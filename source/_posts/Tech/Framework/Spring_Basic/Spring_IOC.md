---
title: 'Spring IOC'
date: 2019-08-13 18:06:52
tags: 
- Web
categories: 
- Software Development
notshow: true
---

# Inversion of Control (IoC)
Inversion of Control is a concept that you only describe how object should be created but not create by yourself. If an object depends on another, you do not connect them together yourself – you merely describe which objects are needed by which. The IoC container is then responsible for hooking it all up, which reduces code in the application. 
There are two key type Inversion of Control: **1) Dependency Pull** and **2) Dependency Push(Dependency Injection)**.

1. **Dependency Pull**: The objects ask for the dependency by calling a method in a factory class.
```
public class PullExample{
	public void addStockExchangeToBroker(Broker broker){
		SEDaoFactory factory = new SEDaoFactory();
		StockExchangeDao dao = factory.getStockExchange();
		int id = broker.getId();
		StockExchange se = dao.findBrokersStockExchange(id);
		broker.setStockExchange(se);        
    }
}
```
In the above example, the dao object is generated by factory.

2. **Dependency Push (Injection)**:

The object does not ask for it. It also doesn’t care where it came from. It just assumes it is there.

```
public class PushExample {
    private StockExchangeDao dao;
    public void setStockExchangeDao(StockExchangeDao dao){
		this.dao = dao;
    }
    public void addStockExchangeToBroker(Broker broker){
		int id = broker.getId();
		StockExchange se = dao.findBrokersStockExchange(id);
	  	broker.setStockExchange(se);
    }
}
```

The Dependency Push is general better as:
- **The code is more decoupled**
No hard code of dependencies is required for classes. Instead, you configure them outside of the code (in XML in Spring). This makes it easier to inject a different implementation if required.

- **Testability is improved**
As stated previously, the object doesn’t care where the dependencies come from as long as they are there. So it is easy to inject mock objects.


In Spring, we use **Dependency Injection(DI)**.

The purpose of **dependency injection** is to helps in **gluing these classes together** and at the same time **keeping them independent from each other**. This is achieved by injecting one class to another one by IoC container. There are two way to achieve this. 

1. **Constructor Injection** (Passing parameters to the constructor)
```
<bean id="customer" class="com.shihao.Customer">
	<!-- Constructor injection -->
	<constructor-arg value="John Doe"></constructor-arg>
	<constructor-arg ref="address"></constructor-arg>
</bean>

<bean id="address" class="com.shihao.Address">
	<!-- Constructor injection -->
	<constructor-arg value="100"></constructor-arg>
	<constructor-arg value="King Street"></constructor-arg>
	<constructor-arg value="ABC"></constructor-arg>
</bean>
```
2. **Setter Injection** (Post-construction by using setter methods) 
```
<bean id="customer" class="com.shihao.Customer">
	<!-- Get Set method -->
	<property name="custName" value="John Doe"></property>
	<property name="address" ref="address"></property>
</bean>

<bean id="address" class="com.shihao.Address">
	<!-- Get Set method -->
	<property name="doorNo" value="100"></property>
	<property name="zipCode" value="ZIP123"></property>
	<property name="streetName" value="King Street"></property>
</bean>
```

* The ref could be replace by using annotation
* A separate spring.xml file is required

```
// Main App
ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
Customer customer = (Customer) context.getBean("customer");
Address address = (Address) context.getBean("address");
```
* Use ApplicationContext interface and ClassPathXmlApplicationContext to get info from the spring.xml file.



# Summary
Dependency Injection helps to decouple application objects from each other, while AOP helps decouple cross-cutting concerns from the objects that they affect.