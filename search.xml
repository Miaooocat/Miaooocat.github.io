<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java Programming: Principles of Software Design]]></title>
    <url>%2F2019%2F03%2F25%2FJava-Programming-Principles-of-Software-Design%2F</url>
    <content type="text"><![CDATA[About this courseComing Soon Module 1 Searching and Filtering dataAbout this moduleThe first module introduce a data set containing details about earthquakes around the world. It ask to1) Write a program that include multiple classes and arraylist of class types,2) Find the maximum value in an ArrayList,3) Use a Filter interface to search through data,4) Implement interfaces with method signatures and 5) combine several filter together. Relationships Between ClassesPOJO - Plain Old Java Object - is an ordinary Java object, not bound by any special restriction and not requiring any class path.The following code is essentially a POJO 123456789//Classpublic class QuakeEntry &#123; private Location myLocation; private String title; private double depth; private double magnitude; public QuakeEntry(...)&#123; &#125;&#125; 123456public class QuakeEntry &#123; public Location getLocation()&#123;.. public double getDepth()&#123;... public String getInfo()&#123;... ...&#125; 1234567// Objectpublic QuakeEntry(double lat, double lon, double mag, String t double d) &#123; myLocation = new Location(lat, lon); magnitude = mag; title = t; depth = d;&#125; Class in Java can have Has-A and Use-A relationshipC Licensing and APIsAPI: Application programming interface - a set of subroutine definitions, communication protocols, and tools for building software. Benefit of use that includes 1) code are well tested, 2) good documentation, 3) follows standards. Example of Android API (‘Location.java’)https://developer.android.com/reference/android/location/Location.html License: A license is an agreement between a developer and user on how a software product can be used. Example of Licensehttps://www.apache.org/licenses/LICENSE-2.0 Coding notes - Searching data12345// to check if a string start, contain or end with certain partpublic boolean startsWith(String prefix)public boolean endsWith(String prefix)// to check if a string start with certain prefix with an offsetpublic boolean startsWith(String prefix, int toffset) 1234567891011121314151617181920public ArrayList&lt;QuakeEntry&gt; getClosest(ArrayList&lt;QuakeEntry&gt; quakeData, Location current, int howMany) &#123; // Create an empty arraylist for return purpose ArrayList&lt;QuakeEntry&gt; ret = new ArrayList&lt;QuakeEntry&gt;(); // Copy the original list ArrayList&lt;QuakeEntry&gt; quakeData_copy = new ArrayList&lt;QuakeEntry&gt;(quakeData); // Use the inner loop to go over the copied arraylist, searching for closest // Use the outter loop to update return arraylist and copy arraylist for (int i=0;i&lt;howMany;i++)&#123; int miniindex=0; for (int j=0;j&lt;quakeData_copy.size();j++)&#123; QuakeEntry quake = quakeData_copy.get(j); Location temploc = quake.getLocation(); if(temploc.distanceTo(current)&lt;quakeData_copy.get(miniindex).getLocation().distanceTo(current))&#123; miniindex = j; &#125; &#125; ret.add(quakeData_copy.remove(miniindex)); &#125; return ret;&#125; Coding Assignment Week 1 Github: https://github.com/Miaooocat/Java_SoftwareDesignPrinciple_Coursera/tree/master/Week1 InterfacesClasses can implement an interface: * Must define the promised methods * Can be treated as the interface type Coding notes - Filtering dataFirst look at two filters to see similiarity:1234567public ArrayList&lt;QuakeEntry&gt; filterByMagnitude(ArrayList&lt;QuakeEntry&gt; quakeData, double magMin) &#123; ArrayList&lt;QuakeEntry&gt; answer = new ArrayList&lt;QuakeEntry&gt;(); for(QuakeEntry qe : quakeData) &#123; if (qe.getMagnitude() &gt;= magMin) &#123;answer.add(qe);&#125; &#125; return answer;&#125; 1234567public ArrayList&lt;QuakeEntry&gt; filterByDistanceFrom(ArrayList&lt;QuakeEntry&gt; quakeData, double distMax, Location from) &#123; ArrayList&lt;QuakeEntry&gt; answer = new ArrayList&lt;QuakeEntry&gt;(); for(QuakeEntry qe : quakeData) &#123; if (qe.getLocation().distanceTo(from) &lt;= distMax) &#123;answer.add(qe);&#125; &#125; return answer;&#125; The only differece is in the if block. Thus, we could parameterize the above code by filter. In here, filter is an interface.12345678public ArrayList&lt;QuakeEntry&gt;filter (ArrayList&lt;QuakeEntry&gt; quakeData, Filter f) &#123; ArrayList&lt;QuakeEntry&gt; answer = new ArrayList&lt;QuakeEntry&gt; (); for (QuakeEntry qe : quakeData) &#123; if (f.satisfies(qe)) &#123;answer.add(qe);&#125; &#125; return answer;&#125; 123public interface Filter &#123; public boolean satisfies(QuakeEntry qe);&#125; 123456789public class MinMagFilter implements Filter &#123; private double magMin; public MinMagFilter(double min) &#123; magMin = min; &#125; public boolean satisfies(QuakeEntry qe) &#123; return qe.getMagnitude() &gt;= magMin; &#125;&#125; 12345Filter f = new MinMagFilter(4.0);ArrayList&lt;QuakeEntry&gt; largeQuakes = filter(list, f);f = new DistanceFilter(myLoc,100);ArrayList&lt;QuakeEntry&gt; shallowQuakes = filter(list, f); How does Java know which f.satisified to call? The answer is Dynamic dispatch, which is a process of selecting which implementation of a polymorphic operation (method or function) to call at run time.]]></content>
      <categories>
        <category>Software Development</category>
        <category>Course Notes</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
