[{"categories":["Java Language"],"content":"Java keywords reference notes","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"All 48 Java Keywords with Examples Table below lists 48 Keywords in Java. ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:0:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"1) abstract abstract keyword is used to implement the abstraction in java. A method which doesn’t have method definition must be declared as abstract and the class containing it must be declared as abstract. You can’t instantiate abstract classes. Abstract methods must be implemented in the sub classes. You can’t use abstract keyword with variables and constructors. abstract class AbstractClass { abstract void abstractMethod(); } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:1:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"2) assert assert keyword is used in the assertion statements. These statements will enable you to test your assumptions about a program. Assertion statements provide the best way to detect and correct the programming errors. Assertion statements take one boolean expression as input and assumes that this will be always true. If the boolean expression returns false, AssertionError will be thrown. public class MainClass { public static void main(String[] args) { System.out.println(\"Enter your marks\"); Scanner sc = new Scanner(System.in); int marks = sc.nextInt(); assert marks \u003e 35 : \"FAIL\"; } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:2:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"3) boolean boolean keyword is used to define boolean type variables. boolean type variables can hold only two values – either true or false. boolean isActive = true; ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:3:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"4) break The break keyword is used to stop the execution of a loop(for, while, switch-case) based on some condition. public class MainClass { public static void main(String[] args) { for (int i = 0; i \u003c 100; i++) { System.out.println(i); if(i == 50) { break; } } } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:4:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"5) byte byte keyword is used to declare byte type of variables. A byte variable can hold a numeric value in the range from -128 to 127. byte b = 50; ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:5:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"6) switch 7) case Both switch and case keywords are used in the switch-case statement. public class MainClass { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"Enter Day :\"); int day = sc.nextInt(); switch (day) { case 1 : System.out.println(\"SUNDAY\"); break; case 2 : System.out.println(\"MONDAY\"); break; case 3 : System.out.println(\"TUESDAY\"); break; case 4 : System.out.println(\"WEDNESDAY\"); break; case 5 : System.out.println(\"THURSDAY\"); break; case 6 : System.out.println(\"FRIDAY\"); break; case 7 : System.out.println(\"SATURDAY\"); break; default: System.out.println(\"Invalid\"); break; } } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:6:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"8) try 9) catch 10) finally try, catch and finally keywords are used to handle the exceptions in java. The statements which are to be monitored for exceptions are kept in the try block. The exceptions thrown by the try block are caught in the catch block. finally block is always executed. public class MainClass { public static void main(String[] args) { try { int i = Integer.parseInt(\"abc\"); } catch(NumberFormatException ex) { System.out.println(ex); } finally { System.out.println(\"This will be always executed\"); } } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:7:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"11) char char keyword is used to declare primitive char type variables. char represents the characters in java. char a = 'A'; char b = 'B'; char c = 'C'; ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:8:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"12) class class keyword is used to define the classes in java. class MyClass { class MyInnerClass { //Inner Class } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:9:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"13) continue continue keyword is used to stop the execution of current iteration and start the execution of next iteration in a loop. public class MainClass { public static void main(String[] args) { for (int i = 0; i \u003c= 100; i++) { if(i % 5 != 0) { continue; } System.out.println(i); } } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:10:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"14) default default keyword is used to define the default methods in an interface (From Java 8). default keyword is also used in the switch-case statements. interface MyInterface { public default void myDefaultMethod() { System.out.println(\"Default Method\"); } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:11:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"15) do do keyword is used in a do–while loop. do-while loop is used to execute one or more statements repetitively until a condition returns false. public class MainClass { public static void main(String[] args) { int a = 10; int b = 20; do { a = a + b; b = b + 10; System.out.println(\"a = \"+a); System.out.println(\"b = \"+b); } while (a \u003c= 100); } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:12:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"16) double double keyword is used to declare primitive double type of variables. public class MainClass { public static void main(String[] args) { double d1 = 23.56; double d2 = 56.23; double d3 = d1 + d2; System.out.println(d3); } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:13:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"17) if 18) else if and else keywords are used in if-else block. public class MainClass { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"Enter a string :\"); String input = sc.next(); if(input.equalsIgnoreCase(\"JAVA\")) { System.out.println(\"It's JAVA\"); } else { System.out.println(\"It's not JAVA\"); } } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:14:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"19) enum enum keyword is used to define enum types. enum MyEnums { A, B, C, D; } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:15:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"20) extends extends keyword is used in inheritance. It is used when a class extends another class. class SuperClass { //Super Class } class SubClass extends SuperClass { //Sub Class } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:16:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"21) final final keyword is used when a class or a method or a field doesn’t need further modifications. final class can’t be extended, final method can’t be overridden and the value of a final field can’t be changed. A final variable that is not initialized at the time of declaration is known as blank final variable. This can only be initialized in constructor. final class FinalClass { final int finalVariable = 10; final void finalMethod() { //final method } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:17:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"22) float float keyword indicates primitive float type of variables. public class MainClass { public static void main(String[] args) { float f1 = 45.26f; float f2 = 84.25f; float f3 = f2 - f1; System.out.println(f3); } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:18:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"23) for for loop is used to execute the set of statements until a condition is true. public class MainClass { public static void main(String[] args) { for (int i = 0; i \u003c= 10; i++) { System.out.println(i); } } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:19:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"24) implements implements keyword is used while implementing an interface. interface MyInterface { void myMethod(); } class MyClass implements MyInterface { public void myMethod() { System.out.println(\"My Method\"); } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:20:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"25) import import keyword is used to import the members of a particular package into current java file. import java.sql.*; import java.util.Arrays; import java.util.Scanner; ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:21:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"26) instanceOf instanceof operator is used to test whether the object is an instance of the specified type (class/subclass/interface). The syntax for using instanceOf keyword is “Object_Reference instanceOf Type“. class A { } public class MainClass { public static void main(String[] args) { A a = new A(); if(a instanceof A) { System.out.println(\"a is of type A\"); } } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:22:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"27) int int keyword is used to declare primitive integer type of variables. public class MainClass { public static void main(String[] args) { int i1 = 10; int i2 = 20; int i3 = i1 * i2; System.out.println(i3); } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:23:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"28) interface interface keyword is used to define the interfaces in java. interface MyInterface { void myMethod(); } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:24:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"29) long long is used to define the primitive long type variables. public class MainClass { public static void main(String[] args) { long l1 = 101; long l2 = 202; long l3 = l1 + l2; System.out.println(l3); } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:25:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"30) native native keyword is used with a method to indicate that a particular method is implemented in native code using Java Native Interfaces(JNI). class AnyClass { public native void anyMethod(int i, double d); } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:26:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"31) new new keyword is used while creating the instances of a class. class A { } public class MainClass { public static void main(String[] args) { A a = new A(); } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:27:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"32) package Java package is used to categorize the classes and interfaces, provides access protection and removes naming collision.* Package inside the package is called the subpackage. If you import a package (package.* ), subpackages will not be imported. To import subpackage, use import package.classname. The standard of defining package is domain.company.package. eg - com.oracle.database There can be only one public class in a java source file and it must be saved by the public class name. package pack1; class A { } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:28:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"33) private private keyword is used to declare a member of a class as private. private methods and fields are visible within the class in which they are defined. class A { private int i = 111; //private field private void method() { //private method } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:29:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"34) protected protected keyword is used to declare a member of a class as protected. protected members of a class are visible within the package only, but they can be inherited to any sub classes. class A { protected int i = 111; //protected field protected void method() { //protected method } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:30:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"35) public public keyword is used to declare the members of a class or class itself as public. public members of a class are visible from anywhere and they can be inherited to any sub classes. public class A { public int i = 222; //public field public A() { //public constructor } public void method() { //public method } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:31:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"36) return return keyword is used to return the control back to the caller from the method. class A { int method(int i) { return i*i; //method returning a value } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:32:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"37) short short keyword is used to declare primitive short type variables. short s1 = 11; short s2 = 22; ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:33:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"38) static The static can be: variable (class variable), method (class method), block \u0026 nested class. Java static property is shared to all objects, no need to instantiate a class. A static method belongs to the class rather than object of a class. A static method can be invoked without the need for creating an instance of a class. A static method can access static data member and can change the value of it. The static method can not use non static data member or call non-static method directly. this and super cannot be used in static context. The main method is static because object is not required to call static method if it were non-static method, jvm create object first then call main() method that will lead the problem of extra memory allocation. A static block is used to initialize the static data member. It is executed before main method at the time of classloading. A constructor cannot be declared final because it is never inherited. A static final variable that is not initialized at the time of declaration is known as static blank final variable. It can be initialized only in static block class A { static int staticField = 555; //Static Field static void staticMethod() { //Static method } } public class MainClass { public static void main(String[] args) { System.out.println(A.staticField); //Accessing staticField via class name A.staticMethod(); //Accessing staticMethod via class name } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:34:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"39) strictfp strictfp keyword is used to implement the strict precision of floating point calculations on different platforms. strictfp can be used with classes, interfaces and methods. strictfp interface I { //strictfp applied on interface } strictfp class C { //strictfp applied on class } class A { strictfp void method() { //strictfp applied on method } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:35:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"40) super super keyword is used to access super class members inside a sub class. class A { int i; public A(int i) { this.i = i; } void methodA() { System.out.println(i); } } class B extends A { public B() { super(10); //Calling super class constructor } void methodB() { System.out.println(super.i); //accessing super class field super.methodA(); //Calling super class method } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:36:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"41) synchronized synchronized keyword is used to implement the synchronization in java. only one thread can enter into a method or a block which is declared as synchronized. Any thread which wants to enter synchronized method or block must acquire object lock of those methods or blocks. class AnyClass { synchronized void synchronizedMethod() { //Synchronized method } void anyMethod() { synchronized (this) { //Synchronized block } } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:37:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"42) this this keyword is used to access other members of the same class. class AnyClass { int i; AnyClass() { System.out.println(\"First Constructor\"); } AnyClass(int j) { this(); //calling statement to First Constructor System.out.println(\"Second Constructor\"); } void methodOne() { System.out.println(\"From method one\"); } void methodTwo() { System.out.println(this.i); //Accessing same class field this.methodOne(); //Accessing same class method } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:38:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"43) throw throw keyword is used to throw the exceptions manually. public class MainClass { public static void main(String[] args) { try { //throwing NumberFormatException manually throw new NumberFormatException(); } catch(Exception ex) { System.out.println(ex); } } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:39:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"44) throws throws keyword is used to specify the exceptions which the current method may throw. class A { void method() throws NumberFormatException { int i = Integer.parseInt(\"abc\"); } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:40:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"45) transient transient keyword is used in serialization. A variable which is declared as transient will not be eligible for serialization. class MyClass implements Serializable { int a; transient String s; //This will not be serialized double d; } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:41:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"46) void void keyword is used to indicate that method returns nothing. class A { void methodReturnsNothing() { //Method returns no value } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:42:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"47) volatile volatile keyword is used in the concurrent programming. The value of a variable which is declared as volatile will be written into or read from the main memory. class A { public volatile int counter = 0; } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:43:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"48) while while keyword is used in the while loop. public class MainClass { public static void main(String[] args) { int i = 10; while (i \u003c= 100) { System.out.println(i); i = i + 10; } } } ","date":"2019-06-12","objectID":"/notes/java_basic/java_key_words/:44:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java_basic/java_key_words/"},{"categories":["Java Language"],"content":"Java notes","date":"2019-06-13","objectID":"/notes/java_basic/java_feature_execution/","tags":["Java"],"title":"Java Notes(2) Feature and Program Execution","uri":"/notes/java_basic/java_feature_execution/"},{"categories":["Java Language"],"content":"Java Features and Program Execution Java is a programming language and a platform. Platform: Any hardware or software environment in which a program runs, is known as a platform. Since Java has its own runtime environment (JRE) and Application Programming Interface (API), it is called platform. ","date":"2019-06-13","objectID":"/notes/java_basic/java_feature_execution/:0:0","tags":["Java"],"title":"Java Notes(2) Feature and Program Execution","uri":"/notes/java_basic/java_feature_execution/"},{"categories":["Java Language"],"content":"Features of Java : Simple: User friendly syntax based on C++ It has Automatic Garbage Collection It has Rich set of APIs Removed confusing features - explicit pointers, operator overloading, multiple inheritance, etc Object-oriented: In Java, we organize the software as a combination of different types of objects that incorporates both data and behaviour. Based on the concept of Objects, Class, Inheritance, Polymorphism, Abstraction, Encapsulation Platform Independent: Java provides software-based platform. It has two components: JRE (Runtime Environment) API (Application Programming Interface) Java code is compiled by the compiler and converted into bytecode. This bytecode is a platform-independent. Can run on many platforms - Windows, Linux, Mac, etc. Secured: No explicit pointer JVM - java Programs run inside virtual machine sandbox Classloader - adds security by separating the package for the classes of the local file system from those that are imported from network sources. Bytecode Verifier - checks the code fragments for illegal code that can violate access right to objects. Security Manager - determines what resources a class can access such as reading and writing to the local disk. More - developers can add extra security through SSL, JAAS, Cryptography etc. Robust: Good memory management - automatic garbage collection. No pointers - increses security. Exception handling - increses robustness against errors. Strongly typed - every variable must be declared with a data type. Statically typed - type checking of variables is performed at compile time. Architecture-Neutral: There is no implementation dependent features. e.g. size of primitive types is fixed. Portable: Write Once and Run Anywhere. interpreted: Java is compiled to bytecodes, which are interpreted by a Java run-time environment. The interpreter reads bytecode stream then execute the instructions. High-Performance: Uses ByteCode - Java is faster than traditional interpreted languages since byte code is “close” to native code. Just-In-Time (JIT) - it is designed to support JIT compilers, which dynamically compile bytecodes to machine code. Garbage collector - collect the unused memory space and improve the performance of the application. NOTE: Java is still slower than a compiled language like C/C++. Distributed: We can create distributed applications in java. RMI and EJB are used for creating distributed applications. We may access files by calling the methods from any machine on the internet. Multi-threaded: A thread is like a separate program, executing concurrently. We can write Java programs that deal with many tasks at once by defining multiple threads. The main advantage of multi-threading is that it doesn’t occupy memory for each thread. It shares a common memory area. Threads are important for multi-media, Web applications etc. Dynamic: Dynamic Compilation (JIT) - Implementations to gain performance during program execution. The machine code emitted by a dynamic compiler is constructed and optimized at program runtime, the use of dynamic compilation enables optimizations for efficiency. Load on Demand - Loads in classes as they are needed, even from across the network. Dynamic memory allocation - All Java objects are dynamically allocated. Dynamic Polymorphism - Compiler doesn’t know which method to be called in advance. JVM decides which method to called at run time. ","date":"2019-06-13","objectID":"/notes/java_basic/java_feature_execution/:1:0","tags":["Java"],"title":"Java Notes(2) Feature and Program Execution","uri":"/notes/java_basic/java_feature_execution/"},{"categories":["Java Language"],"content":"Java Program Execution Process : ","date":"2019-06-13","objectID":"/notes/java_basic/java_feature_execution/:2:0","tags":["Java"],"title":"Java Notes(2) Feature and Program Execution","uri":"/notes/java_basic/java_feature_execution/"},{"categories":["Java Language"],"content":"JDK - JRE - JVM : Java Development Kit (JDK): It is a collection of development tools including JRE. Java Runtime Environment (JRE): It contains set of libraries and the JVM. Java Virtual Machine (JVM): It is an abstract machine. It is a specification that provides runtime environment in which java bytecode can be executed. The JVM performs following main tasks: Loads code, Verifies code, Executes code and Provides runtime environment. NOTE - JVMs are available for many hardware and software platforms. JVM, JRE and JDK are platform dependent because configuration of each OS differs. But, Java is platform independent. ","date":"2019-06-13","objectID":"/notes/java_basic/java_feature_execution/:3:0","tags":["Java"],"title":"Java Notes(2) Feature and Program Execution","uri":"/notes/java_basic/java_feature_execution/"},{"categories":["Java Language"],"content":"Internal Architecture of JVM : JVM (Java Virtual Machine) has various sub components internally. You can see the most important ones in the above diagram. Class loader sub system: JVM’s class loader sub system performs 3 tasks It loads .class file into memory. It verifies byte code instructions. It allots memory required for the program. Run time data area: This is the memory resource used by JVM and it is divided into 5 parts Class (Method) area: Stores constant pool, field and method data, the code for methods. Heap: Objects are allocated on the heap. Java stacks: Java stacks are the places where the Java methods are executed. A Java stack contains frames. It holds local variables and partial results, and plays a part in method invocation and return. On each frame, a separate method is executed. Each thread has a private JVM stack, created at the same time as thread. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes. Program counter registers: PC (program counter) register. It contains the address of the JVM instruction currently being executed. Native method stacks: Are places where native methods (eg. C language programs, etc) are executed. Native method interface: Native method interface is a program that connects native methods libraries (C header files) with JVM for executing native methods. Native method library: Holds the native libraries information. Execution engine: Just-In-Time(JIT) compiler: It is used to improve the performance. It coverts byte code into machine code. JIT compiles parts of the byte code that have similar functionality at the same time, and hence reduces the amount of time needed for compilation.Here the term ?compiler? refers to a translator from the instruction set of a Java virtual machine (JVM) to the instruction set of a specific CPU. Interpreter: Read bytecode stream then execute the instructions. Virtual processor NOTE - JVM uses optimization technique to decide which part to be interpreted and which part to be used with JIT compiler. ","date":"2019-06-13","objectID":"/notes/java_basic/java_feature_execution/:4:0","tags":["Java"],"title":"Java Notes(2) Feature and Program Execution","uri":"/notes/java_basic/java_feature_execution/"},{"categories":["Java Language"],"content":"Java fundamentals reference notes","date":"2019-06-15","objectID":"/notes/java_basic/java_fundamentals/","tags":["Java"],"title":"Java Notes(3) Java Fundamentals","uri":"/notes/java_basic/java_fundamentals/"},{"categories":["Java Language"],"content":"Data Types in Java Data Type Default Value Default size boolean false 1 bit char '\\u0000' 2 byte byte 0 1 byte short 0 2 byte int 0 4 byte long 0L 8 byte float 0.0f 4 byte double 0.0d 8 byte ","date":"2019-06-15","objectID":"/notes/java_basic/java_fundamentals/:1:0","tags":["Java"],"title":"Java Notes(3) Java Fundamentals","uri":"/notes/java_basic/java_fundamentals/"},{"categories":["Java Language"],"content":"Data Type Promotion in Java : ","date":"2019-06-15","objectID":"/notes/java_basic/java_fundamentals/:2:0","tags":["Java"],"title":"Java Notes(3) Java Fundamentals","uri":"/notes/java_basic/java_fundamentals/"},{"categories":["Java Language"],"content":"Wrapper Classes in Java In Java, there is a wrapper class. This is supported by autoboxing/unboxing feature, which converts primitive into object/object into primitive automatically. Primitive TypeWrapper class booleanBoolean charCharacter byteByte shortShort intInteger longLong floatFloat doubleDouble ","date":"2019-06-15","objectID":"/notes/java_basic/java_fundamentals/:3:0","tags":["Java"],"title":"Java Notes(3) Java Fundamentals","uri":"/notes/java_basic/java_fundamentals/"},{"categories":["Java Language"],"content":"Operators in Java Operator TypeCategoryPrecedence Unarypostfixexpr++ expr-- prefix++expr --expr +expr -expr ~ ! Arithmeticmultiplicative* / % additive+ - Shiftshift\u003c\u003c \u003e\u003e \u003e\u003e\u003e Relationalcomparison\u003c \u003e \u003c= \u003e= instanceof equality== != Bitwisebitwise AND\u0026 bitwise exclusive OR^ bitwise inclusive OR| Logicallogical AND\u0026\u0026 logical OR|| Ternaryternary? : Assignmentassignment= += -= *= /= %= \u0026= ^= |= \u003c\u003c= \u003e\u003e= \u003e\u003e\u003e= ","date":"2019-06-15","objectID":"/notes/java_basic/java_fundamentals/:4:0","tags":["Java"],"title":"Java Notes(3) Java Fundamentals","uri":"/notes/java_basic/java_fundamentals/"},{"categories":["Java Language"],"content":"Java Naming Conventions : NameConvention class name should start with uppercase letter and be a noun e.g. String, Color, Button, System, Thread etc. interface nameshould start with uppercase letter and be an adjective e.g. Runnable, Remote, ActionListener etc. method nameshould start with lowercase letter and be a verb e.g. actionPerformed(), main(), print(), println() etc. variable nameshould start with lowercase letter e.g. firstName, orderNumber etc. package nameshould be in lowercase letter e.g. java, lang, sql, util etc. constants nameshould be in uppercase letter. e.g. RED, YELLOW, MAX_PRIORITY etc. ","date":"2019-06-15","objectID":"/notes/java_basic/java_fundamentals/:5:0","tags":["Java"],"title":"Java Notes(3) Java Fundamentals","uri":"/notes/java_basic/java_fundamentals/"},{"categories":["Java Language"],"content":"Java Serialization reference notes","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Multithreading in java is a process of executing multiple threads simultaneously. Thread is basically a lightweight sub-process, a smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking. But we use multithreading than multiprocessing because threads share a common memory area. They don’t allocate separate memory area so saves memory, and context-switching between the threads takes less time than process. Thread is executed inside the process. There is context-switching between the threads. There can be multiple processes inside the OS and one process can have multiple threads. Advantages of Multithreading : It doesn’t block the user because threads are independent and you can perform multiple operations at same time. You can perform many operations simultaneously so it saves time. Threads are independent so it doesn’t affect other threads if exception occur in a single thread. ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:0:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Multitasking Multitasking is a process of executing multiple tasks simultaneously. We use multitasking to utilize the CPU. Multitasking can be achieved by two ways: Process-based Multitasking(Multiprocessing) Thread-based Multitasking(Multithreading) Multiprocessing Multithreading Each process have its own address in memory i.e. each process allocates separate memory area. Threads share the same address space. Process is heavyweight. Thread is lightweight. Cost of communication between the process is high. Cost of communication between the thread is low. Context-switching require some time for saving \u0026 loading registers, memory maps, updating lists etc. Context-switching between the threads takes less time than process. NOTE : Context switching (aka process/task switching) is the switching of the CPU (central processing unit) from one process or thread to another. ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:1:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Life Cycle of a Thread The life cycle of the thread in java is controlled by JVM. The java thread states are as follows: New - The thread is in new state if you create an instance of Thread class but before the invocation of start() method. Runnable - The thread is in runnable state after invocation of start() method, but the thread scheduler has not selected it to be the running thread. Running - The thread is in running state if the thread scheduler has selected it. Non-Runnable (Blocked) - This is the state when the thread is still alive, but is currently not eligible to run. Terminated - A thread is in terminated or dead state when its run() method exits. NOTE : According to sun, there is only 4 states in thread life cycle in java new, runnable, non-runnable and terminated. There is no running state. ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:2:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Creating a Thread There are two ways to create a thread: By extending Thread class By implementing Runnable interface. Thread class: Thread class provide constructors and methods to create and perform operations on a thread.Thread class extends Object class and implements Runnable interface. Commonly used Constructors of Thread class: Thread() Thread(String name) Thread(Runnable r) Thread(Runnable r,String name) Commonly used methods of Thread class: public void run(): is used to perform action for a thread. public void start(): starts the execution of the thread.JVM calls the run() method on the thread. public void sleep(long miliseconds): Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds. public void join(): waits for a thread to die. public void join(long miliseconds): waits for a thread to die for the specified miliseconds. public int getPriority(): returns the priority of the thread. public int setPriority(int priority): changes the priority of the thread. public String getName(): returns the name of the thread. public void setName(String name): changes the name of the thread. public Thread currentThread(): returns the reference of currently executing thread. public int getId(): returns the id of the thread. public Thread.State getState(): returns the state of the thread. public boolean isAlive(): tests if the thread is alive. public void yield(): causes the currently executing thread object to temporarily pause and allow other threads to execute. public void suspend(): is used to suspend the thread(depricated). public void resume(): is used to resume the suspended thread(depricated). public void stop(): is used to stop the thread(depricated). public boolean isDaemon(): tests if the thread is a daemon thread. public void setDaemon(boolean b): marks the thread as daemon or user thread. public void interrupt(): interrupts the thread. public boolean isInterrupted(): tests if the thread has been interrupted. public static boolean interrupted(): tests if the current thread has been interrupted. Runnable interface: The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. Runnable interface have only one method named run(). public void run(): is used to perform action for a thread. Starting a thread: start() method of Thread class is used to start a newly created thread. It performs following tasks: A new thread starts(with new callstack). The thread moves from New state to the Runnable state. When the thread gets a chance to execute, its target run() method will run. ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:3:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Creating Thread Codes : Thread Example by extending Thread class class Multi extends Thread{ public void run(){ System.out.println(\"thread is running...\"); } public static void main(String args[]){ Multi t1=new Multi(); t1.start(); } } Thread Example by implementing Runnable interface class Multi3 implements Runnable{ public void run(){ System.out.println(\"thread is running...\"); } public static void main(String args[]){ Multi3 m1=new Multi3(); Thread t1 =new Thread(m1); t1.start(); } } ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:4:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Thread Scheduler in Java Thread scheduler in java is the part of the JVM that decides which thread should run. There is no guarantee that which runnable thread will be chosen to run by the thread scheduler. Only one thread at a time can run in a single process. The thread scheduler mainly uses preemptive or time slicing scheduling to schedule the threads. Difference between preemptive scheduling and time slicing Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors. NOTE : We cannot start a thread twice. After starting a thread, it can never be started again. If you does so, an IllegalThreadStateException is thrown the moment it is started for the second time. ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:5:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"sleep() method in Java The sleep() method of Thread class is used to sleep a thread for the specified amount of time. The Thread class provides two methods for sleep : public static void sleep(long miliseconds)throws InterruptedException public static void sleep(long miliseconds, int nanos)throws InterruptedException Thread.sleep(500) At a time only one thread is executed. If you sleep a thread for the specified time,the thread shedular picks up another thread and so on. ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:6:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"run() method in Java In Java, Each thread starts in a separate call stack. Invoking the run() method from main thread, the run() method goes onto the current call stack rather than at the beginning of a new call stack. Problem if you use run() directly instead of start() “ There is no context-switching in the below program because here t1 and t2 will be treated as normal object not thread object. Output will be : 1 2 3 4 5 1 2 3 4 5 (One object will finish before starting next) class TestCallRun extends Thread{ public void run(){ for(int i=1;i\u003c5;i++){ try{Thread.sleep(500);}catch(InterruptedException e){System.out.println(e);} System.out.println(i); } } public static void main(String args[]){ TestCallRun2 t1=new TestCallRun2(); TestCallRun2 t2=new TestCallRun2(); t1.run(); t2.run(); } } } } ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:7:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"join() method in Java Java Thread join() method can be used to pause the current thread execution, until the specified thread is dead. There are three join methods : public void join() public void join(long millis) public void join(long millis, int nanos) Examples : t1.join(); \\\\Current thread will be paused, until t1 is dead. (t1 will start executing) t1.join(1500); \\\\Current thread will be paused, t1 will execute for 1500 milliseconds. ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:8:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Naming Thread The Thread class provides methods to change and get the name of a thread. By default, each thread has a name i.e. thread-0, thread-1 and so on. But, we can change the name of the thread by using setName() method. public String getName(): is used to get the name of a thread. t1.getName() public void setName(String name): is used to change the name of a thread. t1.setName(\"My sweet thread\"); Getting the Current Thread public static Thread currentThread(): The currentThread() method returns a reference of currently executing thread. public void run(){ System.out.println(Thread.currentThread().getName()); } ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:9:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Priority of a Thread Each thread have a priority. Priorities are represented by a number between 1 and 10. In most cases, thread schedular schedules the threads according to their priority (known as preemptive scheduling). But it is not guaranteed because it depends on JVM specification that which scheduling it chooses. The 3 constants defined in Thread class: public static int MIN_PRIORITY public static int NORM_PRIORITY public static int MAX_PRIORITY Default priority of a thread is 5 (NORM_PRIORITY). The value of MIN_PRIORITY is 1 and the value of MAX_PRIORITY is 10. System.out.println(\"thread priority is:\"+t1.getPriority()); t1.setPriority(Thread.MIN_PRIORITY); ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:10:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Daemon Thread Daemon thread in java is a service provider thread that provides services to the user thread. It has no role in life than to serve user threads. Its life depends on user threads i.e. when all the user threads dies, JVM terminates this thread automatically. It is a low priority thread. There are many java daemon threads running automatically e.g. gc, finalizer etc. NOTE : You can see all the detail by typing the jconsole in the command prompt. The jconsole tool provides information about the loaded classes, memory usage, running threads etc. Methods for Daemon Thread: public void setDaemon(boolean status): is used to mark the current thread as daemon thread or user thread. t1.setDaemon(true); //Now, t1 is a daemon thread t1.start() public boolean isDaemon(): is used to check that current is daemon. if(t1.isDaemon()) { ... } If you want to make a user thread as Daemon, it must not be started otherwise it will throw IllegalThreadStateException. t1.start(); t1.setDaemon(true); //will Throw Exception Here ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:11:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Java Thread Pool Java Thread pool represents a group of worker threads that are waiting for the job and reuse many times. In case of thread pool, a group of fixed size threads are created. A thread from the thread pool is pulled out and assigned a job by the service provider. After completion of the job, thread is contained in the thread pool again. Advantage of Java Thread Pool is Better performance. It saves time because there is no need to create new thread. Real time usage: It is used in Servlet and JSP where container creates a thread pool to process the request. Example Syntax: ExecutorService executor = Executors.newFixedThreadPool(5); //creating a pool of 5 threads Runnable worker = new ... executor.execute(worker); //calling execute method of ExecutorService ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:12:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"ThreadGroup Class in Java Java provides a convenient way to group multiple threads in a single object. In such way, we can suspend, resume or interrupt group of threads by a single method call. Java thread group is implemented by java.lang.ThreadGroup class. NOTE : Now suspend(), resume() and stop() methods are deprecated. Constructors of ThreadGroup class : No.ConstructorDescription 1)ThreadGroup(String name)creates a thread group with given name. 2)ThreadGroup(ThreadGroup parent, String name)creates a thread group with given parent group and name. Important methods of ThreadGroup class : No.MethodDescription 1)int activeCount()returns no. of threads running in current group. 2)int activeGroupCount()returns a no. of active group in this thread group. 3)void destroy()destroys this thread group and all its sub groups. 4)String getName()returns the name of this group. 5)ThreadGroup getParent()returns the parent of this group. 6)void interrupt()interrupts all threads of this group. 7)void list()prints information of this group to standard console. Creating group of threads : ThreadGroup tg1 = new ThreadGroup(\"Group A\"); Thread t1 = new Thread(tg1,new MyRunnable(),\"one\"); Thread t2 = new Thread(tg1,new MyRunnable(),\"two\"); Thread t3 = new Thread(tg1,new MyRunnable(),\"three\"); Now all 3 threads belong to one group. Here, tg1 is the thread group name, MyRunnable is the class that implements Runnable interface and “one”, “two” and “three” are the thread names. Now we can interrupt all threads by a single line of code only. Thread.currentThread().getThreadGroup().interrupt(); ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:13:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Java Shutdown Hook The shutdown hook can be used to perform cleanup resource or save the state when JVM shuts down normally or abruptly. Performing clean resource means closing log file, sending some alerts or something else. So if you want to execute some code before JVM shuts down, use shutdown hook. The JVM shuts down when: user presses ctrl+c on the command prompt, System.exit(int) method is invoked, user logoff, shutdown, etc. The addShutdownHook() method of Runtime class is used to register the thread with the Virtual Machine. public void addShutdownHook(Thread hook){} The object of Runtime class can be obtained by calling the static factory method getRuntime() Runtime r = Runtime.getRuntime(); Factory method: The method that returns the instance of a class is known as factory method. NOTE: The shutdown sequence can be stopped by invoking the halt(int) method of Runtime class. ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:14:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Multitask Each thread run in a separate callstack. class TestMultitasking1 extends Thread{ public void run(){ System.out.println(\"task one\"); } public static void main(String args[]){ TestMultitasking1 t1=new TestMultitasking1(); TestMultitasking1 t2=new TestMultitasking1(); t1.start(); t2.start(); } } ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:15:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Java Garbage Collection In Java, garbage means unreferenced objects. Garbage Collection is process of reclaiming the runtime unused memory automatically. In other words, it is a way to destroy the unused objects. To do so, we were using free() function in C language and delete() in C++. But, in java it is performed automatically. So, java provides better memory management. Advantage of Garbage Collection: It makes java memory efficient because garbage collector removes the unreferenced objects from heap memory. It is automatically done by the garbage collector(a part of JVM) so we don’t need to make extra efforts. How an object is unreferenced: By nulling the reference Employee e=new Employee(); e=null; By assigning a reference to another Employee e1=new Employee(); Employee e2=new Employee(); e1=e2; //now, the first object referred by e1 is available for garbage collection By annonymous object new Employee(); etc. finalize() method The finalize() method is invoked each time before the object is garbage collected. This method can be used to perform cleanup processing. This method is defined in Object class as: protected void finalize(){} NOTE : The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing (destroying remaining objects). gc() method The gc() method is used to invoke the garbage collector to perform cleanup processing. The gc() is found in System and Runtime classes. This method is defined in System class as: public static void gc(){} System.gc(); // explicitely invoking the garbage collector NOTE : Garbage collection is performed by a daemon thread called Garbage Collector(GC). This thread calls the finalize() method before object is garbage collected. NOTE : Neither finalization nor garbage collection is guaranteed. ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:16:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Java Runtime Class Java Runtime class is used to interact with java runtime environment. Java Runtime class provides methods to execute a process, invoke GC, get total and free memory etc. There is only one instance of java.lang.Runtime class is available for one java application. The Runtime.getRuntime() method returns the singleton instance of Runtime class. Important methods of Java Runtime class : No.MethodDescription 1)public static Runtime getRuntime()returns the instance of Runtime class. 2)public void exit(int status)terminates the current virtual machine. 3)public void addShutdownHook(Thread hook)registers new hook thread. 4)public Process exec(String command)throws IOExceptionexecutes given command in a separate process. 5)public int availableProcessors()returns no. of available processors. 6)public long freeMemory()returns amount of free memory in JVM. 7)public long totalMemory()returns amount of total memory in JVM. ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:17:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Java Runtime exec() method public class Runtime1{ public static void main(String args[])throws Exception{ Runtime.getRuntime().exec(\"notepad\"); // Will open a new notepad } } Shutdown system in Java : Runtime.getRuntime().exec(\"shutdown -s -t 0\"); // Shutdown You can use shutdown -s command to shutdown system. For windows OS, you need to provide full path of shutdown command e.g. c:\\Windows\\System32\\shutdown. Here you can use -s switch to shutdown system, -r switch to restart system and -t switch to specify time delay. Runtime.getRuntime().exec(\"c:\\\\Windows\\\\System32\\\\shutdown -s -t 0\"); // Windows Shutdown Runtime.getRuntime().exec(\"shutdown -r -t 0\"); // Restart Runtime availableProcessors() method : System.out.println(Runtime.getRuntime().availableProcessors()); Runtime freeMemory() and totalMemory() method : System.out.println(\"Total Memory: \"+Runtime.totalMemory()); System.out.println(\"Free Memory: \"+Runtime.freeMemory()); ","date":"2019-08-06","objectID":"/notes/java_basic/java_multithreading/:18:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java_basic/java_multithreading/"},{"categories":["Java Language"],"content":"Java networking reference notes","date":"2019-08-02","objectID":"/notes/java_basic/java_networking/","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java_basic/java_networking/"},{"categories":["Java Language"],"content":"Java Networking is a concept of connecting two or more computing devices together so that we can share resources. Java Socket Programming provides facility to share data between different computing devices. Advantage of Java Networking : sharing resources centralized software management ","date":"2019-08-02","objectID":"/notes/java_basic/java_networking/:0:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java_basic/java_networking/"},{"categories":["Java Language"],"content":"Java Networking Terminology : Some of the widely used java networking terminologies are as follows: IP Address IP address is a unique number assigned to a node of a network e.g. 192.168.0.1. It is composed of octets that range from 0 to 255. It is a logical address that can be changed. Protocol A protocol is a set of rules basically that is followed for communication. For example: TCP, FTP, Telnet, SMTP, POP, etc. Port Number The port number is used to uniquely identify different applications. It acts as a communication endpoint between applications. The port number is associated with the IP address for communication between two applications. MAC Address MAC (Media Access Control) Address is a unique identifier of NIC (Network Interface Controller). A network node can have multiple NIC but each with unique MAC. The main difference between MAC and IP address is that, MAC Address is used to ensure the physical address of computer. It uniquely identifies the devices on a network. While IP address are used to uniquely identifies the connection of network with that device take part in a network. Socket A socket is an endpoint between two way communication. More details in “Socket” section below. Connection-oriented protocol In connection-oriented protocol, acknowledgement is sent by the receiver. So, it is reliable but slow. The example of connection-oriented protocol is TCP. Connection-less protocol In connection-less protocol, acknowledgement is not sent by the receiver. So, it is not reliable but fast. The example of connection-less protocol is UDP. ","date":"2019-08-02","objectID":"/notes/java_basic/java_networking/:1:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java_basic/java_networking/"},{"categories":["Java Language"],"content":"java.net package The java.net package provides many classes to deal with networking applications in Java. A list of these classes is given below: Authenticator CacheRequest CacheResponse ContentHandler CookieHandler CookieManager DatagramPacket DatagramSocket DatagramSocketImpl InterfaceAddress JarURLConnection MulticastSocket InetSocketAddress InetAddress Inet4Address Inet6Address IDN HttpURLConnection HttpCookie NetPermission NetworkInterface PasswordAuthentication Proxy ProxySelector ResponseCache SecureCacheResponse ServerSocket Socket SocketAddress SocketImpl SocketPermission StandardSocketOptions URI URL URLClassLoader URLConnection URLDecoder URLEncoder URLStreamHandler ","date":"2019-08-02","objectID":"/notes/java_basic/java_networking/:2:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java_basic/java_networking/"},{"categories":["Java Language"],"content":"Java Socket Programming Java Socket programming is used for communication between the applications running on different JRE. Java Socket programming can be connection-oriented or connection-less. Socket and ServerSocket classes are used for connection-oriented socket programming and DatagramSocket and DatagramPacket classes are used for connection-less socket programming. The client in socket programming must know two information: IP Address of Server Port number. ","date":"2019-08-02","objectID":"/notes/java_basic/java_networking/:3:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java_basic/java_networking/"},{"categories":["Java Language"],"content":"Socket Class : A socket is simply an endpoint for communications between the machines. The Socket class can be used to create a socket. Important methods : MethodDescription 1) public InputStream getInputStream()returns the InputStream attached with this socket. 2) public OutputStream getOutputStream()returns the OutputStream attached with this socket. 3) public synchronized void close()closes this socket ","date":"2019-08-02","objectID":"/notes/java_basic/java_networking/:3:1","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java_basic/java_networking/"},{"categories":["Java Language"],"content":"ServerSocket Class : The ServerSocket class can be used to create a server socket. This object is used to establish communication with the clients. Important methods : MethodDescription 1) public Socket accept()returns the socket and establish a connection between server and client. 2) public synchronized void close()closes the server socket. ","date":"2019-08-02","objectID":"/notes/java_basic/java_networking/:3:2","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java_basic/java_networking/"},{"categories":["Java Language"],"content":"Example of Java Socket Programming ","date":"2019-08-02","objectID":"/notes/java_basic/java_networking/:4:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java_basic/java_networking/"},{"categories":["Java Language"],"content":"Creating Server : ServerSocket ss = new ServerSocket(6666); Socket s = ss.accept(); //establishes connection and waits for the client ","date":"2019-08-02","objectID":"/notes/java_basic/java_networking/:4:1","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java_basic/java_networking/"},{"categories":["Java Language"],"content":"Creating Client : Socket s = new Socket(\"localhost\",6666); ","date":"2019-08-02","objectID":"/notes/java_basic/java_networking/:4:2","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java_basic/java_networking/"},{"categories":["Java Language"],"content":"Java Serialization reference notes","date":"2019-07-30","objectID":"/notes/java_basic/java_serialization/","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java_basic/java_serialization/"},{"categories":["Java Language"],"content":"Serialization in java is a mechanism of writing the state of an object into a byte stream. It is mainly used in Hibernate, RMI, JPA, EJB and JMS technologies. The reverse operation of serialization is called deserialization. Advantage of Java Serialization : It is mainly used to travel object’s state on the network (known as marshaling). java.io.Serializable interface : Serializable is a marker interface (has no data member and method). It is used to “mark” java classes so that objects of these classes may get certain capability. The Cloneable and Remote are also marker interfaces. It must be implemented by the class whose object you want to persist. The String class and all the wrapper classes implements java.io.Serializable interface by default. ","date":"2019-07-30","objectID":"/notes/java_basic/java_serialization/:0:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java_basic/java_serialization/"},{"categories":["Java Language"],"content":"ObjectOutputStream class The ObjectOutputStream class is used to write primitive data types and Java objects to an OutputStream. Only objects that support the java.io.Serializable interface can be written to streams. Constructor : public ObjectOutputStream(OutputStream out) throws IOException {} Above constructor creates an ObjectOutputStream that writes to the specified OutputStream. Important Methods : MethodDescription 1) public final void writeObject(Object obj) throws IOException {}writes the specified object to the ObjectOutputStream. 2) public void flush() throws IOException {}flushes the current output stream. 3) public void close() throws IOException {}closes the current output stream. ","date":"2019-07-30","objectID":"/notes/java_basic/java_serialization/:1:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java_basic/java_serialization/"},{"categories":["Java Language"],"content":"Example of Java Serialization Example to serialize the object of Student class. import java.io.*; class Persist{ public static void main(String args[])throws Exception{ Student s1 =new Student(211,\"John\"); FileOutputStream fout=new FileOutputStream(\"f.txt\"); ObjectOutputStream out=new ObjectOutputStream(fout); out.writeObject(s1); out.flush(); System.out.println(\"success\"); } } ","date":"2019-07-30","objectID":"/notes/java_basic/java_serialization/:2:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java_basic/java_serialization/"},{"categories":["Java Language"],"content":"Deserialization in java Deserialization is the process of reconstructing the object from the serialized state.It is the reverse operation of serialization. ","date":"2019-07-30","objectID":"/notes/java_basic/java_serialization/:3:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java_basic/java_serialization/"},{"categories":["Java Language"],"content":"ObjectInputStream class An ObjectInputStream deserializes objects and primitive data written using an ObjectOutputStream. Constructor : public ObjectInputStream(InputStream in) throws IOException {} Above constructor creates an ObjectInputStream that reads from the specified InputStream. Important Methods : MethodDescription 1) public final Object readObject() throws IOException, ClassNotFoundException{}reads an object from the input stream. 2) public void close() throws IOException {}closes ObjectInputStream. ","date":"2019-07-30","objectID":"/notes/java_basic/java_serialization/:4:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java_basic/java_serialization/"},{"categories":["Java Language"],"content":"Example of Java Deserialization Example to deserialize the object of Student class. import java.io.*; class Depersist{ public static void main(String args[])throws Exception{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(\"f.txt\")); Student s=(Student)in.readObject(); System.out.println(s.id+\" \"+s.name); in.close(); } } ","date":"2019-07-30","objectID":"/notes/java_basic/java_serialization/:5:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java_basic/java_serialization/"},{"categories":["Java Language"],"content":"Serialization Rules Serialization with Inheritance (IS-A Relationship) : If a class implements serializable then all its sub classes will also be serializable. Parent class properties are inherited to subclasses so if parent class is Serializable, subclass would also be. Serialization with Aggregation (HAS-A Relationship) : If a class has a reference of another class, all the references must be Serializable otherwise serialization process will not be performed. In such case, NotSerializableException is thrown at runtime. All the objects within an object must be Serializable. Serialization with static data member : If there is any static data member in a class, it will not be serialized because static is the part of class not object. Serialization with array or collection : In case of array or collection, all the objects of array or collection must be serializable. If any object is not serialiizable, serialization will be failed. ","date":"2019-07-30","objectID":"/notes/java_basic/java_serialization/:6:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java_basic/java_serialization/"},{"categories":["Java Language"],"content":"Externalizable in Java The Externalizable interface provides the facility of writing the state of an object into a byte stream in compress format. It is not a marker interface. The Externalizable interface provides two methods: public void writeExternal(ObjectOutput out) throws IOException public void readExternal(ObjectInput in) throws IOException ","date":"2019-07-30","objectID":"/notes/java_basic/java_serialization/:7:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java_basic/java_serialization/"},{"categories":["Java Language"],"content":"Java Transient Keyword If you don’t want to serialize any data member of a class, you can mark it as transient. Example : transient int age; //It will not be serialized ","date":"2019-07-30","objectID":"/notes/java_basic/java_serialization/:8:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java_basic/java_serialization/"},{"categories":["Java Language"],"content":"Java OOP reference notes","date":"2019-06-17","objectID":"/notes/java_basic/java_oop/","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java_basic/java_oop/"},{"categories":["Java Language"],"content":"Object Oriented Object-Oriented Programming is a methodology or paradigm to design a program using classes and objects. It simplifies the software development and maintenance. ","date":"2019-06-17","objectID":"/notes/java_basic/java_oop/:1:0","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java_basic/java_oop/"},{"categories":["Java Language"],"content":"Class A class in Java can contain: field(variable, attribute), methods, constructors, blocks, nested class and interface. Object is an instance of a class. There is only one way to define class in java using class keyword. The Object class is the parent class of all the classes in java by default. ","date":"2019-06-17","objectID":"/notes/java_basic/java_oop/:1:1","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java_basic/java_oop/"},{"categories":["Java Language"],"content":"Constructor Constructor in java is a special type of method that is used to initialize the object. If there is no constructor in a class, compiler automatically creates a default constructor. There is no copy constructor in java. But, we can copy the values of one object to another like copy constructor in C++. A constructor can perform other tasks instead of initialization like object creation, starting a thread, calling method etc. You can perform any operation in the constructor as you perform in the method. Constructor must not have return type. Constructor name must be same as the class name. super() is added in each class constructor automatically by compiler if there is no super() or this() ","date":"2019-06-17","objectID":"/notes/java_basic/java_oop/:1:2","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java_basic/java_oop/"},{"categories":["Java Language"],"content":"Instance initializer block Instance Initializer block is used to initialize the instance data member. It is created when instance of the class is created. It runs each time when object of the class is created. It is invoked after the parent class constructor is invoked (i.e. after super() constructor call). The instance Initializer block comes in the order in which they appear. ","date":"2019-06-17","objectID":"/notes/java_basic/java_oop/:1:3","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java_basic/java_oop/"},{"categories":["Java Language"],"content":"Four Pillars of OOP The main concepts in object oriented programming are Inheritance, Polymorphism, Abstraction, Encapsulation. ","date":"2019-06-17","objectID":"/notes/java_basic/java_oop/:2:0","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java_basic/java_oop/"},{"categories":["Java Language"],"content":"Inheritance Inheritance (IS-A) is a mechanism in which one object acquires all the properties and behaviors of parent object. The extends keyword indicates that you are making a new class that derives from an existing class. Multiple inheritance is not supported in Java through class. We can use Interface to perform it. To reduce the complexity and simplify the language, multiple inheritance is not supported in java. If a class have an entity reference, it is known as Aggregation (HAS-A relationship). Inheritance should be used only if the relationship is-a is maintained throughout the lifetime of the objects involved; otherwise, aggregation is the best choice. ","date":"2019-06-17","objectID":"/notes/java_basic/java_oop/:2:1","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java_basic/java_oop/"},{"categories":["Java Language"],"content":"Polymorphism Polymorphism is a concept by which we can perform a single action by different ways. There are two types of polymorphism in java: compile time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding. If you overload static method in java, it is the example of compile time polymorphism. In Runtime polymorphism (Dynamic Method Dispatch), an overridden method is resolved at runtime rather than compile-time. A Virtual Method is an inheritable and overridable method for which dynamic dispatch is facilitated. All non-static, non-final and non-private methods are Virtual Methods by default. When reference variable of Parent class refers to the object of Child class, it is known as upcasting. Method is overridden not the data members, so runtime polymorphism can’t be achieved by data members. Connecting a method call to the method body is known as binding. There are two types of binding : Static binding (early binding) and Dynamic binding (late binding). Method Overloading (compile time polymorphism) If a class has multiple methods having same name but different in parameters, it is known as Method Overloading. There are two ways to overload the method in java : by changing number of arguments, by changing the data type. In Java, Method Overloading is not possible by changing the return type of the method only because of ambiguity. Compile Time Error is better than Run Time Error. So, java compiler renders compiler time error if you declare the same method having same parameters. We can also overload Java main() method, but JVM calls main() method which receives string array as arguments only. One type is promoted to another implicitly if no matching datatype is found. eg. byte can be promoted to short, int, etc. If there are no matching type arguments method, and each method promotes similar number of arguments, there will be ambiguity. One type is not de-promoted implicitly for example double cannot be depromoted to any type implicitly. Method Overriding (runtime polymorphism) If subclass (child class) has the same method as declared in the parent class, it is known as method overriding. Method must have same name and parameters as in the parent class for overriding. Method overriding is used to provide specific implementation of a method that is already provided by its super class. Also used for runtime polymorphism. We cannot override static method (not also main method) because static method is bound with class whereas instance method is bound with object. Static belongs to class area and instance belongs to heap area. Method Overriding with Access Modifier: if you are overriding a method, overridden method (i.e. declared in subclass) must not be more restrictive. Covariant Return Type: It is possible to override method by changing the return type if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type. ","date":"2019-06-17","objectID":"/notes/java_basic/java_oop/:2:2","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java_basic/java_oop/"},{"categories":["Java Language"],"content":"Abstraction Abstraction is a process of hiding the implementation details and showing only functionality to the user. There are two ways to achieve abstraction in java : Abstract class and Interface. Abstract class A class that is declared as abstract (keyword) is abstract class. It can have abstract and non-abstract methods. A method that is declared as abstract and does not have implementation is abstract method. Any method with a body is non-abstract method. An abstract class can have data member, abstract method, method body, constructor and even main() method. If there is any abstract method in a class, that class must be abstract. If extending any abstract class that have abstract method, we must either provide the implementation of the method or make this class abstract. Interface An interface in java is a blueprint of a class. It has static constants and abstract methods. Since Java 8, we can have method body in interface. But we need to make it default or static method. The interface is a mechanism to achieve abstraction. It represents IS-A relationship. By using interface, we can support multiple inheritance. It can be also used to achieve loose coupling (coupling is degree of direct knowledge that one element has of another). The Java compiler adds public \u0026 abstract before the interface method. Adds public, static \u0026 final before data members. A class extends another class, an interface extends another interface but a class implements an interface. Multiple inheritance is not supported by class because of ambiguity. But, supported by interface because there is no ambiguity as implementation is provided by the implementation class. An interface with no member is called marker/tagged interface. For example: Serializable, Cloneable, Remote etc. Marker interface are used to provide essential information to JVM, so that JVM may perform some useful operation. An interface can have another interface i.e. known as nested interface. ","date":"2019-06-17","objectID":"/notes/java_basic/java_oop/:2:3","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java_basic/java_oop/"},{"categories":["Java Language"],"content":"Encapsulation Encapsulation is a process of wrapping code and data together into a single unit. To create a fully encapsulated class, make all data members of the class private, \u0026 use setter/getter methods to access data. By providing only setter or getter method, you can make the class read-only or write-only. ","date":"2019-06-17","objectID":"/notes/java_basic/java_oop/:2:4","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java_basic/java_oop/"},{"categories":["Java Language"],"content":"Java Generic notes","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Generic Classes A generic class declaration looks like a non-generic class declaration, except that the class name is followed by a type parameter section. The type parameter section of a generic class can have one or more type parameters separated by commas. These classes are known as parameterized classes or parameterized types because they accept one or more parameters. Syntax: public class Box\u003cT\u003e { private T t; } Box − Box is a generic class. T − The generic type parameter passed to generic class. It can take any Object. t − Instance of generic type T. ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:1:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Naming Conventions By convention, type parameter names are named as single, uppercase letters so that a type parameter can be distinguished easily with an ordinary class or interface name. Following is the list of commonly used type parameter names − E − Element (mainly used by Java Collections framework) K − Key (mainly used to represent key of a map) V − Value (mainly used to represent value of a map) N − Number (represents numbers) T − Type (represents first generic type parameter) S, U, V, etc − 2nd, 3rd, 4th Types ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:2:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Type Inference Type inference represents the Java compiler’s ability to look at a method invocation and its corresponding declaration to check and determine the type argument(s). The inference algorithm checks the types of the arguments and, if available, assigned type is returned. Inference algorithms tries to find a specific type which can fullfill all type parameters. Compiler generates unchecked conversion warning in-case type inference is not used. Syntax: Box\u003cInteger\u003e integerBox = new Box\u003c\u003e(); Box − Box is a generic class. − The diamond operator denotes type inference. Using diamond operator, compiler determines the type of the parameter. This operator is avalilable from Java SE 7 version onwards. ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:3:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Generic Methods You can write a single generic method declaration that can be called with arguments of different types. Based on the types of the arguments passed to the generic method, the compiler handles each method call appropriately. Following are the rules to define Generic Methods − All generic method declarations have a type parameter section delimited by angle brackets () that precedes the method's return type ( in the next example). Each type parameter section contains one or more type parameters separated by commas. A type parameter, also known as a type variable, is an identifier that specifies a generic type name. The type parameters can be used to declare the return type and act as placeholders for the types of the arguments passed to the generic method, which are known as actual type arguments. A generic method's body is declared like that of any other method. Note that type parameters can represent only reference types, not primitive types (like int, double and char). public static \u003cE\u003e void printArray( E[] inputArray ) { // Display array elements for(E element : inputArray) { System.out.printf(\"%s \", element); } System.out.println(); } ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:4:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Multiple Type Parameters A Generic class can have muliple type parameters. Following example will showcase above mentioned concept. public class Box\u003cS,T\u003e { private T t; private S s; } ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:5:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Parameterized Types A Generic class can have parameterized types where a type parameter can be substituted with a parameterized type. Parameterized Types are types that take other types as parameters. Eg - Collection, ArrayList, etc. public class Box\u003cS,T\u003e { ... } ... Box\u003cInteger, List\u003cString\u003e\u003e box = new Box\u003cInteger, List\u003cString\u003e\u003e(); //Parameterized Types ... ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:6:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Raw Types A raw type is an object of a generic class or interface if its type arguments are not passed during its creation. Box rawBox = new Box(); ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:7:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Bounded Type Parameters There may be times when you’ll want to restrict the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for. To declare a bounded type parameter, list the type parameter’s name, followed by the extends keyword, followed by its upper bound. Single Bound: public static \u003cT extends Comparable\u003cT\u003e\u003e T maximum(T x, T y, T z) Multiple Bounds: public static \u003cT extends Number \u0026 Comparable\u003cT\u003e\u003e T maximum(T x, T y, T z) maximum − maximum is a generic method. T − The generic type parameter passed to generic method. It can take any Object. The T is a type parameter passed to the generic class Box and should be subtype of Number class and must implments Comparable interface. In case a class is passed as bound, it should be passed first before interface otherwise compile time error will occur. Calling eg.: maximum( 6.6, 8.8, 7.7 ) ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:8:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Collections Framework Examples Java has provided generic support in Collections Framework Interfaces like List, Set, Map, etc. ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:9:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"List List\u003cT\u003e list = new ArrayList\u003cT\u003e(); list − object of List interface. T − The generic type parameter passed during List declaration. The T is a type parameter passed to the generic interface List and its implemenation class ArrayList. ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:9:1","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Set Set\u003cT\u003e set = new HashSet\u003cT\u003e(); set − object of Set Interface. T − The generic type parameter passed during Set declaration. The T is a type parameter passed to the generic interface Set and its implemenation class HashSet. ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:9:2","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Map Map\u003cT\u003e set = new HashMap\u003cT\u003e(); set − object of Map Interface. T − The generic type parameter passed during Map declaration. The T is a type parameter passed to the generic interface Map and its implemenation class HashMap. ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:9:3","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Generics Wild Cards The question mark (?), represents the wildcard, stands for unknown type in generics. ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:10:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Upper Bounded Wildcards There may be times when you’ll want to restrict the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. To declare a upper bounded Wildcard parameter, list the ?, followed by the extends keyword, followed by its upper bound. public static double sum(List\u003c? extends Number\u003e numberlist) { ... } ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:10:1","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Unbounded Wildcards There may be times when any object can be used when a method can be implemented using functionality provided in the Object class or When the code is independent of the type parameter. To declare a Unbounded Wildcard parameter, list the ? only. public static void printAll(List\u003c?\u003e list) { ... } ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:10:2","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Lower Bounded Wildcards There may be times when you’ll want to restrict the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Integer or its superclasses like Number. To declare a lower bounded Wildcard parameter, list the ?, followed by the super keyword, followed by its lower bound. public static void addCat(List\u003c? super Cat\u003e catList) { ... } ... //You can add list of Cat or Animal (super class of the Cat class) addCat(animalList); addCat(catList); ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:10:3","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Type Erasure Generics are used for tighter type checks at compile time and to provide a generic programming. To implement generic behaviour, java compiler apply type erasure. Type erasure is a process in which compiler replaces a generic parameter with actual class or bridge method. In type erasure, compiler ensures that no extra classes are created and there is no runtime overhead. Type Erasure rules: Replace type parameters in generic type with their bound if bounded type parameters are used. Replace type parameters in generic type with Object if unbounded type parameters are used. Insert type casts to preserve type safety. Generate bridge methods to keep polymorphism in extended generic types. ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:11:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Restrictions on Generics No Primitive Types - Using generics, primitive types can not be passed as type parameters. Box\u003cint\u003e intBox = new Box\u003cint\u003e() //Error NOTE: Use Wrappers like Integar instead. No Instance - A type parameter cannot be used to instantiate its object inside a method. public static \u003cT\u003e void add(Box\u003cT\u003e box) //Error NOTE: To achieve such functionality, reflection can be used. No Static field - Using generics, type parameters are not allowed to be static. As static variable is shared among object so compiler can not determine which type to used. class Box\u003cT\u003e { private static T t; //Error } No Cast - Casting to a parameterized type is not allowed unless it is parameterized by unbounded wildcards. Box\u003cInteger\u003e integerBox = new Box\u003cInteger\u003e(); Box\u003cNumber\u003e numberBox = new Box\u003cNumber\u003e(); integerBox = (Box\u003cInteger\u003e)numberBox; //Error: Cannot cast from Box\u003cNumber\u003e to Box\u003cInteger\u003e NOTE: To achive the same, unbounded wildcards can be used. No instanceOf - Because compiler uses type erasure, the runtime does not keep track of type parameters, so at runtime difference between Box and Box cannot be verified using instanceOf operator. ... integerBox instanceof Box\u003cInteger\u003e ... No Array - Arrays of parameterized types are not allowed. Because compiler uses type erasure, the type parameter is replaced with Object and user can add any type of object to the array. And at runtime, code will not able to throw ArrayStoreException. Object[] stringBoxes = new Box\u003cString\u003e[]; //Error No Exceptionn - A generic class is not allowed to extend the Throwable class directly or indirectly. //The generic class Box\u003cT\u003e may not subclass java.lang.Throwable class Box\u003cT\u003e extends Exception {} class Box1\u003cT\u003e extends Throwable {} A method is not allowed to catch an instance of a type parameter. ... catch (T e) ... No Overload - A class is not allowed to have two overloaded methods that can have the same signature after type erasure. ... public void print(List\u003cString\u003e stringList) { } // Error public void print(List\u003cInteger\u003e integerList) { } ","date":"2019-07-05","objectID":"/notes/java_basic/java_generics/:12:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java_basic/java_generics/"},{"categories":["Java Language"],"content":"Java collection reference notes","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"The java.util package contains all the classes and interfaces for Collection framework. Map : An object that maps keys to values. A map is not ordered and cannot contain duplicate keys (but can contain duplicate values). Each key can map to at most one value. Collection : A collection represents a group of objects, known as its elements. The JDK provides implementations of more specific subinterfaces like Set and List. List : A list is an ordered list of objects, where the same object may well appear more than once. For example: [1, 7, 1, 3, 1, 1, 1, 5]. It makes sense to talk about the “third element” in a list. You can add an element anywhere in the list, change an element anywhere in the list, or remove an element from any position in the list. Queue : A queue is also ordered, but you’ll only ever touch elements at one end. All elements get inserted at the “end” and removed from the “beginning” (or head) of the queue. You can find out how many elements are in the queue, but you can’t find out what, say, the “third” element is. You’ll see it when you get there. Set : A set is not ordered and cannot contain duplicates. Any given object either is or isn’t in the set. {7, 5, 3, 1} is the exact same set as {1, 7, 3, 5}. You again can’t ask for the “third” element or even the “first” element, since they are not in any particular order. You can add or remove elements, and you can find out if a certain element exists. ListSetQueueMap OrderYesNoYesNo DuplicatesYesNoYesNo (Allow duplicate values not keys) Null ValuesYesSingle NullYes (LinkedList Queue). No (Priority Queue).Single null key and many null values ","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/:0:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"Hierarchy of Collection Interface : ","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/:1:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"Methods of Collection Interface : No.MethodDescription 1public boolean add(Object element) is used to insert an element in this collection. 2public boolean addAll(Collection c)is used to insert the specified collection elements in the invoking collection. 3public boolean remove(Object element)is used to delete an element from this collection. 4public boolean removeAll(Collection c)is used to delete all the elements of specified collection from the invoking collection. 5public boolean retainAll(Collection c)is used to delete all the elements of invoking collection except the specified collection. 6public int size()return the total number of elements in the collection. 7public void clear()removes the total no of element from the collection. 8public boolean contains(Object element)is used to search an element. 9public boolean containsAll(Collection c)is used to search the specified collection in this collection. 10public Iterator iterator()returns an iterator. 11public Object[] toArray()converts collection into array. 12public boolean isEmpty()checks if collection is empty. 13public boolean equals(Object element)matches two collection. 14public int hashCode()returns the hashcode number for collection. ","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/:2:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"Methods of Iterator Interface : No.MethodDescription 1public boolean hasNext()It returns true if iterator has more elements. 2public Object next()It returns the element and moves the cursor pointer to the next element. 3public void remove()It removes the last elements returned by the iterator. It is rarely used. ","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/:3:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"ArrayList vs LinkedList : ArrayListLinkedList 1) ArrayList internally uses dynamic array to store the elements.LinkedList internally uses doubly linked list to store the elements. 2) Manipulation with ArrayList is slow because it internally uses array. If any element is removed from the array, all the bits are shifted in memory.Manipulation with LinkedList is faster than ArrayList because it uses doubly linked list so no bit shifting is required in memory. 3) ArrayList class can act as a list only because it implements List only.LinkedList class can act as a list and queue both because it implements List and Deque interfaces. 4) ArrayList is better for storing and accessing data.LinkedList is better for manipulating data. ","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/:4:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"ArrayList vs Vector : ArrayListVector 1) ArrayList is not synchronized.Vector is synchronized. 2) ArrayList increments 50% of current array size if number of element exceeds from its capacity.Vector increments 100% means doubles the array size if total number of element exceeds than its capacity. 3) ArrayList is not a legacy class, it is introduced in JDK 1.2.Vector is a legacy class. 4) ArrayList is fast because it is non-synchronized.Vector is slow because it is synchronized i.e. in multithreading environment, it will hold the other threads in runnable or non-runnable state until current thread releases the lock of object. 5) ArrayList uses Iterator interface to traverse the elements.Vector uses Enumeration interface to traverse the elements. But it can use Iterator also. ","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/:5:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"Hierarchy of Map Interface : ","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/:6:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"Useful Methods of Map Interface : MethodDescription Object put(Object key, Object value)It is used to insert an entry in this map. void putAll(Map map)It is used to insert the specified map in this map. Object remove(Object key)It is used to delete an entry for the specified key. Object get(Object key)It is used to return the value for the specified key. boolean containsKey(Object key)It is used to search the specified key from this map. Set keySet()It is used to return the Set view containing all the keys. Set entrySet()It is used to return the Set view containing all the keys and values. ","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/:7:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"Methods of Map.Entry Interface : MethodDescription Object getKey()It is used to obtain key. Object getValue()It is used to obtain value. ","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/:8:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"HashMap vs HashTable : HashMapHashtable 1) HashMap is non synchronized. It is not-thread safe and can't be shared between many threads without proper synchronization code.Hashtable is synchronized. It is thread-safe and can be shared with many threads. 2) HashMap allows one null key and multiple null values.Hashtable doesn't allow any null key or value. 3) HashMap is a new class introduced in JDK 1.2.Hashtable is a legacy class. 4) HashMap is fast.Hashtable is slow. 5) We can make the HashMap as synchronized by calling this code Map m = Collections.synchronizedMap(hashMap);Hashtable is internally synchronized and can't be unsynchronized. 6) HashMap is traversed by Iterator.Hashtable is traversed by Enumerator and Iterator. 7) Iterator in HashMap is fail-fast.Enumerator in Hashtable is not fail-fast. 8) HashMap inherits AbstractMap class.Hashtable inherits Dictionary class. ","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/:9:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"Collections Framework Implementation Classes Summary : ","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/:10:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"Comparable vs Comparator Interfaces : ComparableComparator 1) Comparable provides single sorting sequence. In other words, we can sort the collection on the basis of single element such as id or name or price etc. Comparator provides multiple sorting sequence. In other words, we can sort the collection on the basis of multiple elements such as id, name and price etc. 2) Comparable affects the original class i.e. actual class is modified.Comparator doesn't affect the original class i.e. actual class is not modified. 3) Comparable provides compareTo() method to sort elements.Comparator provides compare() method to sort elements. 4) Comparable is found in java.lang package.Comparator is found in java.util package. 5) We can sort the list elements of Comparable type by Collections.sort(List) method.We can sort the list elements of Comparator type by Collections.sort(List,Comparator) method. ","date":"2019-07-16","objectID":"/notes/java_basic/java_collection/:11:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java_basic/java_collection/"},{"categories":["Java Language"],"content":"Java exception handling reference notes","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Exception Handling in Java Exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime. The exception handling in java is one of the powerful mechanism to handle the runtime errors so that normal flow of the application can be maintained. An Error “indicates serious problems that a reasonable application should not try to catch.” An Exception “indicates conditions that a reasonable application might want to catch.” ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:0:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Hierarchy of the Throwable Class : ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:1:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Types of Exceptions : 1. Checked Exception - A checked exception is an exception that occurs at the compile time, these are also called as compile time exceptions. These exceptions cannot simply be ignored at the time of compilation, the programmer should take care of (handle) these exceptions. e.g. IOException, SQLException, ClassNotFoundException, CloneNotSupported, etc. Checked exceptions are checked at compile-time. 2. Unchecked Exception - An unchecked exception is an exception that occurs at the time of execution. These are also called as Runtime Exceptions. These include programming bugs, such as logic errors or improper use of an API. e.g. ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc. Unchecked exceptions are not checked at compile-time rather they are checked at runtime. 3. Error - These are not exceptions at all, but problems that arise beyond the control of the user or the programmer. Errors are typically ignored in your code because you can rarely do anything about an error. Suppose, if a stack overflow occurs, an error will arise. e.g. OutOfMemoryError, VirtualMachineError, AssertionError etc. ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:2:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Exception Example Situations : ArithmeticException int a = 50/0; //ArithmeticException NullPointerException String s = null; System.out.println(s.length());//NullPointerException NumberFormatException String s = \"abc\"; int i = Integer.parseInt(s);//NumberFormatException ArrayIndexOutOfBoundsException int a[] = new int[5]; a[10] = 50; //ArrayIndexOutOfBoundsException ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:3:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Java Exception Handling Keywords : 1. try - Java try block is used to enclose the code that might throw an exception. It must be used within the method. Java try block must be followed by either catch or finally block. 2. catch - Java catch block is used to handle the Exception. It must be used after the try block only. You can use multiple catch block with a single try. 3. finally - Java finally block is a block that is used to execute important code such as closing connection, stream etc. Java finally block is always executed whether exception is handled or not. Java finally block follows try or catch block. 4. throw - Java throw keyword is used to explicitly throw an exception. We can throw either checked or uncheked exception in java by throw keyword. The throw keyword is mainly used to throw custom exception. 5. throws - Java throws keyword is used to declare an exception. It gives an information to the programmer that there may occur an exception so it is better for the programmer to provide the exception handling code. NOTE : Exception Handling is mainly used to handle the checked exceptions. If there occurs any unchecked exception such as NullPointerException, it is programmers fault that he is not performing check up before the code being used. ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:4:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"JVM’s Default Exception Handler The JVM firstly checks whether the exception is handled or not. If exception is not handled, JVM provides a default exception handler that performs the following tasks: Prints out exception description. Prints the stack trace (Hierarchy of methods where the exception occurred). Causes the program to terminate. But if exception is handled by the application programmer, normal flow of the application is maintained i.e. rest of the code is executed. ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:5:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Using Multiple catch blocks If the superclass method declares an exception, subclass overridden method can declare same, subclass exception or no exception but cannot declare parent exception. All catch blocks must be ordered from most specific to most general i.e. catch for ArithmeticException must come before catch for Exception. ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:6:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Using finally block If you don’t handle exception, before terminating the program, JVM executes finally block(if any). For each try block there can be zero or more catch blocks, but only one finally block. The finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort). ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:7:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Execution Propagation An exception is first thrown from the top of the stack and if it is not caught, it drops down the call stack to the previous method,If not caught there, the exception again drops down to the previous method, and so on until they are caught or until they reach the very bottom of the call stack.This is called exception propagation. By default Unchecked Exceptions are forwarded in calling chain (propagated). By default, Checked Exceptions are not forwarded in calling chain (propagated). ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:8:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Using throws keyword Only Checked exception should be declared, because Unchecked Exception are under your control (so correct your code) And Errors are beyond your control. Advantage : By using throws keyword Checked Exception can be propagated (forwarded in call stack). It provides information to the caller of the method about the exception. If you are calling a method that declares an exception, you must either caught or declare the exception. You caught the exception i.e. handle the exception using try/catch. the code will be executed fine whether exception occurs during the program or not. You declare the exception i.e. specifying throws with the method. if exception does not occur, the code will be executed fine. if exception occures, an exception will be thrown at runtime because throws does not handle the exception. You can rethrow and exception by throwing same exception in catch block. ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:9:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Java throw vs throws Keywords No.throwthrows 1)Java throw keyword is used to explicitly throw an exception.Java throws keyword is used to declare an exception. 2)Checked exception cannot be propagated using throw only.Checked exception can be propagated with throws. 3)Throw is followed by an instance.Throws is followed by class. 4)Throw is used within the method.Throws is used with the method signature. 5)You cannot throw multiple exceptions.You can declare multiple exceptions e.g. public void method()throws IOException,SQLException. ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:10:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Java final vs finally vs finalize No.finalfinallyfinalize 1)Final is used to apply restrictions on class, method and variable. Final class can't be inherited, final method can't be overridden and final variable value can't be changed.Finally is used to place important code, it will be executed whether exception is handled or not.Finalize is used to perform clean up processing just before object is garbage collected. 2)Final is a keyword.Finally is a block.Finalize is a method. ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:11:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Exception Handling with Method Overriding : If the superclass method does not declare an exception, subclass overridden method cannot declare the checked exception but it can declare unchecked exception. If the superclass method declares an exception, subclass overridden method can declare same, subclass exception or no exception but cannot declare parent exception. ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:12:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Java Custom Exception : If you are creating your own Exception that is known as custom exception or user-defined exception. Java custom exceptions are used to customize the exception according to user need. By the help of custom exception, you can have your own exception and message. ","date":"2019-07-25","objectID":"/notes/java_basic/java_errors_and_exception_handling/:13:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java_basic/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Java Jackson\u0026Json notes","date":"2019-08-30","objectID":"/notes/java_basic/java_jackson/","tags":["Java"],"title":"Java Notes(19) Jackson","uri":"/notes/java_basic/java_jackson/"},{"categories":["Java Language"],"content":"Java Hibernate notes","date":"2019-08-29","objectID":"/notes/java_basic/java_hibernate/","tags":["Java"],"title":"Java Notes(18) Hibernate","uri":"/notes/java_basic/java_hibernate/"},{"categories":["Java Language"],"content":"Java JDBC reference notes","date":"2019-08-27","objectID":"/notes/java_basic/java_jdbc/","tags":["Java"],"title":"Java Notes(17) JDBC","uri":"/notes/java_basic/java_jdbc/"},{"categories":["Java Language"],"content":"Java String reference notes","date":"2019-07-26","objectID":"/notes/java_basic/java_string/","tags":["Java"],"title":"Java Notes(8) String","uri":"/notes/java_basic/java_string/"},{"categories":["Java Language"],"content":"String, in general, is a sequence of characters. But in Java, string is an object that represents a sequence of character. CharSequence Interface: The CharSequence interface is used to represent the sequence of characters. The Charsequence interface is extended in three class namely String, StringBuffer, and StringBuilder classes. ","date":"2019-07-26","objectID":"/notes/java_basic/java_string/:0:0","tags":["Java"],"title":"Java Notes(8) String","uri":"/notes/java_basic/java_string/"},{"categories":["Java Language"],"content":"String Class By String literal String s1 = \"Welcome\"; // This doesn't create a new instance. String s2 = \"Welcome\"; In the above example, only one object will be created. Firstly, JVM will not find any string object with the value “Welcome” in string constant pool, that is why it will create a new object. After that it will find the string with the value “Welcome” in the pool, it will not create a new object but will return the reference to the same instance. This results that both s1 == s2 and s1.equal(s2) return true value. By new Keyword String s1=new String(\"Welcome\"); String s2=new String(\"Welcome\"); s1 == s2 // return false s1.equal(s2) // return true In the above example, object will be created. There is some ambiguity of whether one or two object is created. In case of only one object being created, the object is created in non-pool heap memory. In case of two objects being created, the objects are created in both non-pool heap memory and and string constant pool. //A new object is created if we modify the string s2=s2.concat(\"world\"); It will waste time and computation if we constantly modify the string. Thus, two new classes are introduced. ","date":"2019-07-26","objectID":"/notes/java_basic/java_string/:0:1","tags":["Java"],"title":"Java Notes(8) String","uri":"/notes/java_basic/java_string/"},{"categories":["Java Language"],"content":"StringBuffer Class String buffer is slower than StringBuilder class but it is thread safe public class Test{ public static void main(String args[]){ StringBuffer sBuffer = new StringBuffer(\"ABC\"); sBuffer.append(\"DEF\"); sBuffer.append(\"GHI\"); sBuffer.append(\"JKL\"); System.out.println(sBuffer); } } ","date":"2019-07-26","objectID":"/notes/java_basic/java_string/:0:2","tags":["Java"],"title":"Java Notes(8) String","uri":"/notes/java_basic/java_string/"},{"categories":["Java Language"],"content":"StringBuilder Class String builder is fast but not thread safe. public class Test{ public static void main(String args[]){ StringBuilder sBuilder=new StringBuilder(\"ABC\"); sBuffer.append(\"DEF\"); sBuffer.append(\"GHI\"); sBuffer.append(\"JKL\"); System.out.println(sBuilder); } } ","date":"2019-07-26","objectID":"/notes/java_basic/java_string/:0:3","tags":["Java"],"title":"Java Notes(8) String","uri":"/notes/java_basic/java_string/"},{"categories":["Java Language"],"content":"Java Lambda notes","date":"2019-10-02","objectID":"/notes/java_basic/java_lambda/","tags":["Java"],"title":"Java Notes(24) Lambda ","uri":"/notes/java_basic/java_lambda/"},{"categories":["Java Language"],"content":"Java optionals notes","date":"2019-09-28","objectID":"/notes/java_basic/java_optionals/","tags":["Java"],"title":"Java Notes(23) Optionals","uri":"/notes/java_basic/java_optionals/"},{"categories":["Java Language"],"content":"Java logging notes","date":"2019-09-12","objectID":"/notes/java_basic/java_logging/","tags":["Java"],"title":"Java Notes(21) Logging","uri":"/notes/java_basic/java_logging/"},{"categories":["Java Language"],"content":"JavaDoc notes","date":"2019-09-10","objectID":"/notes/java_basic/java_doc/","tags":["Java"],"title":"Java Notes(20) JavaDoc","uri":"/notes/java_basic/java_doc/"},{"categories":["Java Language"],"content":"Maven notes","date":"2019-08-24","objectID":"/notes/java_basic/java_maven/","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java_basic/java_maven/"},{"categories":["Java Language"],"content":"Java file I/O reference notes","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"The java.io package contains nearly every class required to perform input and output (I/O) in Java. All these streams represent an input source and an output destination. The stream in the java.io package supports many data such as primitives, object, localized characters, etc. Java provides strong and flexible support for I/O related to files and networks. ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:0:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"The Hierarchy of I/O Class in Java ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:1:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"Stream A stream can be defined as a sequence of data. There are two kinds of Streams : InputStream − The InputStream is used to read data from a source. OutputStream − The OutputStream is used for writing data to a destination. ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:2:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"Byte Streams Java byte streams are used to perform input and output of 8-bit bytes. Though there are many classes related to byte streams but the most frequently used classes are, FileInputStream and FileOutputStream. ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:2:1","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"Character Streams Java Byte streams are used to perform input and output of 8-bit bytes, whereas Java Character streams are used to perform input and output for 16-bit unicode. Though there are many classes related to character streams but the most frequently used classes are, FileReader and FileWriter. Though internally FileReader uses FileInputStream and FileWriter uses FileOutputStream but here the major difference is that FileReader reads two bytes at a time and FileWriter writes two bytes at a time. ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:2:2","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"Why there are Byte and Character Streams A stream is a way of sequentially accessing a file. A byte stream access the file byte by byte. A byte stream is suitable for any kind of file, however not quite appropriate for text files. For example, if the file is using a unicode encoding and a character is represented with two bytes, the byte stream will treat these separately and you will need to do the conversion yourself. A character stream will read a file character by character. A character stream needs to be given the file’s encoding in order to work properly. ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:3:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"Standard Streams All the programming languages provide support for standard I/O where the user’s program can take input from a keyboard and then produce an output on the computer screen. Java provides the following three standard streams Standard Input − This is used to feed the data to user's program and usually a keyboard is used as standard input stream and represented as System.in. Standard Output − This is used to output the data produced by the user's program and usually a computer screen is used for standard output stream and represented as System.out. Standard Error − This is used to output the error data produced by the user's program and usually a computer screen is used for standard error stream and represented as System.err. ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:4:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"Reading and Writing Files The InputStream is used to read data from a source and the OutputStream is used for writing data to a destination. The two important streams are FileInputStream and FileOutputStream. ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:5:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"FileInputStream This stream is used for reading data from the files. Objects can be created using the keyword new and there are several types of constructors available. Following constructor takes a file name as a string to create an input stream object to read the file. InputStream f = new FileInputStream(\"C:/java/hello\"); Following constructor takes a file object to create an input stream object to read the file. First we create a file object using File() method. File f = new File(\"C:/java/hello\"); InputStream f = new FileInputStream(f); Once you have InputStream object, You can use various methods : Sr.No. Method \u0026 Description 1 public void close() throws IOException{} This method closes the file output stream. Releases any system resources associated with the file. Throws an IOException. 2 protected void finalize()throws IOException {} This method cleans up the connection to the file. Ensures that the close method of this file output stream is called when there are no more references to this stream. Throws an IOException. 3 public int read(int r)throws IOException{} This method reads the specified byte of data from the InputStream. Returns an int. Returns the next byte of data and -1 will be returned if it's the end of the file. 4 public int read(byte[] r) throws IOException{} This method reads r.length bytes from the input stream into an array. Returns the total number of bytes read. If it is the end of the file, -1 will be returned. 5 public int available() throws IOException{} Gives the number of bytes that can be read from this file input stream. Returns an int. Other important input streams : ByteArrayInputStream DataInputStream ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:6:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"FileOutputStream FileOutputStream is used to create a file and write data into it. The stream would create a file, if it doesn’t already exist, before opening it for output. Following constructor takes a file name as a string to create an input stream object to write the file OutputStream f = new FileOutputStream(\"C:/java/hello\") Following constructor takes a file object to create an output stream object to write the file. First, we create a file object using File() method. File f = new File(\"C:/java/hello\"); OutputStream f = new FileOutputStream(f); Once you have InputStream object, You can use various methods : Sr.No. Method \u0026 Description 1 public void close() throws IOException{} This method closes the file output stream. Releases any system resources associated with the file. Throws an IOException. 2 protected void finalize()throws IOException {} This method cleans up the connection to the file. Ensures that the close method of this file output stream is called when there are no more references to this stream. Throws an IOException. 3 public void write(int w)throws IOException{} This methods writes the specified byte to the output stream. 4 public void write(byte[] w) Writes w.length bytes from the mentioned byte array to the OutputStream. Other important output streams : ByteArrayOutputStream DataOutputStream ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:7:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"Complete Example The below code would create file test.txt and would write given numbers in binary format. Same would be the output on the stdout screen. import java.io.*; public class fileStreamTest { public static void main(String args[]) { try { byte bWrite [] = {11,21,3,40,5}; OutputStream os = new FileOutputStream(\"test.txt\"); for(int x = 0; x \u003c bWrite.length ; x++) { os.write( bWrite[x] ); // writes the bytes } os.close(); InputStream is = new FileInputStream(\"test.txt\"); int size = is.available(); for(int i = 0; i \u003c size; i++) { System.out.print((char)is.read() + \" \"); } is.close(); } catch (IOException e) { System.out.print(\"Exception\"); } } } ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:8:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"Java Console Class The Java Console class is be used to get input from console. It provides methods to read texts and passwords. If you read password using Console class, it will not be displayed to the user. The java.io.Console class is attached with system console internally. Example : import java.io.Console; class ReadPasswordTest{ public static void main(String args[]){ Console c=System.console(); System.out.println(\"Enter password: \"); char[] ch=c.readPassword(); String pass=String.valueOf(ch);//converting char array into string System.out.println(\"Password is: \"+pass); } } ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:9:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"File Navigation and I/O Other classes for File Navigation and I/O. File Class FileReader Class FileWriter Class ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:10:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"Directories in Java A directory is a File which can contain a list of other files and directories. You use File object to create directories, to list down files available in a directory. ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:11:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"Creating Directories The mkdir( ) method creates a directory, returning true on success and false on failure. Failure indicates that the path specified in the File object already exists, or that the directory cannot be created because the entire path does not exist yet. The mkdirs() method creates both a directory and all the parents of the directory. Below code creates “/tmp/user/java/bin” directory. import java.io.File; public class CreateDir { public static void main(String args[]) { String dirname = \"/tmp/user/java/bin\"; File d = new File(dirname); // Create directory now. d.mkdirs(); } } NOTE : Java automatically takes care of path separators on UNIX and Windows as per conventions. If you use a forward slash (/) on a Windows version of Java, the path will still resolve correctly. ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:12:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"Listing Directories You can use list( ) method provided by File object to list down all the files and directories available in a directory as follows. import java.io.File; public class ReadDir { public static void main(String[] args) { File file = null; String[] paths; try { // create new file object file = new File(\"/tmp\"); // array of files and directory paths = file.list(); // for each name in the path array for(String path:paths) { // prints filename and directory name System.out.println(path); } } catch (Exception e) { // if any error occurs e.printStackTrace(); } } } ","date":"2019-07-27","objectID":"/notes/java_basic/java_file_io/:13:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java_basic/java_file_io/"},{"categories":["Java Language"],"content":"Java Enum notes","date":"2019-07-26","objectID":"/notes/java_basic/java_enum/","tags":["Java"],"title":"Java Notes(10) Enum","uri":"/notes/java_basic/java_enum/"},{"categories":["Java Language"],"content":"Java Anonymous Class notes","date":"2019-07-26","objectID":"/notes/java_basic/java_anonymouse_class/","tags":["Java"],"title":"Java Notes(9) Nested and Anonymous Class ","uri":"/notes/java_basic/java_anonymouse_class/"},{"categories":["Java Language"],"content":"Nested Class In Java, just like methods, variables of a class too can have another class as its member. Writing a class within another is allowed in Java. The class written within is called the nested class, and the class that holds the inner class is called the outer class. public class Outer { public class Inner { } } Outer.Inner inner = outer.new Inner(); Nested classes are divided into two categories: Non-static nested classes : Non-static nested classes could only existed if the outer class object existing. In general, an object of the inner class is always strongly associated with an outer class object. Static nested class : Nested classes that are declared static are called static nested classes. Static nested class object can exist, even if the outer class object is not existing. They are not strongly associated with outer classes. ","date":"2019-07-26","objectID":"/notes/java_basic/java_anonymouse_class/:1:0","tags":["Java"],"title":"Java Notes(9) Nested and Anonymous Class ","uri":"/notes/java_basic/java_anonymouse_class/"},{"categories":["Java Language"],"content":"Non-static Nested Classes Inner classes are a security mechanism in Java. We know a class cannot be associated with the access modifier private, but if we have the class as a member of other class, then the inner class can be made private. And this is also used to access the private members of a class. Non-static Nested Classes are of three types depending on how and where you define them. They are − Inner Class Method-local Inner Class Anonymous Inner Class Inner Class Inner class is most obvious. class Outer_Demo { int num; // inner class private class Inner_Demo { public void print() { System.out.println(\"This is an inner class\"); } } // Accessing he inner class from the method within void display_Inner() { Inner_Demo inner = new Inner_Demo(); inner.print(); } } public class My_class { public static void main(String args[]) { // Instantiating the outer class Outer_Demo outer = new Outer_Demo(); // Accessing the display_Inner() method. outer.display_Inner(); } } Method-local Inner Class A method-local inner class can be instantiated only within the method where the inner class is defined. public class Outerclass { // instance method of the outer class void my_Method() { int num = 23; // method-local inner class class MethodInner_Demo { public void print() { System.out.println(\"This is method inner class \"+num); } } // end of inner class // Accessing the inner class MethodInner_Demo inner = new MethodInner_Demo(); inner.print(); } public static void main(String args[]) { Outerclass outer = new Outerclass(); outer.my_Method(); } } Anonymous inner class Anonymous inner class is a class that we declare and instantiate it at same time. abstract class AnonymousInner { public abstract void mymethod(); } public class Outer_class { public static void main(String args[]) { AnonymousInner inner = new AnonymousInner() { public void mymethod() { System.out.println(\"This is an example of anonymous inner class\"); } }; inner.mymethod(); } } Anonymous inner class could also be passed as parameter of one method. // interface interface Message { String greet(); } public class My_class { // method which accepts the object of interface Message public void displayMessage(Message m) { System.out.println(m.greet() + \", This is an example of anonymous inner class as an argument\"); } public static void main(String args[]) { // Instantiating the class My_class obj = new My_class(); // Passing an anonymous inner class as an argument obj.displayMessage(new Message() { public String greet() { return \"Hello\"; } }); } } ","date":"2019-07-26","objectID":"/notes/java_basic/java_anonymouse_class/:1:1","tags":["Java"],"title":"Java Notes(9) Nested and Anonymous Class ","uri":"/notes/java_basic/java_anonymouse_class/"},{"categories":["Java Language"],"content":"Static Nested Class Live Demo public class Outer { static class Nested_Demo { public void my_method() { System.out.println(\"This is my nested class\"); } } public static void main(String args[]) { Outer.Nested_Demo nested = new Outer.Nested_Demo(); nested.my_method(); } } ","date":"2019-07-26","objectID":"/notes/java_basic/java_anonymouse_class/:1:2","tags":["Java"],"title":"Java Notes(9) Nested and Anonymous Class ","uri":"/notes/java_basic/java_anonymouse_class/"},{"categories":["Java Language"],"content":"Java Serialization reference notes","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Synchronization in java is the capability to control the access of multiple threads to any shared resource. Java Synchronization is better option where we want to allow only one thread to access the shared resource. The synchronization is mainly used to : To prevent Thread Interference (Thread interference is a condition which occurs when more than one threads, executing simultaneously, access same piece of data.). To prevent Consistency Problem (Memory consistency errors occur when different threads have inconsistent views of what should be the same data.). ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:0:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Types of Synchronization : ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:1:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Thread Synchronization There are two types of thread synchronization mutual exclusive and inter-thread communication. Mutual Exclusive Cooperation (Inter-thread communication in java) Mutual Exclusive : Mutual Exclusive helps keep threads from interfering with one another while sharing data. This can be done by three ways in java : by synchronized method by synchronized block by static synchronization Concept of Lock in Java : Synchronization is built around an internal entity known as the lock or monitor. Every object has an lock associated with it. By convention, a thread that needs consistent access to an object’s fields has to acquire the object’s lock before accessing them, and then release the lock when it’s done with them. The package java.util.concurrent.locks contains several lock implementations. ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:2:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Synchronized Method in Java :** If you declare any method as synchronized, it is known as synchronized method. Synchronized method is used to lock an object for any shared resource. When a thread invokes a synchronized method, it automatically acquires the lock for that object and releases it when the thread completes its task. synchronized void printTable(int n){ //synchronized method for(int i=1;i\u003c=5;i++){ System.out.println(n*i); try{ Thread.sleep(200); }catch(Exception e){System.out.println(e);} } } ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:3:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Synchronized Block in Java Synchronized block can be used to perform synchronization on any specific resource of the method. Suppose you have 50 lines of code in your method, but you want to synchronize only 5 lines, you can use synchronized block. Scope of synchronized block is smaller than the method. If you put all the codes of the method in the synchronized block, it will work same as the synchronized method. Syntax - synchronized (object reference expression) { … } void printTable(int n){ synchronized(this){ //synchronized block for(int i=1;i\u003c=5;i++){ System.out.println(n*i); try{ Thread.sleep(200); }catch(Exception e){System.out.println(e);} } } } ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:4:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Static Synchronization in Java If you make any static method as synchronized, the lock will be on the class not on object. Problem without static synchronization : Suppose there are two objects of a shared class(e.g. Table) named object1 and object2.In case of synchronized method and synchronized block there cannot be interference between t1 and t2 or t3 and t4 because t1 and t2 both refers to a common object that have a single lock.But there can be interference between t1 and t3 or t2 and t4 because t1 acquires another lock and t3 acquires another lock.I want no interference between t1 and t3 or t2 and t4.Static synchronization solves this problem. synchronized static void printTable(int n){ for(int i=1;i\u003c=10;i++){ System.out.println(n*i); try{ Thread.sleep(200); }catch(Exception e){System.out.println(e);} } } ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:5:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Deadlock in Java Deadlock can occur in a situation when a thread is waiting for an object lock, that is acquired by another thread and second thread is waiting for an object lock that is acquired by first thread. Since, both threads are waiting for each other to release the lock, the condition is called deadlock. public class TestDeadlockExample1 { public static void main(String[] args) { final String resource1 = \"John\"; final String resource2 = \"Tom\"; // t1 tries to lock resource1 then resource2 Thread t1 = new Thread() { public void run() { synchronized (resource1) { System.out.println(\"Thread 1: locked resource 1\"); try { Thread.sleep(100);} catch (Exception e) {} synchronized (resource2) { System.out.println(\"Thread 1: locked resource 2\"); } } } }; // t2 tries to lock resource2 then resource1 Thread t2 = new Thread() { public void run() { synchronized (resource2) { System.out.println(\"Thread 2: locked resource 2\"); try { Thread.sleep(100);} catch (Exception e) {} synchronized (resource1) { System.out.println(\"Thread 2: locked resource 1\"); } } } }; t1.start(); t2.start(); } } Output: Thread 1: locked resource 1 Thread 2: locked resource 2 ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:6:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Inter-Thread Communication in Java Inter-thread communication or Co-operation is all about allowing synchronized threads to communicate with each other. Cooperation (Inter-thread communication) is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed. It is implemented by following 3 methods of Object class: wait() notify() notifyAll() ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:7:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"wait() Method Causes current thread to release the lock and wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed. The current thread must own this object’s monitor, so it must be called from the synchronized method only otherwise it will throw exception. public final void wait()throws InterruptedException public final void wait(long timeout)throws InterruptedException ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:7:1","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"notify() Method Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. public final void notify() ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:7:2","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"notifyAll() Method Wakes up all threads that are waiting on this object’s monitor. public final void notifyAll() ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:7:3","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Understanding the process of inter-thread communication Explanation of the above diagram : Threads enter to acquire lock. Lock is acquired by one thread. Now thread goes to waiting state if you call wait() method on the object. Otherwise, it releases the lock \u0026 exits when done. If you call notify() or notifyAll() method, thread moves to the notified state (runnable state). Now thread is available to acquire lock. After completion of the task, thread releases the lock and exits the monitor state of the object. NOTE : wait(), notify() and notifyAll() methods are defined in Object class not Thread class because they are related to lock and object has a lock. ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:8:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Difference between wait and sleep wait()sleep() wait() method releases the locksleep() method doesn't release the lock. is a method of Object classis a method of Thread class is a non-static methodis a static method should be notified by notify() or notifyAll() methodsafter the specified amount of time, sleep is completed. Sinple Example : class Customer { int amount = 10000; synchronized void withdraw(int amount) { System.out.println(\"going to withdraw...\"); if (this.amount \u003c amount) { System.out.println(\"Less balance; waiting for deposit...\"); try { wait(); } catch (Exception e) {} } // Simple Eg. So, doesn't consider if amount is again low after notify() this.amount -= amount; System.out.println(\"withdraw completed...\"); } synchronized void deposit(int amount) { System.out.println(\"going to deposit...\"); this.amount += amount; System.out.println(\"deposit completed... \"); notify(); } } class Test { public static void main(String args[]) { final Customer c = new Customer(); new Thread() { public void run() { c.withdraw(15000); }}.start(); new Thread() { public void run() { c.deposit(10000); }}.start(); } } ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:9:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Interrupting a Thread An interrupt is an indication to a thread that it should stop what it is doing and do something else. It’s up to the programmer to decide exactly how a thread responds to an interrupt, but it is very common for the thread to terminate. The 3 methods provided by the Thread class for interrupting a thread : public void interrupt() If any thread is in sleeping or waiting state (i.e. sleep() or wait()) is invoked, calling the interrupt() method on the thread, breaks out the sleeping or waiting state throwing InterruptedException. If the thread is not in the sleeping or waiting state, calling the interrupt() method performs normal behaviour and doesn’t interrupt the thread but sets the interrupt flag to true. t1.interrupt(); public static boolean interrupted() The static interrupted() method returns the interrupted flag afterthat it sets the flag to false if it is true. t1.interrupted() public boolean isInterrupted() The isInterrupted() method returns the interrupted flag either true or false. NOTE : If we interrupt a thread, and propagate the exception, it will stop working. If we don’t want to stop the thread, we should handle it where sleep() or wait() method is invoked. class TestIntrpt extends Thread { public void run() { try { Thread.sleep(1000); System.out.println(\"task\"); } catch (InterruptedException e) { System.out.println(\"Exception handled \" + e); } System.out.println(\"thread is still running after exception...\"); } public static void main(String args[]) { TestIntrpt t1 = new TestIntrpt(); t1.start(); t1.interrupt(); }} ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:10:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Reentrant Monitor in Java According to Sun Microsystems, Java monitors are reentrant means java thread can reuse the same monitor for different synchronized methods if method is called from the method. Advantage of Reentrant Monitor: It eliminates the possibility of single thread deadlocking. Example : class Reentrant { public synchronized void m() { n(); System.out.println(\"this is m() method\"); } public synchronized void n() { System.out.println(\"this is n() method\"); } } public class ReentrantExample { public static void main(String args[]) { final ReentrantExample re = new ReentrantExample(); Thread t1 = new Thread() { //creating thread using annonymous class public void run() { re.m(); }}; //calling m() method of Reentrant class t1.start(); }} ","date":"2019-08-06","objectID":"/notes/java_basic/java_synchronization/:11:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java_basic/java_synchronization/"},{"categories":["Java Language"],"content":"Java testing notes","date":"2019-09-25","objectID":"/notes/java_basic/java_testing/","tags":["Java"],"title":"Java Notes(22) Unit Test\u0026 Mockito","uri":"/notes/java_basic/java_testing/"}]