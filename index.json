[{"categories":["Data Structure"],"content":"Linkedlist Data Structure","date":"2021-05-27","objectID":"/notes/computerscience/datastructure/linkedlist/","tags":["Java"],"title":"Linkedlist Notes ","uri":"/notes/computerscience/datastructure/linkedlist/"},{"categories":["Data Structure"],"content":"Tree Data Structure","date":"2021-05-27","objectID":"/notes/computerscience/datastructure/tree/","tags":["Java"],"title":"Tree Notes ","uri":"/notes/computerscience/datastructure/tree/"},{"categories":["Data Structure"],"content":"Tree Introduction Trees consist of vertices (nodes) and edges that connect them. It has no cycle, and is hierarchical. Binary Tree Structure public class BinaryTreeNode { int val; BinaryTreeNode left; BinaryTreeNode right; BinaryTreeNode() {} BinaryTreeNode(int val) { this.val = val; } BinaryTreeNode(int val, BinaryTreeNode left, BinaryTreeNode right) { this.val = val; this.left = left; this.right = right; } } ","date":"2021-05-27","objectID":"/notes/computerscience/datastructure/tree/:0:0","tags":["Java"],"title":"Tree Notes ","uri":"/notes/computerscience/datastructure/tree/"},{"categories":["Data Structure"],"content":"Preorder traversal https://leetcode.com/problems/binary-tree-preorder-traversal/submissions/ class Solution { public List\u003cInteger\u003e preorderTraversal(TreeNode root) { ArrayList\u003cInteger\u003e res = new ArrayList\u003cInteger\u003e(); preorderTraversalHelper(root,res); return res; } public void preorderTraversalHelper(TreeNode root, ArrayList\u003cInteger\u003e res){ if (root!=null){ res.add(root.val); if (root.left !=null) preorderTraversalHelper(root.left, res); if (root.right != null)preorderTraversalHelper(root.right, res); } } } ","date":"2021-05-27","objectID":"/notes/computerscience/datastructure/tree/:1:0","tags":["Java"],"title":"Tree Notes ","uri":"/notes/computerscience/datastructure/tree/"},{"categories":["Data Structure"],"content":"Iterative public List\u003cInteger\u003e preorderTraversal(TreeNode root) { List\u003cInteger\u003e result = new ArrayList\u003c\u003e(); Deque\u003cTreeNode\u003e stack = new ArrayDeque\u003c\u003e(); TreeNode cur = root; while(!stack.isEmpty() || cur != null) { if(cur != null) { stack.push(p); // Add before going to children result.add(p.val); cur = cur.left; } else { TreeNode node = stack.pop(); cur = node.right; } } return result; } ","date":"2021-05-27","objectID":"/notes/computerscience/datastructure/tree/:1:1","tags":["Java"],"title":"Tree Notes ","uri":"/notes/computerscience/datastructure/tree/"},{"categories":["Data Structure"],"content":"In Order traversal Leetcode 94 https://leetcode.com/problems/binary-tree-inorder-traversal/ ","date":"2021-05-27","objectID":"/notes/computerscience/datastructure/tree/:2:0","tags":["Java"],"title":"Tree Notes ","uri":"/notes/computerscience/datastructure/tree/"},{"categories":["Data Structure"],"content":"Recursive class Solution { public List\u003cInteger\u003e inorderTraversal(TreeNode root) { ArrayList\u003cInteger\u003e res = new ArrayList\u003cInteger\u003e(); inorderTraversalHelper(root,res); return res; } public void inorderTraversalHelper(TreeNode root,ArrayList\u003cInteger\u003e res){ if (root != null) { if (root.left!=null){inorderTraversalHelper(root.left,res);} res.add(root.val); if (root.right!=null){inorderTraversalHelper(root.right,res);} } } } ","date":"2021-05-27","objectID":"/notes/computerscience/datastructure/tree/:2:1","tags":["Java"],"title":"Tree Notes ","uri":"/notes/computerscience/datastructure/tree/"},{"categories":["Data Structure"],"content":"Iterative public List\u003cInteger\u003e inorderTraversal(TreeNode root) { List\u003cInteger\u003e result = new ArrayList\u003c\u003e(); Deque\u003cTreeNode\u003e stack = new ArrayDeque\u003c\u003e(); TreeNode cur = root; while(!stack.isEmpty() || cur != null) { if(cur != null) { stack.push(cur); cur= cur.left; } else { TreeNode node = stack.pop(); // Add after all left children result.add(node.val); cur = node.right; } } return result; } ","date":"2021-05-27","objectID":"/notes/computerscience/datastructure/tree/:2:2","tags":["Java"],"title":"Tree Notes ","uri":"/notes/computerscience/datastructure/tree/"},{"categories":["Data Structure"],"content":"Postorder traversal ","date":"2021-05-27","objectID":"/notes/computerscience/datastructure/tree/:3:0","tags":["Java"],"title":"Tree Notes ","uri":"/notes/computerscience/datastructure/tree/"},{"categories":["Data Structure"],"content":"Recursive class Solution { public List\u003cInteger\u003e postorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003cInteger\u003e(); postorderTraversalHelp(root, res); return res; } public void postorderTraversalHelp(TreeNode node,List\u003cInteger\u003e res){ if (node != null){ postorderTraversalHelp(node.left, res); postorderTraversalHelp(node.right, res); res.add(node.val); } } } ","date":"2021-05-27","objectID":"/notes/computerscience/datastructure/tree/:3:1","tags":["Java"],"title":"Tree Notes ","uri":"/notes/computerscience/datastructure/tree/"},{"categories":["Data Structure"],"content":"Iterative class Solution { public List\u003cInteger\u003e postorderTraversal(TreeNode root) { LinkedList\u003cInteger\u003e result = new LinkedList\u003c\u003e(); Deque\u003cTreeNode\u003e stack = new ArrayDeque\u003c\u003e(); TreeNode cur = root; while(!stack.isEmpty() || cur != null) { if(cur != null) { stack.push(cur); result.addFirst(cur.val); cur = cur.right; } else { TreeNode node = stack.pop(); cur = node.left; } } return result; } } ","date":"2021-05-27","objectID":"/notes/computerscience/datastructure/tree/:3:2","tags":["Java"],"title":"Tree Notes ","uri":"/notes/computerscience/datastructure/tree/"},{"categories":["Data Structure"],"content":"Check if is same tree Leetcode 100 https://leetcode.com/problems/same-tree/ class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null \u0026\u0026 q == null) return true; if (p == null || q == null) return false; return p.val == q.val?isSameTree(p.left,q.left) \u0026\u0026 isSameTree(p.right,q.right):false; } } ","date":"2021-05-27","objectID":"/notes/computerscience/datastructure/tree/:4:0","tags":["Java"],"title":"Tree Notes ","uri":"/notes/computerscience/datastructure/tree/"},{"categories":["Java"],"content":"Java Virtual Machine","date":"2021-05-03","objectID":"/notes/computerscience/language/java/advancejava/jvm/jvm_intro/","tags":["Java"],"title":"JVM Object Initializaton","uri":"/notes/computerscience/language/java/advancejava/jvm/jvm_intro/"},{"categories":["Java"],"content":"Lifetime of a Type This note discusses how JVM create a object type from class file. It has three stages, namely, loading, linking and Initialization. ","date":"2021-05-03","objectID":"/notes/computerscience/language/java/advancejava/jvm/jvm_intro/:1:0","tags":["Java"],"title":"JVM Object Initializaton","uri":"/notes/computerscience/language/java/advancejava/jvm/jvm_intro/"},{"categories":["Java"],"content":"Loading Class loading is a process to create java.lang.Class, which stores the corresponding class information of a type. java.lang.Class java.lang.Class class instance represent classes, interfaces, primitives, void, and arrays in a running Java application. It has no public constructor. Class object contains meta-information about class. String getName(); Class getSuperClass(); boolean isInterface(); Class[] getInterface(); ClassLoader getClassLoader(); When is loading happens The loading of Class happens: new instance is created invoking static method Accessing static field. Exception compile-time constants Subclass is loaded or Sub-interface is loaded Run from command line Reflection The loading of interface happens when the above mentioned happens except “new instance is created”. How loading happens Classloader will try to find Class object in heap first. If not found, it will try to find the class file based on the type and path, and then create the object. If the class is not found, it will give ClassNotFoundException. Type of Classloader There are 4 different types of classloaders. They have parent-child relationships. Bootstrap classloader, is the top parent class, will start to search first, then extension class loader, then Application class loader, and last user-defined classload. There is no security check when being loaded by bootstrap classloaderm and more security check as go down from above figure. public void printClassLoaders() throws ClassNotFoundException { // Application class loader loads our own files in the classpath. System.out.println(\"Classloader of this class:\" + PrintClassLoader.class.getClassLoader()); // Extension class loaders load classes // that are an extension of the standard core Java classes. System.out.println(\"Classloader of Logging:\" + Logging.class.getClassLoader()); // The bootstrap one loads the ArrayList class. System.out.println(\"Classloader of ArrayList:\" + ArrayList.class.getClassLoader()); } Class loader of this class:sun.misc.Launcher$AppClassLoader@18b4aac2 Class loader of Logging:sun.misc.Launcher$ExtClassLoader@3caeaf62 Class loader of ArrayList:null //bootstrap class loader displayed as null ","date":"2021-05-03","objectID":"/notes/computerscience/language/java/advancejava/jvm/jvm_intro/:1:1","tags":["Java"],"title":"JVM Object Initializaton","uri":"/notes/computerscience/language/java/advancejava/jvm/jvm_intro/"},{"categories":["Java"],"content":"Linking (Dynamic Linking in Java) After class being loaded, the next stage is linking. Linking has three steps, namely, verification, preparation, and resolution. Verification Bytecode verifier: it checks for conformity with language rules. final classes are not sub-classed final methods are not overridden No illegal method overloading bytecode integrity jump instruction (if condition) does not send VM beyond end of method Preparation This steps is to allocate space for static variables, and initialize with default values. At this stage, if no space available, OutOfMemoryError will be thrown. Resolution (Optional) Resolution is the process of dynamically determining concrete values from symbolic references in the run-time constant pool. If an error occurs during resolution of a symbolic reference, then an instance of IncompatibleClassChangeError must be thrown at a point in the program that uses the symbolic reference. “Symbolic references” are strings that can be used to retrieve the actual object. Example if (obj.getClass() == String.class) { // do something } aload_1 invokevirtual #21; //Method java/lang/Object.getClass:()Ljava/lang/Class; ldc #25; //class java/lang/String if_acmpne 20 In this case, the ldc operation refers to a class that is stored symbolically. When the JVM executes this opcode, it will use the symbolic reference to identify the actual class within the current classloader, and return a reference to the class instance. ","date":"2021-05-03","objectID":"/notes/computerscience/language/java/advancejava/jvm/jvm_intro/:1:2","tags":["Java"],"title":"JVM Object Initializaton","uri":"/notes/computerscience/language/java/advancejava/jvm/jvm_intro/"},{"categories":["Java"],"content":"Initialization The last stage is to initialize the variable Initialize variable. Super classes are loaded first. Interface are loaded, but not initialized. It will only initialized when it’s static method being accessed. (Before Java 8, interface doesn’t have static method) Field initialized via method. ","date":"2021-05-03","objectID":"/notes/computerscience/language/java/advancejava/jvm/jvm_intro/:1:3","tags":["Java"],"title":"JVM Object Initializaton","uri":"/notes/computerscience/language/java/advancejava/jvm/jvm_intro/"},{"categories":["Javascript"],"content":"Javascript","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"History of JavaScript LiveScript -\u003e JavaScript ECMAScript (ES5, ES6) ECMAScript (ES) is a scripting-language specification standardized by Ecma International. It was created to standardize JavaScript. JavaScript has remained the best-known implementation of ECMAScript. ECMAScript (ES2016, ES2017) ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:1:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"HTML, CSS vs JavaScript HTML and CSS Markup language used to describe and define elements within a document. JavaScript Programming language used to communicate instructions to a machine. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:2:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Data Types Primitive types undefined null String Boolean Number null Data type Value of nothing undefined Data type Absence of value, meaning nothing is assigned to a variable. NaN Number type Not a number ‘Hello’ % 10 =\u003e NaN Type coercion converts Hello to number, NaN Implicit type coercion \"3\" can be converted by 3 implicitly Strict equality === and !== Check both type and value without type conversion Conditionals ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:3:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Truthy values and falsy values Every value in JavaScript has an inherent boolean value. Falsy values false \"\" null type undefined type 0 NaN Truthy values Everything else 0.0 \"null\" ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:4:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Switch statement switch(x) { case 'value1': // if (x === 'value1') ... [break] case 'value2': // if (x === 'value2') ... [break] default: ... [break] } Each case statement is equivalent to === ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:5:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Loop While loop while (\u003cexpression\u003e) { \u003ccode-block\u003e } For loop for (\u003cstart\u003e; \u003cstop\u003e; \u003cstep\u003e) { \u003ccode-block\u003e } ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:6:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Functions ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:7:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Syntax function name(params) { // code block } ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:7:1","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Parameter vs argument Parameter: a variable name that appears in the function declaration. Argument: a value that appears in the code when the function is invoked. Parameters are always passed by value. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:7:2","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Return value A function always returns some value back to the caller. When return value is not specified, the function will return undefined. E.g. console.log ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:7:3","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Scope Global scope Variables defined outside of an function Function scope ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:7:4","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Shadowing Global variable can be overriden inside a function. Preventable by redeclaring the same variable in the function. // shadowing var a = \"a\"; var b = \"b\"; function shadow() { a = \"c\"; // shadowing var b = \"c\"; // no shadowing } console.log(a); // a console.log(b); // b shadow(); console.log(a); // c, shadowed console.log(b); // b ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:7:5","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Hoisting Before any JavaScript is executed, all function declarations are “hoisted” to the top of their current scope. Functions can be called before they are defined in a scope. Only declaration is hoisted. Assignment is not. So hoisted variables can still be undefined. The best practice is to define functions at the top of the scripts, and variables at the top of the functions. // only declaration is hoisted function sayGreeting() { console.log(greeting); var greeting = \"hello\"; } sayGreeting(); // undefined // equivalent function function sayGreeting() { var greeting; console.log(greeting); greeting = \"hello\"; } // hoisting prevents access of global variable var greeting = \"hello\"; function sayGreeting() { console.log(greeting); // undefined var greeting = \"hello2\"; } sayGreeting(); // undefined ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:7:6","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Function as parameters A function passed into another function is called a callback. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:7:7","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Function expressions A function stored in a variable. Anonymous function. var variable = function(params) { // anonymous function body } variable(); Use the variable name to call the function. Function expressions are not hoisted. sayGreeting(); // sayGreetings is not a function var sayGreeting = function() { console.log(\"hello\"); } // equivalent code var sayGreeting; sayGreeting(); sayGreeting = function() { console.log(\"hello\"); } ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:7:8","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Named function expressions var variable = function name(params) { // function body } variable(); // call name() gives an error ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:7:9","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Inline function expressions Using function expressions that pass a function into another function inline, is really common in JavaScript. function movies(messageFunction, name) { messageFunction(name); } movies(function displayFavorite(movieName) { console.log(\"My favorite movie is \" + movieName); }, \"Finding Nemo\"); Anonymous inline function expressions are often used for function callbacks that are not going to be reused elsewhere. function movies(messageFunction, name) { messageFunction(name); } movies(function(movieName) { console.log(\"My favorite movie is \" + movieName); }, \"Finding Nemo\"); ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:7:10","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Array properties length ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:8:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Array methods reverse() sort() push(): return the length of the array after the push pop() shift(): remove first element, and return the removed element join(delimiter): concatenate the elements into a string splice() Add or remove elements from anywhere in an array Return an arrary of removed elements Parameters index number of elements to remove elements to add push(item) is equivalent to splice(array.length, 0, item) pop() is equivalent to splice(-1, 1) or splice(array.length - 1, 1) ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:9:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"forEach() element index (optional) array (optional) Return undefined Iterate through at most the number of elements before iteration If new elements are added, they may be iterated as long as their index is wihtin the original iteration range. If some elements are deleted, the iteration will not run into overflow issue. Iterate the next element according to index const array1 = ['a', 'b', 'c']; array1.forEach(element =\u003e console.log(element)); // expected output: \"a\" // expected output: \"b\" // expected output: \"c\" a = [0, 1, 2]; a.forEach(function(element, index, array) { console.log(\"index \" + index + \" before: \" + element + \", \" + array); if (index === 1) { array.splice(index, 0, 10); } console.log(\"index \" + index + \" after: \" + element + \", \" + array); }); // index 0 before: 0, 0,1,2 // index 0 after: 0, 0,1,2 // index 1 before: 1, 0,1,2 // index 1 after: 1, 0,10,1,2 // index 2 before: 1, 0,10,1,2 // index 2 after: 1, 0,10,1,2 In the example, an element is added to the array, but the iteration only goes through three elements. Element 1 is iterated through twice, because it is the second element before the change, and then pushed to the third position after the change, and the iteration goes from second to third position, regardless of the added element. Elemented are passed by value (reference) var arr = [{ num : 1 }, { num : 2 }, { num : 3 }]; arr.forEach(function(part, index) { // part and arr[index] point to the same object, so // changing the object that part points to also changes // the object that arr[index] points to part.num = 4; }); console.log(arr); // [{ num : 4 }, { num : 4 }, { num : 4 }] var arr = [{ num : 1 }, { num : 2 }, { num : 3 }]; arr.forEach(function(part, index) { // change part to point to a new object will // not change the objects stored in arr part = 4; }); console.log(arr); // [{ num : 1 }, { num : 2 }, { num : 3 }] ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:10:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"map() Return a new array from the original array const array1 = [1, 4, 9, 16]; // pass a function to map const map1 = array1.map(x =\u003e x * 2); console.log(map1); // expected output: Array [2, 8, 18, 32] ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:11:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Object Objects are data structures that store data, and help track of that data by keys. Objects have properties and methods. typeof operator: return name of the data type Object-literal notation var umbrella = { color: 'red', isOpen: false, open: function() { umbrella.isOpen = true; } } Data retrieval Bracket notation: umbrella['color'] Dot notation: umbrella.color Naming conventions Don’t wrap property names in quotes. Special propery names can be put inside quotes. But they are not compatible with dot notations. Don’t use numbers as first character as property names. Don’t include space or - in property names. Use camel case for multi-word property names. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:12:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Javascript"],"content":"Reference: https://www.freecodecamp.org/learn/ https://github.com/tuliren/javascript-notes ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_1_intro/:13:0","tags":["Javascript"],"title":"Javascript Notes 1 Intro","uri":"/notes/computerscience/language/javascript/javascript_notes_1_intro/"},{"categories":["Computer Science"],"content":"Computer Science","date":"2020-12-11","objectID":"/notes/computerscience/internet/network/network_overview/","tags":["Network"],"title":"Network","uri":"/notes/computerscience/internet/network/network_overview/"},{"categories":["Computer Science"],"content":"OSI Model The Open Systems Interconnection (OSI) model is a conceptual model created by the International Organization for Standardization which enables diverse communication systems to communicate using standard protocols. Layer Protocol data unit (PDU) Function Application (应用层) Data High-level APIs, including resource sharing, remote file access, ex: HTTP, HTTPS,FTP,SSH and etc.. Presentation (表示层) Data Translation of data between a networking service and an application; including character encoding, data compression and encryption/decryption Session(会话层) Data Managing communication sessions, i.e., continuous exchange of information in the form of multiple back-and-forth transmissions between two nodes Transport(传输层) Segment,Datagram Reliable transmission of data segments between points on a network, including segmentation, acknowledgement and multiplexing, ex: TCP Network (网络层) Packet Structuring and managing a multi-node network, including addressing, routing and traffic control, ex: IP Data link (数据链路层) Frame Reliable transmission of data frames between two nodes connected by a physical layer Physical (物理层) Bit, Symbol Transmission and reception of raw bit streams over a physical medium，ex: electricity ","date":"2020-12-11","objectID":"/notes/computerscience/internet/network/network_overview/:1:0","tags":["Network"],"title":"Network","uri":"/notes/computerscience/internet/network/network_overview/"},{"categories":["Computer Science"],"content":"TCP/IP Model The TCP/IP model is a concise version of the OSI model. It only contains four layers. Layer Protocol data unit (PDU) Function Application (应用层) Data High-level APIs, including resource sharing, remote file access, ex: HTTP, HTTPS,FTP,SSH and etc.. Transport (传输层) Segment Translation of data between a networking service and an application; including character encoding, data compression and encryption/decryption Internet Layer(网络互连层) Managing communication sessions, i.e., continuous exchange of information in the form of multiple back-and-forth transmissions between two nodes Network Access Packet WIFI In both model, the upper layer only communicates with the one layer that below it. All the data from application layer is wrapped in each layer, and transmitted, and then unwrapped. ","date":"2020-12-11","objectID":"/notes/computerscience/internet/network/network_overview/:2:0","tags":["Network"],"title":"Network","uri":"/notes/computerscience/internet/network/network_overview/"},{"categories":["Computer Science"],"content":"IP IP is a unique number assigned to a node of a network ","date":"2020-12-11","objectID":"/notes/computerscience/internet/network/network_overview/:3:0","tags":["Network"],"title":"Network","uri":"/notes/computerscience/internet/network/network_overview/"},{"categories":["Computer Science"],"content":"TCP vs UDP Protocol TCP is a connection-oriented protocol, once a connection is established, data is sent bidirectional. Bank Transcation is through TCP UDP is a connectionless protocol。 Data comes with no sequencing. UDP is faster, but information does not guarantee delivery. Game/Vido is with UDP connection ","date":"2020-12-11","objectID":"/notes/computerscience/internet/network/network_overview/:4:0","tags":["Network"],"title":"Network","uri":"/notes/computerscience/internet/network/network_overview/"},{"categories":["Computer Science"],"content":"Socket Network programming often related to socket. A network socket is a software structure within a network node of a computer network that serves as an endpoint for sending and receiving data across the network. ","date":"2020-12-11","objectID":"/notes/computerscience/internet/network/network_overview/:5:0","tags":["Network"],"title":"Network","uri":"/notes/computerscience/internet/network/network_overview/"},{"categories":["Computer Science"],"content":"Java Implementation [Java Network Implementation](http://miaoshihao.com/notes/computerscience/internet/network/network_overview/) ","date":"2020-12-11","objectID":"/notes/computerscience/internet/network/network_overview/:6:0","tags":["Network"],"title":"Network","uri":"/notes/computerscience/internet/network/network_overview/"},{"categories":["Spring"],"content":"Spring  Notes","date":"2020-08-20","objectID":"/notes/computerscience/backend/spring/springboot/","tags":["Java"],"title":"Difference in Spring and Spring Boot","uri":"/notes/computerscience/backend/spring/springboot/"},{"categories":["Spring"],"content":"Spring Boot is an extension of the Spring framework which eliminated the boilerplate configurations required for setting up a Spring application. This notes highlight the difference between Spring Boot and Spring. ","date":"2020-08-20","objectID":"/notes/computerscience/backend/spring/springboot/:0:0","tags":["Java"],"title":"Difference in Spring and Spring Boot","uri":"/notes/computerscience/backend/spring/springboot/"},{"categories":["Spring"],"content":"Maven Dependencies Spring looks minimum dependencies required to create an web application. \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-web\u003c/artifactId\u003e \u003cversion\u003e5.2.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e Spring Boot requires only one dependency: \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003cversion\u003e2.3.4.RELEASE\u003c/version\u003e \u003c/dependency\u003e Another example is related to testing library. In Spring, we use the set of Spring Test, JUnit, Hamcrest, and Mockito libraries. In a Spring project, we should add all these libraries as dependencies. But in Spring Boot, we only need the starter dependency for testing to automatically include these libraries. ","date":"2020-08-20","objectID":"/notes/computerscience/backend/spring/springboot/:1:0","tags":["Java"],"title":"Difference in Spring and Spring Boot","uri":"/notes/computerscience/backend/spring/springboot/"},{"categories":["Spring"],"content":"MVC Configuration Spring requires defining the dispatcher servlet, mappings, and other supporting configurations. This can be completed by tiher web.xml or an initializer class. public class MyWebAppInitializer implements WebApplicationInitializer { @Override public void onStartup(ServletContext container) { AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.setConfigLocation(\"com.baeldung\"); container.addListener(new ContextLoaderListener(context)); ServletRegistration.Dynamic dispatcher = container .addServlet(\"dispatcher\", new DispatcherServlet(context)); dispatcher.setLoadOnStartup(1); dispatcher.addMapping(\"/\"); } } Also a @EnableWebMvc annotation need to add to a @Configuration class and define a view-resolver to resolve the views returned from the controllers: @EnableWebMvc @Configuration public class ClientWebConfig implements WebMvcConfigurer { @Bean public ViewResolver viewResolver() { InternalResourceViewResolver bean = new InternalResourceViewResolver(); bean.setViewClass(JstlView.class); bean.setPrefix(\"/WEB-INF/view/\"); bean.setSuffix(\".jsp\"); return bean; } } By comparison, Spring Boot only needs a couple of properties to make things work, once we’ve added the web starter: spring.mvc.view.prefix=/WEB-INF/jsp/ spring.mvc.view.suffix=.jsp ","date":"2020-08-20","objectID":"/notes/computerscience/backend/spring/springboot/:2:0","tags":["Java"],"title":"Difference in Spring and Spring Boot","uri":"/notes/computerscience/backend/spring/springboot/"},{"categories":["Spring"],"content":"Application Bootstrap The basic difference in bootstrapping of an application in Spring and Spring Boot lies with the servlet. Spring uses either the web.xml or SpringServletContainerInitializer as its bootstrap entry point. On the other hand, Spring Boot uses only Servlet 3 features to bootstrap an application. ","date":"2020-08-20","objectID":"/notes/computerscience/backend/spring/springboot/:3:0","tags":["Java"],"title":"Difference in Spring and Spring Boot","uri":"/notes/computerscience/backend/spring/springboot/"},{"categories":["Spring"],"content":"Spring Spring use web.xml approach in steps: Servlet container (the server) reads web.xml The DispatcherServlet defined in the web.xml is instantiated by the container DispatcherServlet creates WebApplicationContext by reading WEB-INF/{servletName}-servlet.xml Finally, the DispatcherServlet registers the beans defined in the application context Spring bootstraps use servlet 3+ approach The container searches for classes implementing ServletContainerInitializer and executes The SpringServletContainerInitializer finds all classes implementing WebApplicationInitializer The WebApplicationInitializer creates the context with XML or @Configuration classes The WebApplicationInitializer creates the DispatcherServlet with the previously created context ","date":"2020-08-20","objectID":"/notes/computerscience/backend/spring/springboot/:3:1","tags":["Java"],"title":"Difference in Spring and Spring Boot","uri":"/notes/computerscience/backend/spring/springboot/"},{"categories":["Spring"],"content":"Spring boot The entry point of a Spring Boot application is the class which is annotated with @SpringBootApplication: @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } By default, Spring Boot uses an embedded container to run the application. In this case, Spring Boot uses the public static void main entry-point to launch an embedded web server. Also, it takes care of the binding of the Servlet, Filter, and ServletContextInitializer beans from the application context to the embedded servlet container. Another feature of Spring Boot is that it automatically scans all the classes in the same package or sub packages of the Main-class for components. Spring Boot provides the option of deploying it as a web archive in an external container as well. In this case, we have to extend the SpringBootServletInitializer: @SpringBootApplication public class Application extends SpringBootServletInitializer { // ... } Here the external servlet container looks for the Main-class defined in the META-INF file of the web archive and the SpringBootServletInitializer will take care of binding the Servlet, Filter, and ServletContextInitializer. ","date":"2020-08-20","objectID":"/notes/computerscience/backend/spring/springboot/:3:2","tags":["Java"],"title":"Difference in Spring and Spring Boot","uri":"/notes/computerscience/backend/spring/springboot/"},{"categories":["Investment"],"content":"Beneish model","date":"2020-07-17","objectID":"/notes/finance/investment/beneish_model/","tags":["Finance"],"title":"Beneish Model","uri":"/notes/finance/investment/beneish_model/"},{"categories":["Investment"],"content":"The Beneish model is a mathematical model that uses financial ratios and eight variables to identify whether a company has manipulated its earnings. It is used as a tool to uncover potential financial fraud. However, the result generated from beneish model can not be the evidence. The variables are constructed from the data in the company’s financial statements, and once calculated, create an M-Score to describe the degree to which the earnings have been manipulated. Once these eight variables are calculated, they are then combined to achieve an M-Score for the company. An M-Score of less than -2.22 suggests that the company will not be a manipulator. An M-Score of greater than -2.22 signals that the company is likely to be a manipulator. The Beneish model’s eight variables are: DSRI: Days’ sales in a receivable index GMI: Gross margin index AQI: Asset quality index SGI: Sales growth index DEPI: Depreciation index SGAI: Sales and general and administrative expenses index LVGI: Leverage index TATA: Total accruals to total assets Beneish M-Score = -4.84 + 0.92DSRI + 0.528GMI + 0.404 * AQI + 0.892 * SGI + 0.115 * DEPI - 0.172 * SGAI + 4.679 *TATA - 0.327 * LVGI 一，应收账款指数（DSRI，Days’Sales in Receivables Index） $$ DSRI = \\frac{本期应收账款占收入比例}{上期应收账款占收入比例} $$ $$ DSRI = \\frac{(Net Receivables_t / Sales_t )}{(Net Receivables_{t-1} / Sales_{t-1})} $$ Sale的数据 如果没有在财报上，可以选择用Revenue来当Sale 一般公司的应收帐款应该比较稳定，如果有了突然的增长，则意味的企业经营可能出现恶化而被迫用信用销售来做调整。 二，毛利率指数（GMI，GrossMargin Index） $$ GMI = \\frac{上期毛利率}{本期毛利率} $$ $$ GMI = \\frac{[(Sales_{t-1} - COGS_{t-1})/ Sales_{t-1}]}{[(Sales_t - COGS_t)/ Sales_t]}$$ 如果指数大于1，则证明企业的盈利能力出现下滑。 CSGS - Cost of goods sold 三，资产质量指数（AQI，AssetQuality Index） $$ AQI = \\frac{本期非实物资产比例}{上期非实物资产比例} $$ $$ AQI = \\frac{Non-current Asset_t/Total Assets_t}{Non-current Asset_{t-1}/Total Assets_{t-1}} $$ 如果指数大于1，则证明企业的资产质量出来下滑。 四，营业收入指数（SGI，SalesGrowth Index） $$ SGI = \\frac{本期销售收入}{上期销售收入} $$ $$ SGI = \\frac{Sales_t}{Sales_{t-1}} $$ 五，折旧率指数（DEPI，DepreciationIndex） $$ DEPI = \\frac{上期折旧率}{本期折旧率}$$ $$ DEPI = \\frac{Depreciation_{t-1}/({PPE}_{t-1}+Depreciation_{t-1})}{Depreciation_{t}/({PPE}_{t}+Depreciation_{t})}$$ PPE is PP\u0026E(Property, Plant, and Equipment) 公司如果折旧率下降，则证明公司有可能通过修改折旧的一些计算方法来提高公司的利润，这是一种常见的财务操作手法。 六，销售管理费用指数（SGAI，Sales,General, and Administrative Expenses Index） $$ SGAI = \\frac{本期销售管理占销售收入比例}{上期销售管理占销售收入比例} $$ $$ SGAI = \\frac{SGA Expense_t/Sales_t}{SGA Expense_{t-1}/Sales_{t-1}} $$ 如果销售管理费用增加，则表明企业在成本控制上遇到一定的问题。 七，财务杠杆指数（LVGI，LeverageIndex） $$ LVGI = \\frac{本期资产负债率}{上期资产负债率} $$ $$ LVGI = \\frac{(Current Liabilities_t + Total Long Term Debt_t)/Total Assets_t}{(Current Liabilities_{t-1} + Total Long Term Debt_{t-1})/Total Assets_{t-1}} $$ 如果公司的企业杠杆率越高，则财务风险越大。 八，应计系数（TATA，TotalAccruals to Total Asset） TATA = \\frac{应计项目}{总资产}$$ TATA = \\frac{Income from Continuing Operations_t - Cash Flows from Operations_t}{Total Assets}$$ 应计利润是一个重要的财务操纵指标，反应了公司所报出来的利润和实际的现金流收入的差值。 ","date":"2020-07-17","objectID":"/notes/finance/investment/beneish_model/:0:0","tags":["Finance"],"title":"Beneish Model","uri":"/notes/finance/investment/beneish_model/"},{"categories":["MQ"],"content":"Message Middleware Intro Message Oriented Middleware is a concept that involves the passing of data between applications using a communication channel that carries self-contained units of information (messages). ","date":"2020-07-10","objectID":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/:1:0","tags":["MQ"],"title":"Message-Oriented Middleware","uri":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/"},{"categories":["MQ"],"content":"Message Middleware Option Information transfer between different application can be achieved in many different ways, but most efficient solution so far (2021) is with Message Queue. ","date":"2020-07-10","objectID":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/:2:0","tags":["MQ"],"title":"Message-Oriented Middleware","uri":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/"},{"categories":["MQ"],"content":"Message Queue A message queue provides an asynchronous communications protocol, which is a system that puts a message onto a message queue and does not require an immediate response to continuing processing. An example of this is IBM MQ ","date":"2020-07-10","objectID":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/:2:1","tags":["MQ"],"title":"Message-Oriented Middleware","uri":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/"},{"categories":["MQ"],"content":"Message bus （ESB） A Message Bus is a messaging infrastructure to allow different systems to communicate through a shared set of interfaces(message bus). An example of message bus is TIBCO. Message Queue vs. Message Bus The idea of BUS vs. QUEUE is now a legacy concept. It is stemming from systems like IBM MQ and Tibco Rendezvous. MQ was originally a 1:1 system, while Tibco by contrast was having multiple publishers and subscribers on the same topics. ","date":"2020-07-10","objectID":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/:2:2","tags":["MQ"],"title":"Message-Oriented Middleware","uri":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/"},{"categories":["MQ"],"content":"Web Services Applications can communicate directly through web services or APIs based on standard protocols. However, one drawback is that web services cannot guarantee message delivery. Also web services are lack of pub/sub distribution models. ","date":"2020-07-10","objectID":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/:2:3","tags":["MQ"],"title":"Message-Oriented Middleware","uri":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/"},{"categories":["MQ"],"content":"Databases Databases can be used as an alternative to message queues, but they should serve different purposes and are not readily interchangeable. Database are used for storage, and and allow the same information being used over and over again. A message queue-like database is possible, but it cannot be scalable for larger applications. ","date":"2020-07-10","objectID":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/:2:4","tags":["MQ"],"title":"Message-Oriented Middleware","uri":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/"},{"categories":["MQ"],"content":"Message Queue Available in Market ","date":"2020-07-10","objectID":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/:3:0","tags":["MQ"],"title":"Message-Oriented Middleware","uri":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/"},{"categories":["MQ"],"content":"IBM MQ ","date":"2020-07-10","objectID":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/:3:1","tags":["MQ"],"title":"Message-Oriented Middleware","uri":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/"},{"categories":["MQ"],"content":"Kafka MQ ","date":"2020-07-10","objectID":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/:3:2","tags":["MQ"],"title":"Message-Oriented Middleware","uri":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/"},{"categories":["MQ"],"content":"Rabbit MQ ","date":"2020-07-10","objectID":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/:3:3","tags":["MQ"],"title":"Message-Oriented Middleware","uri":"/notes/computerscience/backend/messagequeue/message_oriented-middleware/"},{"categories":["Java"],"content":"Java 8","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"A stream represents a sequence of elements and supports different kind of operations to perform computations upon those elements: List\u003cString\u003e myList = Arrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\"); myList .stream() .filter(s -\u003e s.startsWith(\"c\")) .map(String::toUpperCase) .sorted() .forEach(System.out::println); ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:0:0","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Stream Creation Calling the method stream() on a list of objects returns a regular object stream. Arrays.asList(\"a1\", \"a2\", \"a3\") .stream() .findFirst() .ifPresent(System.out::println); But we don’t have to create collections in order to work with streams as we see in the next code sample Stream.of(). Stream.of(\"a1\", \"a2\", \"a3\") .findFirst() .ifPresent(System.out::println); // a1 Stream.of() to create a stream from a bunch of object references. ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:1:0","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Primitive Streams Besides regular object streams Java 8 ships with special kinds of streams for working with the primitive data types int, long and double. As you might have guessed it’s IntStream, LongStream and DoubleStream. IntStreams can replace the regular for-loop utilizing IntStream.range(): IntStream.range(1, 4) .forEach(System.out::println); ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:1:1","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Empty Stream Stream\u003cString\u003e streamEmpty = Stream.empty(); public Stream\u003cString\u003e streamOf(List\u003cString\u003e list) { return list == null || list.isEmpty() ? Stream.empty() : list.stream(); } ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:1:2","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Stream of Collection Collection\u003cString\u003e collection = Arrays.asList(\"a\", \"b\", \"c\"); Stream\u003cString\u003e streamOfCollection = collection.stream(); ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:1:3","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Stream of Array Array can also be a source of a Stream: Stream\u003cString\u003e streamOfArray = Stream.of(\"a\", \"b\", \"c\"); They can also be created out of an existing array or of a part of an array: String[] arr = new String[]{\"a\", \"b\", \"c\"}; Stream\u003cString\u003e streamOfArrayFull = Arrays.stream(arr); Stream\u003cString\u003e streamOfArrayPart = Arrays.stream(arr, 1, 3); ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:1:4","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Stream.builder() When builder is used the desired type should be additionally specified in the right part of the statement, otherwise the build() method will create an instance of the Stream: Stream\u003cString\u003e streamBuilder = Stream.\u003cString\u003ebuilder().add(\"a\").add(\"b\").add(\"c\").build(); ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:1:5","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Stream.generate() The generate() method accepts a Supplier for element generation. As the resulting stream is infinite, developer should specify the desired size or the generate() method will work until it reaches the memory limit: Stream\u003cString\u003e streamGenerated = Stream.generate(() -\u003e \"element\").limit(10); ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:1:6","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Stream.iterate() Another way of creating an infinite stream is by using the iterate() method: Stream\u003cInteger\u003e streamIterated = Stream.iterate(40, n -\u003e n + 2).limit(20); The first element of the resulting stream is a first parameter of the iterate() method. For creating every following element the specified function is applied to the previous element. In the example above the second element will be 42. ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:1:7","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Stream of Primitives Java 8 offers a possibility to create streams out of three primitive types: int, long and double. As Stream is a generic interface and there is no way to use primitives as a type parameter with generics, three new special interfaces were created: IntStream, LongStream, DoubleStream. Using the new interfaces alleviates unnecessary auto-boxing allows increased productivity: IntStream intStream = IntStream.range(1, 3); LongStream longStream = LongStream.rangeClosed(1, 3); The range(int startInclusive, int endExclusive) method creates an ordered stream from the first parameter to the second parameter. It increments the value of subsequent elements with the step equal to 1. The result doesn’t include the last parameter, it is just an upper bound of the sequence. The rangeClosed(int startInclusive, int endInclusive) method does the same with only one difference – the second element is included. These two methods can be used to generate any of the three types of streams of primitives. Since Java 8 the Random class provides a wide range of methods for generation streams of primitives. For example, the following code creates a DoubleStream, which has three elements: Random random = new Random(); DoubleStream doubleStream = random.doubles(3); ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:1:8","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Stream of String String can also be used as a source for creating a stream. With the help of the chars() method of the String class. Since there is no interface CharStream in JDK, the IntStream is used to represent a stream of chars instead. IntStream streamOfChars = \"abc\".chars(); The string can be breaked into substring according to specified RegEx: Stream\u003cString\u003e streamOfString = Pattern.compile(\", \").splitAsStream(\"a, b, c\"); ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:1:9","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Stream of File Java NIO class Files allows to generate a Stream of a text file through the lines() method. Every line of the text becomes an element of the stream: Path path = Paths.get(\"C:\\\\file.txt\"); Stream\u003cString\u003e streamOfStrings = Files.lines(path); Stream\u003cString\u003e streamWithCharset = Files.lines(path, Charset.forName(\"UTF-8\")); The Charset can be specified as an argument of the lines() method. List\u003cString\u003e strings = Arrays.asList(\"abc\", \"\", \"bc\", \"efg\", \"abcd\",\"\", \"jkl\"); List\u003cString\u003e filtered = strings.stream().filter(string -\u003e !string.isEmpty()).collect(Collectors.toList()); ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:1:10","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Intermediate and Termial Operation Stream operations are either intermediate or terminal. Intermediate operations return a stream so we can chain multiple intermediate operations without using semicolons. Terminal operations are either void or return a non-stream result. In the above example filter, map and sorted are intermediate operations whereas forEach is a terminal operation. Streams can be created from various data sources, especially collections. Lists and Sets support new methods stream() and parallelStream() to either create a sequential or a parallel stream. ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:2:0","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Intermediate Operation map(mapToInt,mapToLong,mapToDouble) It allows elements of a Stream to be transformed into something else by mapping them to another value or type flatmap(flatmapToInt,flatmapToLong,flatmapToDouble): It taking a Function that goes from a type T to a return type R. Thre result stream are flattened. limit it creates a new stream that only contains the first n elements of the stream it is applied on. distint filter out any duplicates by using equal method filter: Filter elements out in a stream. Skip：Skip the number of elements in the device peek 挑出操作，如果想对数据进行某些操作，如：读取、编辑修改等。 sorted: Sorted by using natural order or defined comparator. ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:2:1","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Termial Operation collect: To build data structures containing a specific collection of elements. Collect to Set .collect(Collectors.toSet()) Collect to List .collect(Collectors.toList()) Collect to General Collection .collect(Collectors.toCollection(LinkedList::new)) .collect(Collectors.toCollection(LinkedHashSet::new)) .collect(Collectors.toCollection(PriorityQueue::new)) Collect to Array .toArray(String[]::new) Collect to Map Collectors.toMap() takes two Functions corresponding to a key-mapper and a value-mapper .collect(Collectors.toMap(,)) Collect GroupingBy There is a very useful Collector named groupingBy() which divides the elements into different groups, depending on some property whereby the property is extracted by something called a “classifier”. .collect(Collectors.groupingBy(,)) Collect GroupingBy Using Downstream Collector There is an overloaded version of groupingBy() that allows the use of a custom “downstream collector” to get better control over the resulting Map. Below is an example of how the special downstream collector counting() is applied to count, rather than collecting, the elements of each bucket. .collect(Collectors.groupingBy(s -\u0026gt;s.charAt(0),counting())) count count the number of element in a Stream. findFirst、findAny 查找操作，查找第一个、查找任何一个 返回的类型为Optional。 noneMatch、allMatch、anyMatch 匹配操作，数据流中是否存在符合条件的元素 返回值为bool 值。 min,max,average: return the aggregate value of a stream reduce 规约操作，将整个数据流的值规约为一个值，count、min、max底层就是使用reduce。 forEach、forEachOrdered: They both take a Consumer and terminates the Stream without returning anything. toArray 数组操作，将数据流的元素转换成数组。 anyMatch(): return a boolean to see if the value existed ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:2:2","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Java"],"content":"Reference Java 8 Stream Tutorial https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/ Become a Master of Java Streams, Part 3: Terminal Operations https://dzone.com/articles/become-a-master-of-java-streams-part-1-creating-st https://dzone.com/articles/become-a-master-of-java-streams-part-2-intermediat https://dzone.com/articles/become-a-master-of-java-streams-part-3-terminal-op ","date":"2019-10-02","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_stream/:3:0","tags":["Java"],"title":"Java8 Stream ","uri":"/notes/computerscience/language/java/basicjava/java8_notes_stream/"},{"categories":["Spring"],"content":"Spring Integration Notes","date":"2019-10-01","objectID":"/notes/computerscience/backend/spring/spring_integration/","tags":["Java"],"title":"Spring Integration Notes(1) Overview ","uri":"/notes/computerscience/backend/spring/spring_integration/"},{"categories":["Spring"],"content":"Spring Integration Basic Overview Spring Integration is an open source framework that designed to enable the development of integration solutions typical of event-driven architectures and messaging-centric architectures. It requires dependency spring intergration core, which could be downloaded from Maven Central. \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.integration\u003c/groupId\u003e \u003cartifactId\u003espring-integration-core\u003c/artifactId\u003e \u003cversion\u003e5.3.1.RELEASE\u003c/version\u003e \u003c/dependency\u003e Spring integration framework consists three parts, namely message, message channel, and message endpoint. In general. a message is a unit of information that can be passed between different message endpoint through message channels. Message: A message is a unit of information that can be passed between different components, called message endpoints. Message Channel: The message channel is the connection between multiple endpoints. The channel implementation manages the details of how and where a message is delivered but shouldn’t need to interact with the payload of a message. Message Endpoint: Message endpoints are the components that actually do something with the message. ","date":"2019-10-01","objectID":"/notes/computerscience/backend/spring/spring_integration/:1:0","tags":["Java"],"title":"Spring Integration Notes(1) Overview ","uri":"/notes/computerscience/backend/spring/spring_integration/"},{"categories":["Spring"],"content":"Spring Integration Design Concept ","date":"2019-10-01","objectID":"/notes/computerscience/backend/spring/spring_integration/:2:0","tags":["Java"],"title":"Spring Integration Notes(1) Overview ","uri":"/notes/computerscience/backend/spring/spring_integration/"},{"categories":["Spring"],"content":"Loose coupling and event-driven architecture ","date":"2019-10-01","objectID":"/notes/computerscience/backend/spring/spring_integration/:2:1","tags":["Java"],"title":"Spring Integration Notes(1) Overview ","uri":"/notes/computerscience/backend/spring/spring_integration/"},{"categories":["Design"],"content":"Notes on Database","date":"2019-10-01","objectID":"/notes/computerscience/system/sql_nosql/","tags":["System Design"],"title":"SQL vs. Non SQL","uri":"/notes/computerscience/system/sql_nosql/"},{"categories":["Design"],"content":"Intro There are two main types of solutions: SQL (relational databases) and NoSQL(non-relational databases. ","date":"2019-10-01","objectID":"/notes/computerscience/system/sql_nosql/:1:0","tags":["System Design"],"title":"SQL vs. Non SQL","uri":"/notes/computerscience/system/sql_nosql/"},{"categories":["Design"],"content":"SQL Relational databases store data in rows and columns. Each row contains all the information about one entity and each column contains all the separate data points. ","date":"2019-10-01","objectID":"/notes/computerscience/system/sql_nosql/:1:1","tags":["System Design"],"title":"SQL vs. Non SQL","uri":"/notes/computerscience/system/sql_nosql/"},{"categories":["Design"],"content":"NoSQL Following are most common type of NoSQL DB: Key-Value Stores: Data is stored in an array of key-value pairs. The ‘key’ is an attribute name which is linked to a ‘value’. Document Databases: In these databases, data is stored in documents (instead of rows and columns in a table) and these documents are grouped together in collections. Each document can have an entirely different structure. Document databases include the CouchDB and MongoDB. Wide-Column Databases: Instead of ‘tables,’ in columnar databases we have column families, which are containers for rows. Unlike relational databases, we don’t need to know all the columns up front and each row doesn’t have to have the same number of columns. Columnar databases are best suited for analyzing large datasets - big names include Cassandra and HBase. Graph Databases: These databases are used to store data whose relations are best represented in a graph. Data is saved in graph structures with nodes (entities), properties (information about the entities), and lines (connections between the entities). Examples of graph database include Neo4J and InfiniteGraph. ","date":"2019-10-01","objectID":"/notes/computerscience/system/sql_nosql/:1:2","tags":["System Design"],"title":"SQL vs. Non SQL","uri":"/notes/computerscience/system/sql_nosql/"},{"categories":["Design"],"content":"High level differences between SQL and NoSQL Storage: SQL stores data in tables where each row represents an entity and each column represents a data point about that entity; for example, if we are storing a car entity in a table, different columns could be ‘Color’, ‘Make’, ‘Model’, and so on. NoSQL databases have different data storage models. The main ones are key-value, document, graph, and columnar. We will discuss differences between these databases below. Schema: In SQL, each record conforms to a fixed schema, meaning the columns must be decided and chosen before data entry and each row must have data for each column. The schema can be altered later, but it involves modifying the whole database and going offline. In NoSQL, schemas are dynamic. Columns can be added on the fly and each ‘row’ (or equivalent) doesn’t have to contain data for each ‘column.’ Querying: SQL databases use SQL (structured query language) for defining and manipulating the data, which is very powerful. In a NoSQL database(Unstructured Query Language), queries are focused on a collection of documents. Sometimes it is also called UnQL. Different databases have different syntax for using UnQL. Scalability In most common situations, SQL databases are vertically scalable, i.e., by increasing the horsepower (higher Memory, CPU, etc.) of the hardware, which can get very expensive. It is possible to scale a relational database across multiple servers, but this is a challenging and time-consuming process. On the other hand, NoSQL databases are horizontally scalable, meaning we can add more servers easily in our NoSQL database infrastructure to handle a lot of traffic. Any cheap commodity hardware or cloud instances can host NoSQL databases, thus making it a lot more cost-effective than vertical scaling. A lot of NoSQL technologies also distribute data across servers automatically. Reliability Reliability or ACID Compliancy (Atomicity, Consistency, Isolation, Durability): The vast majority of relational databases are ACID compliant. So, when it comes to data reliability and safe guarantee of performing transactions, SQL databases are still the better bet. ","date":"2019-10-01","objectID":"/notes/computerscience/system/sql_nosql/:1:3","tags":["System Design"],"title":"SQL vs. Non SQL","uri":"/notes/computerscience/system/sql_nosql/"},{"categories":["Design"],"content":"Notes on System Design","date":"2019-10-01","objectID":"/notes/computerscience/system_design/example/url_shorten/","tags":["System Design"],"title":"URL Shortening service","uri":"/notes/computerscience/system_design/example/url_shorten/"},{"categories":["Design"],"content":"Requirement ","date":"2019-10-01","objectID":"/notes/computerscience/system_design/example/url_shorten/:0:0","tags":["System Design"],"title":"URL Shortening service","uri":"/notes/computerscience/system_design/example/url_shorten/"},{"categories":["Design"],"content":"Functional Requirements: Given a URL, the service should generate a shorter and unique alias of it. This is called a short link. This link should be short enough to be easily copied and pasted into applications. When users access a short link, service should redirect them to the original link. Users should optionally be able to pick a custom short link for their URL. Links will expire after a standard default timespan. Users should be able to specify the expiration time. ","date":"2019-10-01","objectID":"/notes/computerscience/system_design/example/url_shorten/:1:0","tags":["System Design"],"title":"URL Shortening service","uri":"/notes/computerscience/system_design/example/url_shorten/"},{"categories":["Design"],"content":"Non-Functional Requirements: The system should be highly available. This is required because, if our service is down, all the URL redirections will start failing. URL redirection should happen in real-time with minimal latency. Shortened links should not be guessable (not predictable). ","date":"2019-10-01","objectID":"/notes/computerscience/system_design/example/url_shorten/:2:0","tags":["System Design"],"title":"URL Shortening service","uri":"/notes/computerscience/system_design/example/url_shorten/"},{"categories":["Design"],"content":"Extended Requirements: Analytics; e.g., how many times a redirection happened? Our service should also be accessible through REST APIs by other services. Capacity Estimation and Constraints ","date":"2019-10-01","objectID":"/notes/computerscience/system_design/example/url_shorten/:3:0","tags":["System Design"],"title":"URL Shortening service","uri":"/notes/computerscience/system_design/example/url_shorten/"},{"categories":["Design"],"content":"Traffic estimates: ","date":"2019-10-01","objectID":"/notes/computerscience/system_design/example/url_shorten/:3:1","tags":["System Design"],"title":"URL Shortening service","uri":"/notes/computerscience/system_design/example/url_shorten/"},{"categories":["Java"],"content":"Java 8","date":"2019-09-28","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_option/","tags":["Java"],"title":"Java8 Optional class","uri":"/notes/computerscience/language/java/basicjava/java8_notes_option/"},{"categories":["Java"],"content":"Optional class is a container for null. The primary design goal for Optional is to be used as the return value of functions when a return value might be absent. The intent is that the caller immediately check the Optional and extract the actual value if it’s present. If the value is absent, the caller can substitute a default value, throw an exception, or apply some other policy. This is typically done by chaining fluent method calls off the end of a stream pipeline (or other methods) that return Optional values. ","date":"2019-09-28","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_option/:0:0","tags":["Java"],"title":"Java8 Optional class","uri":"/notes/computerscience/language/java/basicjava/java8_notes_option/"},{"categories":["Java"],"content":"Optional class Declartion public final class Optional\u003cT\u003e extends Object ","date":"2019-09-28","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_option/:0:1","tags":["Java"],"title":"Java8 Optional class","uri":"/notes/computerscience/language/java/basicjava/java8_notes_option/"},{"categories":["Java"],"content":"Optional class method Return an empty option class static \u003cT\u003e Optional\u003cT\u003e empty() Example: @Test public void whenCreatesEmptyOptional_thenCorrect() { Optional\u003cString\u003e empty = Optional.empty(); assertFalse(empty.isPresent()); } 判断其他对象是否等于Optional boolean equals(Object obj) optionObject.filter() Filter takes a predicate as an argument and returns an Optional object. If the wrapped value passes testing by the predicate, then the Optional is returned as-is. if the predicate returns false, then it will return an empty Optional: Optional\u003cT\u003e filter(Predicate\u003c? super \u003cT\u003e predicate) Example: @Test public void whenOptionalFilterWorks_thenCorrect() { Integer year = 2016; Optional\u003cInteger\u003e yearOptional = Optional.of(year); boolean is2016 = yearOptional.filter(y -\u003e y == 2016).isPresent(); assertTrue(is2016); boolean is2017 = yearOptional.filter(y -\u003e y == 2017).isPresent(); assertFalse(is2017); } public boolean priceIsInRange2(Modem modem2) { return Optional.ofNullable(modem2) .map(Modem::getPrice) .filter(p -\u003e p \u003e= 10) .filter(p -\u003e p \u003c= 15) .isPresent(); } flatMap() flatMap is similiar to map method. The difference is that map transforms values only when they are unwrapped whereas flatMap takes a wrapped value and unwraps it before transforming it. \u003cU\u003e Optional\u003cU\u003e flatMap(Function\u003c? super T,Optional\u003cU\u003e\u003e mapper) public class Person { private String name; private int age; private String password; public Optional\u003cString\u003e getName() { return Optional.ofNullable(name); } public Optional\u003cInteger\u003e getAge() { return Optional.ofNullable(age); } public Optional\u003cString\u003e getPassword() { return Optional.ofNullable(password); } // normal constructors and setters } Normal way of creating object Person person = new Person(\"john\", 26); Optional\u003cPerson\u003e personOptional = Optional.of(person); @Test public void givenOptional_whenFlatMapWorks_thenCorrect2() { Person person = new Person(\"john\", 26); Optional\u003cPerson\u003e personOptional = Optional.of(person); Optional\u003cOptional\u003cString\u003e\u003e nameOptionalWrapper = personOptional.map(Person::getName); Optional\u003cString\u003e nameOptional = nameOptionalWrapper.orElseThrow(IllegalArgumentException::new); String name1 = nameOptional.orElse(\"\"); assertEquals(\"john\", name1); String name = personOptional .flatMap(Person::getName) .orElse(\"\"); assertEquals(\"john\", name); } optionObject.get() This method is to get the value inside Optional container The purpose of Optional is to avoid any unforeseen exceptions. However, this method is against the purpose of optional T get() @Test public void givenOptional_whenGetsValue_thenCorrect() { Optional\u003cString\u003e opt = Optional.of(\"baeldung\"); String name = opt.get(); assertEquals(\"baeldung\", name); } If get value is null @Test(expected = NoSuchElementException.class) public void givenOptionalWithNull_whenGetThrowsException_thenCorrect() { Optional\u003cString\u003e opt = Optional.ofNullable(null); String name = opt.get(); } 返回存在值的哈希码，如果值不存在 返回 0。 int hashCode() optionObject.ifPresent() This method is to replace the null check in Java void ifPresent(Consumer\u003c? super T\u003e consumer) Example: @Test public void givenOptional_whenIfPresentWorks_thenCorrect() { Optional\u003cString\u003e opt = Optional.of(\"Test\"); opt.ifPresent(name -\u003e System.out.println(name.length())); } optionObject.isPresent() This method will return true if the value is presented in Option boolean isPresent() Example: @Test public void givenOptional_whenIsPresentWorks_thenCorrect() { Optional\u003cString\u003e opt = Optional.of(\"Test\"); assertTrue(opt.isPresent()); opt = Optional.ofNullable(null); assertFalse(opt.isPresent()); } in Java 11, we can use isEmpty method @Test public void givenAnEmptyOptional_thenIsEmptyBehavesAsExpected() { Optional\u003cString\u003e opt = Optional.of(\"Baeldung\"); assertFalse(opt.isEmpty()); opt = Optional.ofNullable(null); assertTrue(opt.isEmpty()); } optionalObject.map() The map method returns the result of the computation wrapped inside a Optional. The value passing in the map bracket should not be option. Otherwise flagMap() should be used. \u003cU\u003eO","date":"2019-09-28","objectID":"/notes/computerscience/language/java/basicjava/java8_notes_option/:0:2","tags":["Java"],"title":"Java8 Optional class","uri":"/notes/computerscience/language/java/basicjava/java8_notes_option/"},{"categories":["Investment"],"content":"Technical Indicator for Stock Market Trend","date":"2019-06-29","objectID":"/notes/finance/investment/technicalindicator/","tags":["Finance"],"title":"Technical Indicator","uri":"/notes/finance/investment/technicalindicator/"},{"categories":["Investment"],"content":"Accumulation/Distribution Line (ADL) The accumulation/distribution line gauges supply and demand by looking at where the price closed within the period’s range, and then multiplying that by volume. The A/D indicator is cumulative, meaning one period’s value is added or subtracted from the last. A rising A/D line helps confirm a rising price trend. A falling A/D line helps confirm a price downtrend. If the price is rising but A/D is falling, it signals underlying weakness and a potential decline in price. If the price of an asset is falling but A/D is rising, it signals underlying strength and the price may start to rise. ","date":"2019-06-29","objectID":"/notes/finance/investment/technicalindicator/:1:0","tags":["Finance"],"title":"Technical Indicator","uri":"/notes/finance/investment/technicalindicator/"},{"categories":["Investment"],"content":"Average Directional Index (ADX) ","date":"2019-06-29","objectID":"/notes/finance/investment/technicalindicator/:2:0","tags":["Finance"],"title":"Technical Indicator","uri":"/notes/finance/investment/technicalindicator/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-06-13","objectID":"/notes/computerscience/language/java/basicjava/java_notes_1_introduction/","tags":["Java"],"title":"Java Notes(1) Introduction","uri":"/notes/computerscience/language/java/basicjava/java_notes_1_introduction/"},{"categories":["Java"],"content":"Java Features and Program Execution Java is a programming language and a platform. Platform: Any hardware or software environment in which a program runs, is known as a platform. Since Java has its own runtime environment (JRE) and Application Programming Interface (API), it is called platform. ","date":"2019-06-13","objectID":"/notes/computerscience/language/java/basicjava/java_notes_1_introduction/:0:0","tags":["Java"],"title":"Java Notes(1) Introduction","uri":"/notes/computerscience/language/java/basicjava/java_notes_1_introduction/"},{"categories":["Java"],"content":"Features of Java : Simple: User friendly syntax based on C++ It has Automatic Garbage Collection It has Rich set of APIs Removed confusing features - explicit pointers, operator overloading, multiple inheritance, etc Object-oriented: In Java, we organize the software as a combination of different types of objects that incorporates both data and behaviour. Based on the concept of Objects, Class, Inheritance, Polymorphism, Abstraction, Encapsulation Platform Independent: Java provides software-based platform. It has two components: JRE (Runtime Environment) API (Application Programming Interface) Java code is compiled by the compiler and converted into bytecode. This bytecode is a platform-independent. Can run on many platforms - Windows, Linux, Mac, etc. Secured: No explicit pointer JVM - java Programs run inside virtual machine sandbox Classloader - adds security by separating the package for the classes of the local file system from those that are imported from network sources. Bytecode Verifier - checks the code fragments for illegal code that can violate access right to objects. Security Manager - determines what resources a class can access such as reading and writing to the local disk. More - developers can add extra security through SSL, JAAS, Cryptography etc. Robust: Good memory management - automatic garbage collection. No pointers - increses security. Exception handling - increses robustness against errors. Strongly typed - every variable must be declared with a data type. Statically typed - type checking of variables is performed at compile time. Architecture-Neutral: There is no implementation dependent features. e.g. size of primitive types is fixed. Portable: Write Once and Run Anywhere. interpreted: Java is compiled to bytecodes, which are interpreted by a Java run-time environment. The interpreter reads bytecode stream then execute the instructions. High-Performance: Uses ByteCode - Java is faster than traditional interpreted languages since byte code is “close” to native code. Just-In-Time (JIT) - it is designed to support JIT compilers, which dynamically compile bytecodes to machine code. Garbage collector - collect the unused memory space and improve the performance of the application. NOTE: Java is still slower than a compiled language like C/C++. Distributed: We can create distributed applications in java. RMI and EJB are used for creating distributed applications. We may access files by calling the methods from any machine on the internet. Multi-threaded: A thread is like a separate program, executing concurrently. We can write Java programs that deal with many tasks at once by defining multiple threads. The main advantage of multi-threading is that it doesn’t occupy memory for each thread. It shares a common memory area. Threads are important for multi-media, Web applications etc. Dynamic: Dynamic Compilation (JIT) - Implementations to gain performance during program execution. The machine code emitted by a dynamic compiler is constructed and optimized at program runtime, the use of dynamic compilation enables optimizations for efficiency. Load on Demand - Loads in classes as they are needed, even from across the network. Dynamic memory allocation - All Java objects are dynamically allocated. Dynamic Polymorphism - Compiler doesn’t know which method to be called in advance. JVM decides which method to called at run time. Call by Value What is Call by Value and Call by Reference In call by value, the modification done to the parameter passed does not reflect in the caller’s scope while in the call by reference, the modification done to the parameter passed are persistent and changes are reflected in the caller’s scope. Java is call by value with evidence of a simple swap value function Java can achieve call by reference by passing the reference address of an object. This can give some extend of call by reference, but the principle behind this is still call by reference. ","date":"2019-06-13","objectID":"/notes/computerscience/language/java/basicjava/java_notes_1_introduction/:1:0","tags":["Java"],"title":"Java Notes(1) Introduction","uri":"/notes/computerscience/language/java/basicjava/java_notes_1_introduction/"},{"categories":["Java"],"content":"Java Program Execution Process : ","date":"2019-06-13","objectID":"/notes/computerscience/language/java/basicjava/java_notes_1_introduction/:2:0","tags":["Java"],"title":"Java Notes(1) Introduction","uri":"/notes/computerscience/language/java/basicjava/java_notes_1_introduction/"},{"categories":["Java"],"content":"JDK - JRE - JVM : Java Development Kit (JDK): It is a collection of development tools including JRE. Java Runtime Environment (JRE): It contains set of libraries and the JVM. Java Virtual Machine (JVM): It is an abstract machine. It is a specification that provides runtime environment in which java bytecode can be executed. The JVM performs following main tasks: Loads code, Verifies code, Executes code and Provides runtime environment. NOTE - JVMs are available for many hardware and software platforms. JVM, JRE and JDK are platform dependent because configuration of each OS differs. But, Java is platform independent. ","date":"2019-06-13","objectID":"/notes/computerscience/language/java/basicjava/java_notes_1_introduction/:3:0","tags":["Java"],"title":"Java Notes(1) Introduction","uri":"/notes/computerscience/language/java/basicjava/java_notes_1_introduction/"},{"categories":["Java"],"content":"Internal Architecture of JVM : JVM (Java Virtual Machine) has various sub components internally. You can see the most important ones in the above diagram. Class loader sub system: JVM’s class loader sub system performs 3 tasks It loads .class file into memory. It verifies byte code instructions. It allots memory required for the program. Run time data area: This is the memory resource used by JVM and it is divided into 5 parts Class (Method) area: Stores constant pool, field and method data, the code for methods. Heap: Objects are allocated on the heap. Java stacks: Java stacks are the places where the Java methods are executed. A Java stack contains frames. It holds local variables and partial results, and plays a part in method invocation and return. On each frame, a separate method is executed. Each thread has a private JVM stack, created at the same time as thread. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes. Program counter registers: PC (program counter) register. It contains the address of the JVM instruction currently being executed. Native method stacks: Are places where native methods (eg. C language programs, etc) are executed. Native method interface: Native method interface is a program that connects native methods libraries (C header files) with JVM for executing native methods. Native method library: Holds the native libraries information. Execution engine: Just-In-Time(JIT) compiler: It is used to improve the performance. It coverts byte code into machine code. JIT compiles parts of the byte code that have similar functionality at the same time, and hence reduces the amount of time needed for compilation.Here the term ?compiler? refers to a translator from the instruction set of a Java virtual machine (JVM) to the instruction set of a specific CPU. Interpreter: Read bytecode stream then execute the instructions. Virtual processor NOTE - JVM uses optimization technique to decide which part to be interpreted and which part to be used with JIT compiler. ","date":"2019-06-13","objectID":"/notes/computerscience/language/java/basicjava/java_notes_1_introduction/:4:0","tags":["Java"],"title":"Java Notes(1) Introduction","uri":"/notes/computerscience/language/java/basicjava/java_notes_1_introduction/"},{"categories":["TypeScript"],"content":"TypeScript","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_2_function/","tags":["TypeScript"],"title":"TypeScript Notes 2 Function","uri":"/notes/computerscience/language/typescript/typescript_notes_2_function/"},{"categories":["TypeScript"],"content":"Function ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_2_function/:1:0","tags":["TypeScript"],"title":"TypeScript Notes 2 Function","uri":"/notes/computerscience/language/typescript/typescript_notes_2_function/"},{"categories":["TypeScript"],"content":"Named Functions A named function is one where you declare and call a function by its given name. function display() { console.log(\"Hello TypeScript!\"); } display(); //Output: Hello TypeScript Functions can also include parameter types and return type. function Sum(x: number, y: number) : number { return x + y; } Sum(2,3); // returns 5 ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_2_function/:1:1","tags":["TypeScript"],"title":"TypeScript Notes 2 Function","uri":"/notes/computerscience/language/typescript/typescript_notes_2_function/"},{"categories":["TypeScript"],"content":"Anonymous Function An anonymous function are stored in a variable. The function itself does not have a name. These are invoked using the variable name that the function is stored in. let greeting = function() { console.log(\"Hello TypeScript!\"); }; greeting(); //Output: Hello TypeScript! An anonymous function can also include parameter types and return type. let Sum = function(x: number, y: number) : number { return x + y; } Sum(2,3); // returns 5 ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_2_function/:1:2","tags":["TypeScript"],"title":"TypeScript Notes 2 Function","uri":"/notes/computerscience/language/typescript/typescript_notes_2_function/"},{"categories":["TypeScript"],"content":"Optional Parameters TypeScript has an optional parameter functionality. The parameters that may or may not receive a value can be appended with a ‘?’ to mark them as optional. function Greet(greeting: string, name?: string ) : string { return greeting + ' ' + name + '!'; } Greet('Hello','Steve');//OK, returns \"Hello Steve!\" Greet('Hi'); // OK, returns \"Hi undefined!\". Greet('Hi','Bill','Gates'); //Compiler Error: Expected 2 arguments, but got 3. ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_2_function/:1:3","tags":["TypeScript"],"title":"TypeScript Notes 2 Function","uri":"/notes/computerscience/language/typescript/typescript_notes_2_function/"},{"categories":["TypeScript"],"content":"Default Parameters We can add default parameters to a function in case that there is no parameter passed. function Greet(name: string, greeting: string = \"Hello\") : string { return greeting + ' ' + name + '!'; } Greet('Steve');//OK, returns \"Hello Steve!\" Greet('Steve', 'Hi'); // OK, returns \"Hi Steve!\". Greet('Bill'); //OK, returns \"Hello Bill!\" We can use undefined to indicate we want to use default value. This is useful when we want default parameter at front. function Greet(greeting: string = \"Hello\", name: string) : string { return greeting + ' ' + name + '!'; } Greet(undefined, 'Steve');//returns \"Hello Steve!\" Greet(\"Hi\", 'Steve'); //returns \"Hi Steve!\". Greet(undefined, 'Bill'); //returns \"Hello Bill!\" ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_2_function/:1:4","tags":["TypeScript"],"title":"TypeScript Notes 2 Function","uri":"/notes/computerscience/language/typescript/typescript_notes_2_function/"},{"categories":["TypeScript"],"content":"Arrow Function Arrow =\u003e can replace the function keyword. Parameters are passed in the parenthesis (), and the function expression is enclosed within the curly brackets { }. let sum = (x: number, y: number): number =\u003e { return x + y; } sum(10, 20); //returns 30 If there is no parameter in a function, we can use an empty bracket. let Print = () =\u003e console.log(\"Hello TypeScript\"); Print(); //Output: Hello TypeScript If the function body consists of only one statement then no need for the curly brackets and the return keyword, as shown below. let sum = (x: number, y: number) =\u003e x + y; sum(3, 4); //returns 7 ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_2_function/:2:0","tags":["TypeScript"],"title":"TypeScript Notes 2 Function","uri":"/notes/computerscience/language/typescript/typescript_notes_2_function/"},{"categories":["TypeScript"],"content":"Arrow Function as Property A class can include an arrow function as a property, as shown below: class Employee { empCode: number; empName: string; constructor(code: number, name: string) { this.empName = name; this.empCode = code; } display = () =\u003e console.log(this.empCode +' ' + this.empName) } let emp = new Employee(1, 'Ram'); emp.display(); ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_2_function/:2:1","tags":["TypeScript"],"title":"TypeScript Notes 2 Function","uri":"/notes/computerscience/language/typescript/typescript_notes_2_function/"},{"categories":["TypeScript"],"content":"Function Overloading function add(a:string, b:string):string; function add(a:number, b:number): number; function add(a: any, b:any): any { return a + b; } add(\"Hello \", \"Steve\"); // returns \"Hello Steve\" add(10, 20); // returns 30 ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_2_function/:2:2","tags":["TypeScript"],"title":"TypeScript Notes 2 Function","uri":"/notes/computerscience/language/typescript/typescript_notes_2_function/"},{"categories":["TypeScript"],"content":"Rest Parameters Rest parameters can be used to pass n number of parameters easily. The compiler will create an array of arguments with the rest parameter name provided by us. The below is the example: function Greet(greeting: string, ...names: string[]) { return greeting + \" \" + names.join(\", \") + \"!\"; } Greet(\"Hello\", \"Steve\", \"Bill\"); // returns \"Hello Steve, Bill!\" Greet(\"Hello\");// returns \"Hello !\" ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_2_function/:2:3","tags":["TypeScript"],"title":"TypeScript Notes 2 Function","uri":"/notes/computerscience/language/typescript/typescript_notes_2_function/"},{"categories":["TypeScript"],"content":"TypeScript","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_3_objectoriented/","tags":["TypeScript"],"title":"TypeScript Notes 3 Object Oriented","uri":"/notes/computerscience/language/typescript/typescript_notes_3_objectoriented/"},{"categories":["TypeScript"],"content":"Class in TypeScript A class can include the following: Constructor Properties Methods class Employee { empCode: number; empName: string; constructor(code: number, name: string) { this.empName = name; this.empCode = code; } getSalary() : number { return 10000; } } ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_3_objectoriented/:0:1","tags":["TypeScript"],"title":"TypeScript Notes 3 Object Oriented","uri":"/notes/computerscience/language/typescript/typescript_notes_3_objectoriented/"},{"categories":["TypeScript"],"content":"Inheritance in TypeScript class Person { name: string; constructor(name: string) { this.name = name; } } class Employee extends Person { empCode: number; constructor(empcode: number, name:string) { super(name); this.empCode = empcode; } displayName():void { console.log(\"Name = \" + this.name + \", Employee Code = \" + this.empCode); } } let emp = new Employee(100, \"Bill\"); emp.displayName(); // Name = Bill, Employee Code = 100 ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_3_objectoriented/:0:2","tags":["TypeScript"],"title":"TypeScript Notes 3 Object Oriented","uri":"/notes/computerscience/language/typescript/typescript_notes_3_objectoriented/"},{"categories":["TypeScript"],"content":"Interface Class can implement interface like Java, but, unlike Java, interface can also extends class. Class implement interface A class can implement multiple interface interface IPerson { name: string; display():void; } interface IEmployee { empCode: number; } class Employee implements IPerson, IEmployee { empCode: number; name: string; constructor(empcode: number, name:string) { this.empCode = empcode; this.name = name; } display(): void { console.log(\"Name = \" + this.name + \", Employee Code = \" + this.empCode); } } let per:IPerson = new Employee(100, \"Bill\"); per.display(); // Name = Bill, Employee Code = 100 let emp:IEmployee = new Employee(100, \"Bill\"); emp.display(); //Compiler Error: Property 'display' does not exist on type 'IEmployee' Interface extends class class Person { name: string; } interface IEmployee extends Person { empCode: number; } let emp: IEmployee = { empCode : 1, name:\"James Bond\" } ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_3_objectoriented/:0:3","tags":["TypeScript"],"title":"TypeScript Notes 3 Object Oriented","uri":"/notes/computerscience/language/typescript/typescript_notes_3_objectoriented/"},{"categories":["TypeScript"],"content":"Method Overriding class Car { name: string; constructor(name: string) { this.name = name; } run(speed:number = 0) { console.log(\"A \" + this.name + \" is moving at \" + speed + \" mph!\"); } } class Mercedes extends Car { constructor(name: string) { super(name); } run(speed = 150) { console.log('A Mercedes started') super.run(speed); } } class Honda extends Car { constructor(name: string) { super(name); } run(speed = 100) { console.log('A Honda started') super.run(speed); } } let mercObj = new Mercedes(\"Mercedes-Benz GLA\"); let hondaObj = new Honda(\"Honda City\") mercObj.run(); // A Mercedes started A Mercedes-Benz GLA is moving at 150 mph! hondaObj.run(); // A Honda started A Honda City is moving at 100 mph! ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_3_objectoriented/:0:4","tags":["TypeScript"],"title":"TypeScript Notes 3 Object Oriented","uri":"/notes/computerscience/language/typescript/typescript_notes_3_objectoriented/"},{"categories":["TypeScript"],"content":"Data Modifiers There are three types of access modifiers in TypeScript: public, private and protected. public By default, all members of a class in TypeScript are public. All the public members can be accessed anywhere without any restrictions. private The private access modifier ensures that class members are visible only to that class and are not accessible outside the containing class. protected The protected access modifier is similar to the private access modifier, except that protected members can be accessed using their deriving classes. ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_3_objectoriented/:0:5","tags":["TypeScript"],"title":"TypeScript Notes 3 Object Oriented","uri":"/notes/computerscience/language/typescript/typescript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Javascript","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"JavaScript ES6 ECMAScript is a standardized version of JavaScript with the goal of unifying the language’s specifications and features. The term ECMAScript is interchangeable with the term JavaScript. ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:0:0","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Basic Syntax ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:1:0","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"let and const Variables declared with let and const are scoped to the block{ }, not to the function. Variables declared with let and const can only be accessed after they have been declared. They eliminate issues from hoisting. Variables declared with let can be reassigned, but can’t be redeclared in the same scope. Variables declared with const can’t be redeclared, or reassigned in the same scope. ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:1:1","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Mutateble const object Using the const declaration only prevents reassignment of the variable identifier. Value from the object can still be changed in the following method. const s = [5, 6, 7]; s = [1, 2, 3]; // throws error, trying to assign a const s[2] = 45; // works just as it would with an array declared with var or let console.log(s); // returns [5, 6, 45] JavaScript also provides a function Object.freeze to prevent data mutation. let obj = { name:\"FreeCodeCamp\", review:\"Awesome\" }; Object.freeze(obj); obj.review = \"bad\"; // will be ignored. Mutation not allowed obj.newProp = \"Test\"; // will be ignored. Mutation not allowed console.log(obj); // { name: \"FreeCodeCamp\", review:\"Awesome\"} ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:1:2","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Destructuring Data can be extracted from arrays and objects into distinct variables using destructuring. From array const point = [10, 25, -34, 15, 9]; // destructuring const [x, y, z] = point; // x: 10 // y: 25 // z: -34 // ignore y const [ x, , z ] = point; // x: 10 // z: -34 From object const gemstone = { type: 'quartz', color: 'rose', carat: 21.29 }; const { type, carat } = gemstone; // type: quartz // carat: 21.29 ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:1:3","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Template literals Template literals are string literals that include embedded expressions. Template literals in JavaScript are denoted with backticks ( ` ), and can template literals can contain placeholders which are represented using ${expression}. Template literals can preserve newlines as part of the string. const person = { name: \"Zodiac Hasbro\", age: 56 }; // Template literal with multi-line and string interpolation const greeting = `Hello, my name is ${person.name}! I am ${person.age}years old.`; console.log(greeting); // prints // Hello, my name is Zodiac Hasbro! // I am 56 years old. ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:1:4","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Object literal shorthand If the properties have the same name as the variables being assigned to them in an object literal, variable names can be removed. let type = 'quartz'; let color = 'rose'; let carat = 21.29; const gemstone = { type: type, color: color, carat: carat, calculateWorth: function() { // ... } }; // it is equivalent to const gemstone = { type, color, carat, // shorthand method name calculateWorth() { // ... } }; ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:1:5","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Iteration Iterable protocol Allow JavaScript objects to define or customize their iteration behavior. for...of loop A loop that iterates over iterable objects. Family of for loops for loop Need to keep track of the counter and exit condition. const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; for (let i = 0; i \u003c digits.length; i++) { console.log(digits[i]); } for...in loop Iterate with index. Loop over all enumerable properties, including any additional properties of the array’s prototype. var person = {fname:\"John\", lname:\"Doe\", age:25}; var text = \"\"; var x; for (x in person) { text += person[x]; } for...of loop Loop over any type of data that is iterable. Only loop over the values in the object. const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; for (const digit of digits) { console.log(digit); } // custom function won't be included The iterable protocol The iterable protocol is used for defining and customizing the iteration behavior of objects. Any object that is iterable can use the new for...of loop. For an object to be iterable, it must implement the iterable interface. The iterator method is available via the constant [Symbol.iterator]. The iterator method is a zero argument function that returns an iterator object. An iterator object is an object that conforms to the iterator protocol. the iterator protocol The iterator protocol is used to define a standard way that an object produces a sequence of values. This is done through implementing the next() method, a zero argument function that returns an object with two properties. value: the data representing the next value in the sequence of values within the object. done: a boolean representing if the iterator is done going through the sequence of values. If done is true, then the iterator has reached the end of its sequence of values. If done is false, then the iterator is able to produce another value in its sequence of values. const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; const arrayIterator = digits[Symbol.iterator](); console.log(arrayIterator.next()); // Object {value: 0, done: false} console.log(arrayIterator.next()); // Object {value: 1, done: false} console.log(arrayIterator.next()); // Object {value: 2, done: false} let randint = (min, max) =\u003e Math.floor(Math.random() * (max - min + 1)) + min; create_random = { min: -1, max: 90, lenght: 100, }; create_random[Symbol.iterator] = function() { return { start: 0, min: this.min, max: this.max, lenght: this.lenght, next() { this.start++; return this.start \u003c this.lenght ? { done: false, value: randint(this.min, this.max) } : { done: true }; } }; }; let array = Array.from(create_random); console.log(array); ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:1:6","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Spread operator The spread operator (...) expands, or spreads, iterable objects into multiple elements. const primes = new Set([2, 3, 5, 7]); console.log(...primes); // 2 3 5 7 This operator is useful for combining arrays. const fruits = [\"apples\", \"bananas\", \"pears\"]; const vegetables = [\"corn\", \"potatoes\", \"carrots\"]; const produce = [...fruits, ...vegetables]; const arr = [6, 89, 3, 45]; const maximus = Math.max(...arr); // returns 89 ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:1:7","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Rest parameter The rest parameter (...) can represent an indefinite number of elements as an array. const order = [20.17, 18.67, \"cheese\", \"eggs\"]; const [total, subtotal, ...items] = order; // total: 20.17 // subtotal: 18.67 // items: [\"cheese\", \"eggs\"] function howMany(...args) { return \"You have passed \" + args.length + \" arguments.\"; } console.log(howMany(0, 1, 2)); // You have passed 3 arguments. console.log(howMany(\"string\", null, [1, 2, 3], { })); // You have passed 4 arguments. Useful for defining variadic functions Variadic functions are functions that take an indefinite number of arguments. // define variadic function with arguments object function sum() { let total = 0; for(const argument of arguments) { total += argument; } return total; } // define variadic function with rest parameter function sum(...nums) { let total = 0; for(const num of nums) { total += num; } return total; } ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:1:8","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Functions ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:2:0","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Arrow functions The full name is arrow function expressions, because arrow functions are always expressions. Valid cases Stored in a variable, Passed as an argument to a function, Stored in an object’s property. Parameters When there is only one parameter, the parentheses can be omitted. When there is zero or multiple parameters, the parentheses cannot be omitted. Function body Concise body syntax: when there is only a single expression, curly braces, return, and semi-colons can all be omitted. Block body syntax: when there is more than a single expression. Parentheses and return statement can be omitted when using arrow notation. const fn0 = () =\u003e result; const fn1 = _ =\u003e result; const fn2 = singleParam =\u003e result; const fn3 = (param1, param2) =\u003e result; const fn4 = (param1, param2) =\u003e { return result; }; var myConcat1 = function(arr1, arr2) { return arr1.concat(arr2); }; var myConcat2 = (arr1, arr2) =\u003e arr1.concat(arr2); console.log(myConcat1([1, 2], [3, 4, 5])); console.log(myConcat2([1, 2], [3, 4, 5])); When not to use arrow functions Arrow functions are only expressions. There is no arrow function declaration. There is a gotcha with the this keyword in arrow functions. this and regular functions Function Call this With the new operator The new object With call / apply Specified by call / apply Method of an object The object the method is called from With no context - In non-strict mode: the global object- In strict mode: undefined this and arrow functions this is based on the function’s surrounding context. The value of this inside an arrow function is the same as the value of this outside the function. ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:2:1","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Default function parameters const fn1 = function (param1 = 'defaultValue1', param2 = 'defaultValue2') { }; Defaults and destructuring arrays function createGrid([width = 5, height = 5]) { return `Generates a ${width}x ${height}grid`; } createGrid([]); // Generates a 5 x 5 grid createGrid([2]); // Generates a 2 x 5 grid createGrid([2, 3]); // Generates a 2 x 3 grid createGrid([undefined, 3]); // Generates a 5 x 3 grid The createGrid() function expects an array to be passed to it. It uses destructuring to set the first and second items in the array. If the array is empty or if it has only one item in it, then the default parameters kick in. createGrid(); // throws an error function createGrid([width = 5, height = 5] = []) { return `Generates a ${width}x ${height}grid`; } createGrid(); // Generates a 5 x 5 grid The function expects an array to be passed in for destructuring. Pass in non-array arguments will result in error. Pass in an array, and then other arguments is fine. When no parameter is passed in, it throws an error. With = [], if createGrid() is called without any argument, it will use this default empty array. Defaults and destructuring objects A function can have an object be a default parameter and use object destructuring. An advantage of object defaults over array defaults is that it is easier to skip a parameter. function createSundae({scoops = 1, toppings = ['Hot Fudge']}) { const scoopText = scoops === 1 ? 'scoop' : 'scoops'; return `Your sundae has ${scoops}${scoopText}with ${toppings.join(' and ')}toppings.`; } createSundae({}); // Your sundae has 1 scoop with Hot Fudge toppings. createSundae({scoops: 2}); // Your sundae has 2 scoops with Hot Fudge toppings. createSundae({scoops: 2, toppings: ['Sprinkles']}); // Your sundae has 2 scoops with Sprinkles toppings. createSundae({toppings: ['Cookie Dough']}); // Your sundae has 1 scoop with Cookie Dough toppings. The same issue applies to calling createSundae without any argument. Use {scoops = 1, toppings = ['Hot Fudge']} = {} to specify a default object value. ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:2:2","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"JavaScript class JavaScript classes are just a thin mirage over regular functions and prototypal inheritance. The constructor function is called with the new keyword. The constructor function, by convention, starts with a capital letter. The constructor function controls the setting of data on the objects that will be created. “Inherited” methods are placed on the constructor function’s prototype object. ES5 classes function Plane(numEngines) { this.numEngines = numEngines; this.enginesActive = false; } Plane.prototype.startEngines = function () { console.log('starting engines...'); this.enginesActive = true; }; ES6 classes ES6 provides a new class syntax. A class is just a function. When creating a new instance, the new keyword must be used. Otherwise, an error will be thrown. Use keyword static to mark a method as static. class Plane { // everything inside the constructor function // is inside the new constructor method constructor(numEngines) { this.numEngines = numEngines; this.enginesActive = false; } // methods are placed inside the class startEngines() { console.log('starting engines…'); this.enginesActive = true; } } typeof Plane; // function Benefits of classes Less setup Clearly defined constructor function Everything is contained ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:2:3","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"ES6 subclasses Use super and extends to extend a class. In the constructor function, super must be called before this can be used. // ES6 version class Tree { constructor(size = '10', leaves = {spring: 'green', summer: 'green', fall: 'orange', winter: null}) { this.size = size; this.leaves = leaves; this.leafColor = null; } changeSeason(season) { this.leafColor = this.leaves[season]; if (season === 'spring') { this.size += 1; } } } class Maple extends Tree { constructor(syrupQty = 15, size, leaves) { // super as a function super(size, leaves); this.syrupQty = syrupQty; } changeSeason(season) { // super as an object super.changeSeason(season); if (season === 'spring') { this.syrupQty += 1; } } gatherSyrup() { this.syrupQty -= 3; } } // ES5 version function Tree(size, leaves) { this.size = (typeof size === \"undefined\")? 10 : size; const defaultLeaves = {spring: 'green', summer: 'green', fall: 'orange', winter: null}; this.leaves = (typeof leaves === \"undefined\")? defaultLeaves : leaves; this.leafColor; } Tree.prototype.changeSeason = function(season) { this.leafColor = this.leaves[season]; if (season === 'spring') { this.size += 1; } } function Maple (syrupQty, size, leaves) { Tree.call(this, size, leaves); this.syrupQty = (typeof syrupQty === \"undefined\")? 15 : syrupQty; } Maple.prototype = Object.create(Tree.prototype); // maple's prototype has been overwritten, so // the constructor property and the original // constructor function needs to be reconnected Maple.prototype.constructor = Maple; Maple.prototype.changeSeason = function(season) { Tree.prototype.changeSeason.call(this, season); if (season === 'spring') { this.syrupQty += 1; } } Maple.prototype.gatherSyrup = function() { this.syrupQty -= 3; } ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:2:4","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Built-ins Symbols A symbol is a unique and immutable data type that is often used to identify object properties. To create a symbol, write Symbol() with an optional string as its description. const sym1 = Symbol('apple'); console.log(sym1); // Symbol(apple) Uniqueness Each time a new symbol is created, regardless of the description. The description is only used to describe the symbol. It’s not used as part of the symbol itself. const sym2 = Symbol('banana'); const sym3 = Symbol('banana'); console.log(sym2 === sym3); // false Use case It is most often used to uniquely identify properties within an object. // use string as property keys, and the // second banana overwrites the first one const bowl = { 'apple': { color: 'red', weight: 136.078 }, 'banana': { color: 'yellow', weight: 183.151 }, 'orange': { color: 'orange', weight: 170.097 }, 'banana': { color: 'yellow', weight: 176.845 } }; // use symbol as property keys, // and each symbol is unique const bowl = { [Symbol('apple')]: { color: 'red', weight: 136.078 }, [Symbol('banana')]: { color: 'yellow', weight: 183.15 }, [Symbol('orange')]: { color: 'orange', weight: 170.097 }, [Symbol('banana')]: { color: 'yellow', weight: 176.845 } }; ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:2:5","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Set Sets are not indexed-based. Items in a Set cannot be accessed individually. // create const set1 = new Set() const set2 = new Set(array) // modify set1.add(element); // return the set itself set2.delete(element); // return true or false // delete set1.clear(); // check length set1.size; // check element existence set2.has(element); // retrieve all values const iterator1 = set1.keys(); // return a SetIterator const iterator2 = set1.values(); // return a SetIterator WeakSet A normal Set with the following differences: WeakSet only contains objects. Not iterable and thus cannot be looped over. Does not have a .clear() method. When an object is deleted, it will also be deleted from the WeakSet when garbage collection runs. WeakSet is useful when there needs an efficient, lightweight solution for creating groups of objects. ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:2:6","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Map Both the keys and the values can be objects, primitive values, or a combination of the two. const map = new Map(); map.set(key, value); // return the map itself map.get(key); map.delete(key); // return true or false map.clear(); map.has(key); Looping through Map Default MapIterator const iterator1 = map.keys(); iterator1.next(); const iterator2 = map.values(); iterator2.next(); for...of loop for (const [key, value] of map) { // ... } forEach loop map.forEach((value, key) =\u003e fn(value, key)); WeakMap A normal Map with the following differences: Only contain objects as keys. Not iterable. Does not have a .clear() method. When an object is deleted, the object key will also be deleted from the WeakMap when garbage collection runs. ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:2:7","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Promises A promise will start some work that will be done asynchronously. A Promise constructor takes a function with two functions. When the promise succeeds, the resolve function will be called. When the promise fails, the reject function will be called. A promise returns immediately. The promise object has a .then() method that takes in the resolve and reject functions. const promise = new Promise(function (resolve, reject) { if (successful) { resolve(arguments); } else { reject('Promise failed'); } }); promise.then((params) =\u003e { console.log(`Succeed: ${params}`); }, (errorMessage) =\u003e { console.log(errorMessage); }); ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:2:8","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Proxies Proxy constructor takes in two items: The object to be proxied. The proxy handler object. It contains the list of methods it will handle for the proxied object. Pass through proxy new Proxy(object, {}) It just passes the request directly to the source object. get trap Intercept calls to properties. Take over whenever any property on the proxy is accessed. const richard = {status: 'looking for work'}; const handler = { /** * @param target the proxied object (richard) * @param propName the name of the property being accessed (status) */ get(target, propName) { return target[propName]; } }; const agent = new Proxy(richard, handler); set trap Intercepting code that will change a property. const richard = {status: 'looking for work'}; const handler = { /** * @param target the proxied object (richard) * @param propName the name of the property being modified (payRate) * @param value the new value to be set to propName (payRate) */ set(target, propName, value) { // if the pay is being set, take 15% as commission if (propName === 'payRate') { value = value * 0.85; } target[propName] = value; } }; const agent = new Proxy(richard, handler); All traps get trap: handle calls to property access. set trap: handle setting the property to a new value. apply trap: handle being invoked (the object being proxied is a function). has trap: handle the using in operator. deleteProperty trap: handle if a property is deleted. ownKeys trap: handle when all keys are requested. construct trap: handle when the proxy is used with the new keyword as a constructor. defineProperty trap: handle when defineProperty is used to create a new property on the object. getOwnPropertyDescriptor trap: handle getting the property’s descriptors. preventExtenions trap: handle calls to Object.preventExtensions() on the proxy object. isExtensible trap: handle calls to Object.isExtensible on the proxy object. getPrototypeOf trap: handle calls to Object.getPrototypeOf on the proxy object. setPrototypeOf trap: handle calls to Object.setPrototypeOf on the proxy object. Proxies vs ES5 getter / setter With ES5’s getter and setter methods, you need to know before hand the properties that are going to be get/set. With ES6 Proxies, we do not need to know the properties beforehand. var obj = { _age: 5, _height: 4, get age() { console.log(`getting the \"age\" property`); console.log(this._age); }, get height() { console.log(`getting the \"height\" property`); console.log(this._height); } }; obj.age; // logs 'getting the \"age\" property' \u0026 5 obj.height; // logs 'getting the \"height\" property' \u0026 4 ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:2:9","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Javascript"],"content":"Generators Use a generator to be able to pause a function mid-execution. function* name() { ... } The asterisk of the generator can be placed anywhere between the function keyword and the function name. The community has coalesced into having the asterisk appear right next to the function keyword. Generators cannot be defined with fat arrow functions. Every call to next() will Fulfill the previous yield expression if there is any; Return the value following the next yield; Pause at the same next yield statement. function* foo() { console.log(`function starts`); // the first next() returns 123 and pause here const a = (yield 123); console.log(`a: ${a}`); // the second next(456) replace (yield 123) with 456, // and assign it to a, print out a's value, and pause here yield a; console.log(`function ends`); // the third next() will print out the statement, // and return undefined } const iterator = foo(); iterator.next(); // function starts // { value: 123, done: false } iterator.next(456); // a: 456 // { value: 456, done: false } iterator.next(); // function ends // { value: undefined, done: false } Reference: https://www.freecodecamp.org/learn/ https://github.com/tuliren/javascript-notes ","date":"2021-01-11","objectID":"/notes/computerscience/language/javascript/javascript_notes_2_es6/:2:10","tags":["Javascript"],"title":"Javascript Notes 2 ES6","uri":"/notes/computerscience/language/javascript/javascript_notes_2_es6/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-06-17","objectID":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/","tags":["Java"],"title":"Java Notes(2) Object Oriented Language","uri":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/"},{"categories":["Java"],"content":"Object Oriented Object-Oriented Programming is a methodology or paradigm to design a program using classes and objects. It simplifies the software development and maintenance. ","date":"2019-06-17","objectID":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/:1:0","tags":["Java"],"title":"Java Notes(2) Object Oriented Language","uri":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/"},{"categories":["Java"],"content":"Class A class in Java can contain: field(variable, attribute), methods, constructors, blocks, nested class and interface. Object is an instance of a class. There is only one way to define class in java using class keyword. The Object class is the parent class of all the classes in java by default. ","date":"2019-06-17","objectID":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/:1:1","tags":["Java"],"title":"Java Notes(2) Object Oriented Language","uri":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/"},{"categories":["Java"],"content":"Constructor Constructor in java is a special type of method that is used to initialize the object. If there is no constructor in a class, compiler automatically creates a default constructor. There is no copy constructor in java. But, we can copy the values of one object to another like copy constructor in C++. A constructor can perform other tasks instead of initialization like object creation, starting a thread, calling method etc. You can perform any operation in the constructor as you perform in the method. Constructor must not have return type. Constructor name must be same as the class name. super() is added in each class constructor automatically by compiler if there is no super() or this() ","date":"2019-06-17","objectID":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/:1:2","tags":["Java"],"title":"Java Notes(2) Object Oriented Language","uri":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/"},{"categories":["Java"],"content":"Instance initializer block Instance Initializer block is used to initialize the instance data member. It is created when instance of the class is created. It runs each time when object of the class is created. It is invoked after the parent class constructor is invoked (i.e. after super() constructor call). The instance Initializer block comes in the order in which they appear. ","date":"2019-06-17","objectID":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/:1:3","tags":["Java"],"title":"Java Notes(2) Object Oriented Language","uri":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/"},{"categories":["Java"],"content":"Four Pillars of OOP The main concepts in object oriented programming are Inheritance, Polymorphism, Abstraction, Encapsulation. ","date":"2019-06-17","objectID":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/:2:0","tags":["Java"],"title":"Java Notes(2) Object Oriented Language","uri":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/"},{"categories":["Java"],"content":"Inheritance Inheritance (IS-A) is a mechanism in which one object acquires all the properties and behaviors of parent object. The extends keyword indicates that you are making a new class that derives from an existing class. Multiple inheritance is not supported in Java through class. We can use Interface to perform it. To reduce the complexity and simplify the language, multiple inheritance is not supported in java. If a class have an entity reference, it is known as Aggregation (HAS-A relationship). Inheritance should be used only if the relationship is-a is maintained throughout the lifetime of the objects involved; otherwise, aggregation is the best choice. ","date":"2019-06-17","objectID":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/:2:1","tags":["Java"],"title":"Java Notes(2) Object Oriented Language","uri":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/"},{"categories":["Java"],"content":"Polymorphism Polymorphism is a concept by which we can perform a single action by different ways. There are two types of polymorphism in java: compile time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding. If you overload static method in java, it is the example of compile time polymorphism. In Runtime polymorphism (Dynamic Method Dispatch), an overridden method is resolved at runtime rather than compile-time. A Virtual Method is an inheritable and overridable method for which dynamic dispatch is facilitated. All non-static, non-final and non-private methods are Virtual Methods by default. When reference variable of Parent class refers to the object of Child class, it is known as upcasting. Method is overridden not the data members, so runtime polymorphism can’t be achieved by data members. Connecting a method call to the method body is known as binding. There are two types of binding : Static binding (early binding) and Dynamic binding (late binding). Method Overloading (compile time polymorphism) If a class has multiple methods having same name but different in parameters, it is known as Method Overloading. There are two ways to overload the method in java : by changing number of arguments, by changing the data type. In Java, Method Overloading is not possible by changing the return type of the method only because of ambiguity. Compile Time Error is better than Run Time Error. So, java compiler renders compiler time error if you declare the same method having same parameters. We can also overload Java main() method, but JVM calls main() method which receives string array as arguments only. One type is promoted to another implicitly if no matching datatype is found. eg. byte can be promoted to short, int, etc. If there are no matching type arguments method, and each method promotes similar number of arguments, there will be ambiguity. One type is not de-promoted implicitly for example double cannot be depromoted to any type implicitly. Method Overriding (runtime polymorphism) If subclass (child class) has the same method as declared in the parent class, it is known as method overriding. Method must have same name and parameters as in the parent class for overriding. Method overriding is used to provide specific implementation of a method that is already provided by its super class. Also used for runtime polymorphism. We cannot override static method (not also main method) because static method is bound with class whereas instance method is bound with object. Static belongs to class area and instance belongs to heap area. Method Overriding with Access Modifier: if you are overriding a method, overridden method (i.e. declared in subclass) must not be more restrictive. Covariant Return Type: It is possible to override method by changing the return type if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type. ","date":"2019-06-17","objectID":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/:2:2","tags":["Java"],"title":"Java Notes(2) Object Oriented Language","uri":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/"},{"categories":["Java"],"content":"Abstraction Abstraction is a process of hiding the implementation details and showing only functionality to the user. There are two ways to achieve abstraction in java : Abstract class and Interface. Abstract class A class that is declared as abstract (keyword) is abstract class. It can have abstract and non-abstract methods. A method that is declared as abstract and does not have implementation is abstract method. Any method with a body is non-abstract method. An abstract class can have data member, abstract method, method body, constructor and even main() method. If there is any abstract method in a class, that class must be abstract. If extending any abstract class that have abstract method, we must either provide the implementation of the method or make this class abstract. Interface An interface in java is a blueprint of a class. It has static constants and abstract methods. Since Java 8, we can have method body in interface. But we need to make it default or static method. The interface is a mechanism to achieve abstraction. It represents IS-A relationship. By using interface, we can support multiple inheritance. It can be also used to achieve loose coupling (coupling is degree of direct knowledge that one element has of another). The Java compiler adds public \u0026 abstract before the interface method. Adds public, static \u0026 final before data members. A class extends another class, an interface extends another interface but a class implements an interface. Multiple inheritance is not supported by class because of ambiguity. But, supported by interface because there is no ambiguity as implementation is provided by the implementation class. An interface with no member is called marker/tagged interface. For example: Serializable, Cloneable, Remote etc. Marker interface are used to provide essential information to JVM, so that JVM may perform some useful operation. An interface can have another interface i.e. known as nested interface. ","date":"2019-06-17","objectID":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/:2:3","tags":["Java"],"title":"Java Notes(2) Object Oriented Language","uri":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/"},{"categories":["Java"],"content":"Encapsulation Encapsulation is a process of wrapping code and data together into a single unit. To create a fully encapsulated class, make all data members of the class private, \u0026 use setter/getter methods to access data. By providing only setter or getter method, you can make the class read-only or write-only. ","date":"2019-06-17","objectID":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/:2:4","tags":["Java"],"title":"Java Notes(2) Object Oriented Language","uri":"/notes/computerscience/language/java/basicjava/java_notes_2_oop/"},{"categories":["Spring"],"content":"Spring Notes","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/spring_bean/","tags":["Java"],"title":"Spring Framework Notes 2 - Beans, BeanFactory and the ApplicationContext","uri":"/notes/computerscience/backend/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"Bean Bean represents as an objects in Java. Bean need to contain the following points: ","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/spring_bean/:1:0","tags":["Java"],"title":"Spring Framework Notes 2 - Beans, BeanFactory and the ApplicationContext","uri":"/notes/computerscience/backend/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"The Bean class The class attribute in bean is normally mandatory. The creation of bean object is through BeanFactory. It has three approaches. The first approach is where the BeanFactory itself directly creates the bean by calling its constructor (equivalent to Java code calling new), the class attribute specifies the class of the bean to be constructed. \u003cbean id=\"exampleBean\" class=\"examples.ExampleBean\"/\u003e \u003cbean name=\"anotherExample\" class=\"examples.ExampleBeanTwo\"/\u003e The second approach is to call a static, so-called factory method. The class attribute specifies the actual class containing the static factory method. This method returns the wanted object. \u003cbean id=\"exampleBean\" class=\"examples.ExampleBean2\" factory-method=\"createInstance\"/\u003e The third approach is to call an instance factory method. This method combined above two approaches. The xml file need specify the factory bean as well. \u003c!-- The factory bean, which contains a method called createInstance --\u003e \u003cbean id=\"myFactoryBean\" class=\"...\"\u003e ... \u003c/bean\u003e \u003c!-- The bean to be created via the factory bean --\u003e \u003cbean id=\"exampleBean\" factory-bean=\"myFactoryBean\" factory-method=\"createInstance\"/\u003e ","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/spring_bean/:1:1","tags":["Java"],"title":"Spring Framework Notes 2 - Beans, BeanFactory and the ApplicationContext","uri":"/notes/computerscience/backend/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"The bean identifiers (id and name) Every bean has one or more ids (also called identifiers, or names; these terms refer to the same thing). These ids must be unique within the BeanFactory or ApplicationContext the bean is hosted in. A bean will almost always have only one id, but if a bean has more than one id, the extra ones can essentially be considered aliases. ","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/spring_bean/:1:2","tags":["Java"],"title":"Spring Framework Notes 2 - Beans, BeanFactory and the ApplicationContext","uri":"/notes/computerscience/backend/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"Bean scopes ","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/spring_bean/:1:3","tags":["Java"],"title":"Spring Framework Notes 2 - Beans, BeanFactory and the ApplicationContext","uri":"/notes/computerscience/backend/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"The singleton scope Only one shared instance of a singleton bean is managed, and all requests for beans with an id or ids matching that bean definition result in that one specific bean instance being returned by the Spring container. Spring’s concept of a singleton bean differs from the Singleton pattern as defined in the Gang of Four (GoF) patterns book. The GoF Singleton hard-codes the scope of an object such that one and only one instance of a particular class is created per ClassLoader. The scope of the Spring singleton is best described as per container and per bean. This means that if you define one bean for a particular class in a single Spring container, then the Spring container creates one and only one instance of the class defined by that bean definition. The singleton scope is the default scope in Spring. To define a bean as a singleton in XML, you would write, for example: \u003cbean id=\"accountService\" class=\"com.foo.DefaultAccountService\"/\u003e \u003c!-- the following is equivalent, though redundant (singleton scope is the default); using spring-beans-2.0.dtd --\u003e \u003cbean id=\"accountService\" class=\"com.foo.DefaultAccountService\" scope=\"singleton\"/\u003e \u003c!-- the following is equivalent and preserved for backward compatibility in spring-beans.dtd --\u003e \u003cbean id=\"accountService\" class=\"com.foo.DefaultAccountService\" singleton=\"true\"/\u003e ","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/spring_bean/:1:4","tags":["Java"],"title":"Spring Framework Notes 2 - Beans, BeanFactory and the ApplicationContext","uri":"/notes/computerscience/backend/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"The prototype scope The non-singleton, prototype scope of bean deployment results in the creation of a new bean instance every time a request for that specific bean is made. That is, the bean is injected into another bean or you request it through a getBean() method call on the container. As a rule, use the prototype scope for all stateful beans and the singleton scope for stateless beans. \u003c!-- using spring-beans-2.0.dtd --\u003e \u003cbean id=\"accountService\" class=\"com.foo.DefaultAccountService\" scope=\"prototype\"/\u003e \u003c!-- the following is equivalent and preserved for backward compatibility in spring-beans.dtd --\u003e \u003cbean id=\"accountService\" class=\"com.foo.DefaultAccountService\" singleton=\"false\"/\u003e In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean: the container instantiates, configures, and otherwise assembles a prototype object, and hands it to the client, with no further record of that prototype instance. Singleton beans with prototype-bean dependencies When you use singleton-scoped beans with dependencies on prototype beans, be aware that dependencies are resolved at instantiation time. Thus if you dependency-inject a prototype-scoped bean into a singleton-scoped bean, a new prototype bean is instantiated and then dependency-injected into the singleton bean. The prototype instance is the sole instance that is ever supplied to the singleton-scoped bean. However, suppose you want the singleton-scoped bean to acquire a new instance of the prototype-scoped bean repeatedly at runtime. You cannot dependency-inject a prototype-scoped bean into your singleton bean, because that injection occurs only once, when the Spring container is instantiating the singleton bean and resolving and injecting its dependencies. I ","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/spring_bean/:1:5","tags":["Java"],"title":"Spring Framework Notes 2 - Beans, BeanFactory and the ApplicationContext","uri":"/notes/computerscience/backend/spring/spring/spring_bean/"},{"categories":["Javascript"],"content":"Javascript","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Object Oriented Programming ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:0:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Creating objects // Using literal notation: const myObject = {}; // Using the Object() constructor function: const myObject = new Object(); Both methods return an object without properties. The Object() constructor function is a bit slower. The recommended way to create new objects in JavaScript is to use literal notation. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:1:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Modifying properties Data within objects are mutable. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:2:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Adding properties Properties can be added to objects simply by specifying the property name, then giving it a value ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:3:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Removing properties // returns true if deletion is successful delete object.property; delete object.function; ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:4:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Passing primitives Primitives are immutable. Any changes made to an argument inside a function effectively creates a copy local to that function, and does not affect the primitive outside of that function function changeToEight(n) { // whatever n was, it is now 8, // but only in this function! n = 8; } let n = 7; changeToEight(n); console.log(n); // 7 ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:5:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Passing objects Objects are mutable. When an object is passed into a function, JavaScript makes a copy of the reference to that object. Both the original reference and the copied references point to the same object. function setToBlue(object) { object.favoriteColor = 'blue'; } let originalObject = { favoriteColor: 'red' }; setToBlue(originalObject); originalObject.favoriteColor; // 'blue' ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:6:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Comparing objects When comparing two objects with ===, the expression will only return true when comparing two references to exactly the same object. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:7:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Functions vs. methods Methods are functions inside an object. Methods are special properties whose values are functions. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:8:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Access object in the method Using this, methods can directly access the object that it is called on. this is a reserved word in JavaScript, and cannot be used as an identifier. Depending on how a function is called, this can be set to different values. const triangle = { type: 'scalene', identify: function () { console.log(`This is a ${this.type}triangle.`); } }; ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:9:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Value of this When a method is invoked, the value of this is the object left of the dot at invocation. When a regular function is invoked, the value of this is the global window object. const car = { numberOfDoors: 4, drive: function () { console.log(`Get in one of the ${this.numberOfDoors}doors, and let's go!`); } }; car.drive(); // Get in one of the 4 doors, and let's go! const letsRoll = car.drive; letsRoll(); // Get in one of the undefined doors, and let's go! The second this in the code above refers to the window object. Even though car.drive is a method, the function is stored in the a variable letsRoll. Because letsRoll() is invoked as a regular function, this will refer to the window object inside of it. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:10:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"The window object The window object is provided by the browser environment and is globally accessible to JavaScript code using the identifier, window. This object is not part of the JavaScript specification (i.e. ECMAScript). It is developed by the W3C. This window object has access to a ton of information about the page itself, including: // the page's URL window.location; // the vertical scroll position of the page window.scrollY; // scroll to 200 pixels down from the current location window.scroll(0, window.scrollY + 200); // open a new web page window.open(\"https://www.udacity.com/\"); ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:11:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Globals Global variables Every variable declaration with var made at the global level (outside of a function) automatically becomes a property on the window object. let and const are introduced in ES6. Variabled declared with them are not added to the window object. Global functions Any global function declarations are accessible on the window object as methods. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:12:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Avoid globals Tight coupling Code that is too dependent on the details of each other. Changing one unintentionally alters the functioning of some other code. Name collisions Two (or more) functions depend on a variable with the same name. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:13:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Object methods The Object() function includes a few methods of its own. Object.keys(\u003cobject\u003e): returns an array of the provided objects’ property names. Object.values(\u003cobject\u003e): returns an array of the provided objects’ property values. These two methods will return the items in the same order as when using a for loop on the object. Classes and objects ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:14:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Constructor function Persist data with the this keyword. No explicit return value. Can have parameters. function SoftwareDeveloper(name) { this.favoriteLanguage = 'JavaScript'; this.name = name; } ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:15:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Creating a new object Use the new operator. let developer = new SoftwareDeveloper('David'); When the new operator is not used, no object is created. The function is invoked like a regular function. Since there is no return value, the variable will be assigned to undefined. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:16:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"The instanceof operator This operator confirms whether an object is created by a specific constructor function. This operator actually tests whether the constructor appears in the prototype chain of an object. object instanceof ClassName; // return a boolean typeof object // \"object\" ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:17:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"this in objects A value for this is set when a method is invoked on an object, and that value refers to that object. Four ways to call functions Calling a constructor function with the new keyword sets this to a newly-created object. Calling a method sets this to the object that owns the method. Calling a function on its own (i.e. invoking a regular function) sets this to window. Calling a function with call or apply allow customization of this. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:18:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"call() Set this to custom objects. // this variable is set to thisObject in the invocation function.call(thisObject, arguments) Invoke functions attached to objects (i.e. methods). const mockingbird = { title: 'To Kill a Mockingbird', describe: function () { console.log(`${this.title}is a classic novel`); } }; const pride = { title: 'Pride and Prejudice' }; mockingbird.describe.call(pride); // 'Pride and Prejudice is a classic novel' ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:19:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"apply() Pass in arguments in an array. Useful when the number of arguments is unknown. function.apply(thisObject, [arguments]) ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:20:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"bind() When methods are passed in as a callback, this reference may be lost. function invokeTwice(cb) { cb(); cb(); } const dog = { age: 5, growOneYear: function () { this.age += 1; } }; // growOneYear is passed in as a function, so // this inside growOneYear is set to windows, // and the age is not updated invokeTwice(dog.growOneYear); dog.age; // 5 Use anonymous closure to close over the dog object. invokeTwice(function () { // growOneYear is directly call onto the dog object dog.growOneYear(); }); dog.age; // 7 bind() method provides an less verbose alternative approach. It is called onto a function and returns a copy of that function with a specified this value. const growOneYearMethod = dog.growOneYear.bind(dog); invokeTwice(growOneYearMethod); dog.age; // 7 ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:21:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"prototype Each function has a prototype property. prototype is an object. An object created by the new operator of a constructor function is linked to its constructor’s prototype. This link allows the object to access the prototype's properties and methods as if it were its own. Whether accessing a property or invoking a method, the JavaScript interpreter looks for them along the prototype chain in this order: The object’s own properties. The object’s constructor’s prototype. At the very end of the chain is the Object() object, or the top-level parent. If the property still cannot be found, the property is undefined. By adding methods to the prototype, memory is saved as more objects are instantiated. function Dalmatian (name) { this.name = name; } // register a method on the prototype Dalmatian.prototype.bark = function() { console.log(`${this.name}barks!`); }; When new methods are added to prototype, existing objects can access the new methods as well. When proprotype is replaced, objects created before the replacement are still linked to the old prototype. Objects created after the replacement are linked to the new prototype. function Cat() { this.color = 'white'; } let cat1 = new Cat(); cat1.color; // white cat1.meow(); // exception Cat.prototype = { isHungry: false, meow: function () { return 'Meow!'; } }; // new properties and methods are not available // for existing objects cat1.isHungry; // undefined cat1.meow(); // exception let cat2 = new Cat(); cat2.color; // white cat2.meow(); // Meow! cat2.isHungry; // false ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:22:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Relevant Methods hasOwnProperty() hasOwnProperty() allows user to find the origin of a particular property. This method takes in a string of the property name, and returns a boolean indicating whether or not the property belongs to the object itself (i.e. that property was not inherited). isPrototypeOf() This method checks whether or not an object exists in another object’s prototype chain. It can be used to confirm if a particular object serves as the prototype of another object. Object.getPrototypeOf() This method retrieves the prototype of a given object. constructor A property that returns a reference to the constructor function that creates the object. Objects created with literal notation are constructed with the Object() constructor function. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:23:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"__proto__ An object is secretly linked to its constructor function’s prototype object through that instance’s __proto__ property. object.__proto__ === object.constructor.prototype; // true It is highly discouraged to reassign the __proto__ property, or even use it in any written code. There are compatibility issues across browsers. Since the JavaScript engine searches and accesses properties along the prototype chain, mutating an object’s prototype can lead to performance issues. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:24:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Inheritance Inheritance in JavaScript is all about setting up the prototype chain. Users should not use __proto__ to manage inheritance. Users should not inherit only the prototype, because this doesn’t set up the prototype chain, and any changes made to a child object will also be reflected in a parent object. // inappropriate Child.prototype = Parent.prototype Use Object.create() to manage inheritance without altering the prototype. This method takes in a single object as an argument, and returns a new object with its __proto__ property set to the argument passed into it. Objects created with this method extend from the passed in argument. const mammal = { vertebrate: true, earBones: 3 }; // rabbit extends mammal const rabbit = Object.create(mammal); console.log(rabbit.__proto__ === mammal); // true Create inheritance function Animal (name) { this.name = name; } Animal.prototype.walk = function () { console.log(`${this.name}walks!`); }; function Cat (name) { // call super constructor; use call // instead of new operator so that // no Animal object is created Animal.call(this, name); this.lives = 9; } Cat.prototype.constructor === Cat // true // link Cat.prototype.__proto__ to Animal.prototype Cat.prototype = Object.create(Animal.prototype); // now Cat prototype's constructor is set to Animal // https://stackoverflow.com/a/20830553 Cat.prototype.constructor // Animal // so its constructor needs to be changed back Cat.prototype.constructor = Cat; // add a method only shared by Cat objects Cat.prototype.meow = function () { console.log('Meow!'); }; const bambi = new Cat('Bambi'); bambi.meow(); bambi.walk(); bambi.name; Object-Oriented Design Patterns ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:25:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Single inheritance An object’s .prototype property points to just one object. This is because JavaScript only supports single inheritance. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:26:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Factory Functions A factory function is a function that returns an object, but isn’t itself a class or constructor. We can invoke a factory function as a normal function without using the new operator to avoid the complexity of classes and constructors. function Basketball(color) { return { color: color, numDots: 35000 }; } const orangeBasketball = Basketball('orange'); console.log(orangeBasketball); // { color: 'orange', numDots: 35000 } Category Factory Function Constructor Function Can create new object each time Yes Yes Can receive arguments Yes Yes Implicate prototypal inheritance No Yes Invocation Normal functionfactoryFunc() With the new operatornew ConstructorFunc() ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:27:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Mixins A mixin is a technique that takes the properties and methods from one object and copies them over to another object. Mixin is not meant to be added to the prototype chain. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:28:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Object.assign() Object.assign() is a method that (shallow) copies an object’s own (non-inherited) properties from one or more source objects into a target object, then returns the updated target object. Object.assign() does not create and return a new object. It directly modifies then returns the same target object that was passed in. Values of existing properties will be overwritten. This method is introduced in ES2015 (ES6). target = Object.assign(target, source1, source2, ...); ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:28:1","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Functional Mixins A functional mixin is a composable factory function that receives a mixin as an argument, copies properties and methods from that mixin, and returns a new object. Functional mixins are composable. We can use them as individual pieces of code that add specific properties like an assembly line. function CoffeeMaker(object) { let needsRefill = false; return Object.assign({}, object, { pourAll: function () { needsRefill = true; }, isEmpty: function () { return needsRefill; } }); } const mixedCoffeeMaker = CoffeeMaker({ style: 'percolator' }); // mixedCoffeeMaker is equivalent to { style: 'percolator', pourAll: function () { needsRefill = true; }, isEmpty: function () { return needsRefill; } } ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:28:2","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Private Properties JavaScript has no concept of private properties out-of-the-box. There is no special syntax or keyword we can use to protect certain properties from being accessed. Some object properties and method names may be prefixed with an underscore (_). It They are private by convention only. we can use scope and closures to create a private state. function myCounter() { let count = 0; return function () { count += 1; return count; }; } let counter = myCounter(); counter(); // 1 counter(); // 2 ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:29:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Module Pattern Use function scope, closure, and IIFE. let moduleVar = (function () { return { // privatr variable let privateVar = 'private variable'; return { // setter setVar: function (varValue) { privateVar = varValue; } // getter getVar: function () { return privateVar; } } }; }()); Advantages of module pattern: Private properties Usage of IIFE that prevents pollution of global scope Code organization ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:30:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Revealing Module Pattern While we still maintain encapsulation (as in the Module Pattern), we also reveal certain properties (and methods). Key ingredients to the Revealing Module Pattern: An IIFE (wrapper) The module content (variables, methods, objects, etc.) A returned object literal with keys pointing to data to be revealed let person = (function () {] // private properties let privateAge = 0; let privateName = 'Andrew'; // private method function privateAgeOneYear() { privateAge += 1; console.log(`One year has passed! Current age is ${privateAge}`); } // public method function publicDisplayName() { console.log(`Name: ${privateName}`); } // public method function publicAgeOneYear() { privateAgeOneYear(); } // object literal return { // keys pointing to data to be revealed name: publicDisplayName, age: publicDisplayName }; })(); Advantages of the revealing module pattern: There is clarity at the end of the module (in the return statement) as to which variables or methods may be accessed publicly. It has consistent syntax. In contrast, the normal Module Pattern may contain variables and functions spread throughout the entire function body. Function ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:31:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Functions are first-class functions Functions can: be stored in variables be returned from a function be passed as arguments into another function A function that takes other functions as arguments (and/or returns a function) is known as a higher-order function. A function that is passed as an argument into another function is called a callback function. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:32:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Scope Functions have access to: The function’s arguments Local variables declared within the function Variables from its parent function’s scope Global variables JavaScript is function-scoped Variables in JavaScript are traditionally defined in the scope of a function, rather than in the scope of a block. Any variables defined inside that function are not available outside of that function, since entering a function will change scope. Any variables defined inside a block (e.g. within an if statement) are available outside of that block. ES6 syntax allows for block-scoped variables with let and const. These keywords are used to declare block-scoped variables in JavaScript. They largely replace the need for var. Scope chain: JavaScript interpreter will search the value of a variable in the following order: Local variables Parent function’s variables Parent function’s parent function’s variables Global variables ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:33:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Variable shadowing When a variable has the same name as another variable somewhere in the scope chain, the variable with local scope will temporarily “shawow” the variable in the outer scope. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:34:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Closure Closure The function itself The scope chain of the code where the function is declared It is the process of a function retaining access to its scope. Formal definition: the combaination of a function and the lexical environment within which that function. Lexical environment The association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. I.e. the code as it is written in the JavaScript file ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:35:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Creating a closure Every time a function is defined, closure is created for that function. Every function has closure. Functions close over at least one other context along the scope chain: the global scope. Recall that a nested function has access to variables outside of it. These nested functions close over (i.e. capture) variables that aren’t passed in as arguments nor defined locally. function remember(number) { // the returned function retains the // scope chain of its parent function return function() { return number; } } const returnedFunction = remember(5); console.log( returnedFunction() ); // 5 ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:36:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Garbage collection JavaScript manages memory with automatic garbage collection. If the nested function captures and uses its parent’s variables (or variables along the scope chain), those variables will stay in memory as long as the functions that utilize them can still be referenced. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:37:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Function declarations vs. expressions Function declaration Defines a function Does not require a variable to be assigned to it Does not return a value function returnHello() { return 'Hello!'; } Function expression Does return a value Can be anonymous or named Part of another expression’s syntax Commonly assigned to variables // anonymous const myFunction = function () { return 'Hello!'; }; // named const myFunction = function returnHello() { return 'Hello!'; }; ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:38:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Immediately-invoked function expressions (IIFE) A function that is called as soon as it is declared: (function [name](parameters){ // function body })(arguments); (function [name](parameters){ // function body }(arguments)); // anonymous (function() { alert('Hi!'); })(); // named (function sayHi() { alert('Hi!'); })(); (function () { console.log(\"Chirp, chirp!\"); })(); ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:39:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"IIFE to Create a Module An immediately invoked function expression (IIFE) is often used to group related functionality into a single object or module. function glideMixin(obj) { obj.glide = function() { console.log(\"Gliding on the water\"); }; } function flyMixin(obj) { obj.fly = function() { console.log(\"Flying, wooosh!\"); }; } let motionModule = (function () { return { glideMixin: function(obj) { obj.glide = function() { console.log(\"Gliding on the water\"); }; }, flyMixin: function(obj) { obj.fly = function() { console.log(\"Flying, wooosh!\"); }; } } })(); // The two parentheses cause the function to be immediately invoked Note that you have an immediately invoked function expression (IIFE) that returns an object motionModule. This returned object contains all of the mixin behaviors as properties of the object. The advantage of the module pattern is that all of the motion behaviors can be packaged into a single object that can then be used by other parts of your code. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:40:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"Private scope One of the primary uses for IIFE is to create private scope (i.e., private state). // immediately-invoked function expression const myFunction = ( function () { // variable available for the returned function const hi = 'Hi!'; return function () { console.log(hi); } } )(); The returned anonymous function closes over (i.e. captures) the hi variable. This allows myFunction to maintain a private, mutable state that cannot be accessed outside the function. Because the function expressed is called immediately, the IIFE wraps up the code nicely so that it won’t pollute the global scope. IIFE is best for one-time task without polluting the global environment with extra variables. ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:41:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Javascript"],"content":"IIFE example Create a button that alerts the user on every other click. One way is to keep track of the number of clicks of the button with a global variable. The better way is to enclose the data in the event handler itself. \u003c!-- button.html --\u003e \u003chtml\u003e \u003cbody\u003e \u003cbutton id='button'\u003eClick me!\u003c/button\u003e \u003cscript src='button.js'\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e // button.js const button = document.getElementById('button'); // the function creates a closure to protect the count // variable from being accesses externally button.addEventListener('click', (function() { let count = 0; // the returned function closes on the count variable return function() { count += 1; if (count === 2) { alert('This alert appears every other press!'); count = 0; } }; })()); The first function creates a closure to Define the count variable Protect the variable from being accesses externally The second returned anonymous function creates a closure to Access and modify the count variable Reference: https://github.com/tuliren/javascript-notes ","date":"2021-01-15","objectID":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/:42:0","tags":["Javascript"],"title":"Javascript Notes 3 Object Oriented","uri":"/notes/computerscience/language/javascript/javascript_notes_3_objectoriented/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Java"],"content":"The java.util package contains all the classes and interfaces for Collection framework. Map : An object that maps keys to values. A map is not ordered and cannot contain duplicate keys (but can contain duplicate values). Each key can map to at most one value. Collection : A collection represents a group of objects, known as its elements. The JDK provides implementations of more specific subinterfaces like Set and List. List : A list is an ordered list of objects, where the same object may well appear more than once. For example: [1, 7, 1, 3, 1, 1, 1, 5]. It makes sense to talk about the “third element” in a list. You can add an element anywhere in the list, change an element anywhere in the list, or remove an element from any position in the list. Queue : A queue is also ordered, but you’ll only ever touch elements at one end. All elements get inserted at the “end” and removed from the “beginning” (or head) of the queue. You can find out how many elements are in the queue, but you can’t find out what, say, the “third” element is. You’ll see it when you get there. Set : A set is not ordered and cannot contain duplicates. Any given object either is or isn’t in the set. {7, 5, 3, 1} is the exact same set as {1, 7, 3, 5}. You again can’t ask for the “third” element or even the “first” element, since they are not in any particular order. You can add or remove elements, and you can find out if a certain element exists. ListSetQueueMap OrderYesNoYesNo DuplicatesYesNoYesNo (Allow duplicate values not keys) Null ValuesYesSingle NullYes (LinkedList Queue). No (Priority Queue).Single null key and many null values ","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/:0:0","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Java"],"content":"Hierarchy of Collection Interface : ","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/:1:0","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Java"],"content":"Methods of Collection Interface : No.MethodDescription 1public boolean add(Object element) is used to insert an element in this collection. 2public boolean addAll(Collection c)is used to insert the specified collection elements in the invoking collection. 3public boolean remove(Object element)is used to delete an element from this collection. 4public boolean removeAll(Collection c)is used to delete all the elements of specified collection from the invoking collection. 5public boolean retainAll(Collection c)is used to delete all the elements of invoking collection except the specified collection. 6public int size()return the total number of elements in the collection. 7public void clear()removes the total no of element from the collection. 8public boolean contains(Object element)is used to search an element. 9public boolean containsAll(Collection c)is used to search the specified collection in this collection. 10public Iterator iterator()returns an iterator. 11public Object[] toArray()converts collection into array. 12public boolean isEmpty()checks if collection is empty. 13public boolean equals(Object element)matches two collection. 14public int hashCode()returns the hashcode number for collection. ","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/:2:0","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Java"],"content":"Methods of Iterator Interface : No.MethodDescription 1public boolean hasNext()It returns true if iterator has more elements. 2public Object next()It returns the element and moves the cursor pointer to the next element. 3public void remove()It removes the last elements returned by the iterator. It is rarely used. ","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/:3:0","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Java"],"content":"ArrayList vs LinkedList : ArrayListLinkedList 1) ArrayList internally uses dynamic array to store the elements.LinkedList internally uses doubly linked list to store the elements. 2) Manipulation with ArrayList is slow because it internally uses array. If any element is removed from the array, all the bits are shifted in memory.Manipulation with LinkedList is faster than ArrayList because it uses doubly linked list so no bit shifting is required in memory. 3) ArrayList class can act as a list only because it implements List only.LinkedList class can act as a list and queue both because it implements List and Deque interfaces. 4) ArrayList is better for storing and accessing data.LinkedList is better for manipulating data. ","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/:4:0","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Java"],"content":"ArrayList vs Vector : ArrayListVector 1) ArrayList is not synchronized.Vector is synchronized. 2) ArrayList increments 50% of current array size if number of element exceeds from its capacity.Vector increments 100% means doubles the array size if total number of element exceeds than its capacity. 3) ArrayList is not a legacy class, it is introduced in JDK 1.2.Vector is a legacy class. 4) ArrayList is fast because it is non-synchronized.Vector is slow because it is synchronized i.e. in multithreading environment, it will hold the other threads in runnable or non-runnable state until current thread releases the lock of object. 5) ArrayList uses Iterator interface to traverse the elements.Vector uses Enumeration interface to traverse the elements. But it can use Iterator also. ","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/:5:0","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Java"],"content":"Hierarchy of Map Interface : ","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/:6:0","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Java"],"content":"Useful Methods of Map Interface : MethodDescription Object put(Object key, Object value)It is used to insert an entry in this map. void putAll(Map map)It is used to insert the specified map in this map. Object remove(Object key)It is used to delete an entry for the specified key. Object get(Object key)It is used to return the value for the specified key. boolean containsKey(Object key)It is used to search the specified key from this map. Set keySet()It is used to return the Set view containing all the keys. Set entrySet()It is used to return the Set view containing all the keys and values. ","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/:7:0","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Java"],"content":"Methods of Map.Entry Interface : MethodDescription Object getKey()It is used to obtain key. Object getValue()It is used to obtain value. ","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/:8:0","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Java"],"content":"HashMap vs HashTable : HashMapHashtable 1) HashMap is non synchronized. It is not-thread safe and can't be shared between many threads without proper synchronization code.Hashtable is synchronized. It is thread-safe and can be shared with many threads. 2) HashMap allows one null key and multiple null values.Hashtable doesn't allow any null key or value. 3) HashMap is a new class introduced in JDK 1.2.Hashtable is a legacy class. 4) HashMap is fast.Hashtable is slow. 5) We can make the HashMap as synchronized by calling this code Map m = Collections.synchronizedMap(hashMap);Hashtable is internally synchronized and can't be unsynchronized. 6) HashMap is traversed by Iterator.Hashtable is traversed by Enumerator and Iterator. 7) Iterator in HashMap is fail-fast.Enumerator in Hashtable is not fail-fast. 8) HashMap inherits AbstractMap class.Hashtable inherits Dictionary class. ","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/:9:0","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Java"],"content":"Collections Framework Implementation Classes Summary : ","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/:10:0","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Java"],"content":"Comparable vs Comparator Interfaces : ComparableComparator 1) Comparable provides single sorting sequence. In other words, we can sort the collection on the basis of single element such as id or name or price etc. Comparator provides multiple sorting sequence. In other words, we can sort the collection on the basis of multiple elements such as id, name and price etc. 2) Comparable affects the original class i.e. actual class is modified.Comparator doesn't affect the original class i.e. actual class is not modified. 3) Comparable provides compareTo() method to sort elements.Comparator provides compare() method to sort elements. 4) Comparable is found in java.lang package.Comparator is found in java.util package. 5) We can sort the list elements of Comparable type by Collections.sort(List) method.We can sort the list elements of Comparator type by Collections.sort(List,Comparator) method. ","date":"2019-07-16","objectID":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/:11:0","tags":["Java"],"title":"Java Notes(3) Collection Framework","uri":"/notes/computerscience/language/java/basicjava/java_notes_3_collection/"},{"categories":["Spring"],"content":"Spring Notes","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/object_instantiation_with_iocdi/","tags":["Java"],"title":"Spring Framework Notes 3 - Object Instantiation with IOC/DI","uri":"/notes/computerscience/backend/spring/spring/object_instantiation_with_iocdi/"},{"categories":["Spring"],"content":"Inverse of Control (IOC) and Dependency Injection Inversion of Control (IoC): Application get the objects that they need from an outside source. Dependency Injection (DI): Dependency Injection is one type of Inversion of Control. It allows the creation of dependent objects outside of a class and provides those objects to a class through constructor or through factory method. Example For example, a text editor want to have spell checking. The standard code would look something like below: public class TextEditor { private SpellChecker checker; public TextEditor() { this.checker = new SpellChecker(); } } The inverse controller code would look like below: public class TextEditor { private IocSpellChecker checker; public TextEditor(IocSpellChecker checker) { this.checker = checker; } } In the first code example we are instantiating SpellChecker this.checker = new SpellChecker();, which means the TextEditor class directly depends on the SpellChecker class. In the second code example we are creating an abstraction by having the SpellChecker dependency class in TextEditor’s constructor signature (not initializing dependency in class). This allows us to call the dependency then pass it to the TextEditor class like so: void main(){ EnglishSpellChecker englishSpellChecker = new EnglishSpellChecker; // dependency FrenchSpellChecker frenchSpellChecker = new FrenchSpellChecker; // We can decide which spell checker being used TextEditor textEditor = new TextEditor(englishSpellChecker); } The client who create the TextEditor class has control over which SpellChecker implementation to use as this is injected into TextEditor signature Spring uses dependency injection. The following is the implementation by both xml or java. XML Implementation The following XML declares two beans, an InventoryService bean and a ProductService bean, and wires the InventoryService bean into ProductService via a constructor argument: \u003cbean id=\"inventoryService\" class=\"com.example.InventoryService\" /\u003e \u003cbean id=\"productService\" class=\"com.example.ProductService\" /\u003e \u003cconstructor-arg ref=\"inventoryService\" /\u003e \u003c/bean\u003e Java Implementation The @Configuration annotation indicates to Spring that this is a configuration class that will provide beans to the Spring application context. The configuration’s class methods are annotated with @Bean, indicating that the objects they return should be added as beans in the application context. @Configuration public class ServiceConfiguration { @Bean public InventoryService inventoryService() { return new InventoryService(); } @Bean public ProductService productService() { return new ProductService(inventoryService()); } } ","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/object_instantiation_with_iocdi/:1:0","tags":["Java"],"title":"Spring Framework Notes 3 - Object Instantiation with IOC/DI","uri":"/notes/computerscience/backend/spring/spring/object_instantiation_with_iocdi/"},{"categories":["Spring"],"content":"Dependency Injection Inner Bean There are two types of dependency injection in Spring. ","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/object_instantiation_with_iocdi/:2:0","tags":["Java"],"title":"Spring Framework Notes 3 - Object Instantiation with IOC/DI","uri":"/notes/computerscience/backend/spring/spring/object_instantiation_with_iocdi/"},{"categories":["Spring"],"content":"Type 1 Setter-based dependency injection Setter-based dependency injection is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean. public class TextEditor { private SpellChecker spellChecker; // a setter method to inject the dependency. public void setSpellChecker(SpellChecker spellChecker) { System.out.println(\"Inside setSpellChecker.\" ); this.spellChecker = spellChecker; } // a getter method to return spellChecker public SpellChecker getSpellChecker() { return spellChecker; } public void spellCheck() { spellChecker.checkSpelling(); } } public class SpellChecker { public SpellChecker(){ System.out.println(\"Inside SpellChecker constructor.\" ); } public void checkSpelling() { System.out.println(\"Inside checkSpelling.\" ); } } import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainApp { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); TextEditor te = (TextEditor) context.getBean(\"textEditor\"); te.spellCheck(); } } \u003c?xml version = \"1.0\" encoding = \"UTF-8\"?\u003e \u003cbeans xmlns = \"http://www.springframework.org/schema/beans\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\u003e \u003c!-- Definition for textEditor bean --\u003e \u003cbean id = \"textEditor\" class = \"com.TextEditor\"\u003e \u003cproperty name = \"spellChecker\" ref = \"spellChecker\"/\u003e \u003c/bean\u003e \u003c!-- Definition for spellChecker bean --\u003e \u003cbean id = \"spellChecker\" class = \"com.SpellChecker\"\u003e\u003c/bean\u003e \u003c/beans\u003e ","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/object_instantiation_with_iocdi/:2:1","tags":["Java"],"title":"Spring Framework Notes 3 - Object Instantiation with IOC/DI","uri":"/notes/computerscience/backend/spring/spring/object_instantiation_with_iocdi/"},{"categories":["Spring"],"content":"Type 2 Constructor-based dependency injection Constructor-based dependency injection is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on the other class. public class TextEditor { private SpellChecker spellChecker; public TextEditor(SpellChecker spellChecker) { System.out.println(\"Inside TextEditor constructor.\" ); this.spellChecker = spellChecker; } public void spellCheck() { spellChecker.checkSpelling(); } } public class SpellChecker { public SpellChecker(){ System.out.println(\"Inside SpellChecker constructor.\" ); } public void checkSpelling() { System.out.println(\"Inside checkSpelling.\" ); } } import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainApp { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); TextEditor te = (TextEditor) context.getBean(\"textEditor\"); te.spellCheck(); } } \u003c?xml version = \"1.0\" encoding = \"UTF-8\"?\u003e \u003cbeans xmlns = \"http://www.springframework.org/schema/beans\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\u003e \u003c!-- Definition for textEditor bean --\u003e \u003cbean id = \"textEditor\" class = \"com.TextEditor\"\u003e \u003cconstructor-arg ref = \"spellChecker\"/\u003e \u003c/bean\u003e \u003c!-- Definition for spellChecker bean --\u003e \u003cbean id = \"spellChecker\" class = \"com.SpellChecker\"\u003e\u003c/bean\u003e \u003c/beans\u003e Constructor arguments resolution The order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor. public class Foo { public Foo(Bar bar, Baz baz) { // ... } } \u003cbeans\u003e \u003cbean id = \"foo\" class = \"x.y.Foo\"\u003e \u003cconstructor-arg ref = \"bar\"/\u003e \u003cconstructor-arg ref = \"baz\"/\u003e \u003c/bean\u003e \u003cbean id = \"bar\" class = \"x.y.Bar\"/\u003e \u003cbean id = \"baz\" class = \"x.y.Baz\"/\u003e \u003c/beans\u003e public class Foo { public Foo(int year, String name) { // ... } } The container can also use type matching with types, if you explicitly specify the type of the constructor argument using the type attribute. For example − \u003cbeans\u003e \u003cbean id = \"exampleBean\" class = \"examples.ExampleBean\"\u003e \u003cconstructor-arg type = \"int\" value = \"2001\"/\u003e \u003cconstructor-arg type = \"java.lang.String\" value = \"Zara\"/\u003e \u003c/bean\u003e \u003c/beans\u003e Finally, the best way to pass constructor arguments, use the index attribute to specify explicitly the index of constructor arguments. Here, the index is 0 based. For example − \u003cbeans\u003e \u003cbean id = \"exampleBean\" class = \"examples.ExampleBean\"\u003e \u003cconstructor-arg index = \"0\" value = \"2001\"/\u003e \u003cconstructor-arg index = \"1\" value = \"Zara\"/\u003e \u003c/bean\u003e \u003c/beans\u003e ","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/object_instantiation_with_iocdi/:2:2","tags":["Java"],"title":"Spring Framework Notes 3 - Object Instantiation with IOC/DI","uri":"/notes/computerscience/backend/spring/spring/object_instantiation_with_iocdi/"},{"categories":["Spring"],"content":"Spring Injecting Collection Java Collection class object can also be injected by using Spring Framework, see example below import java.util.*; public class JavaCollection { List addressList; Set addressSet; Map addressMap; Properties addressProp; // a setter method to set List public void setAddressList(List addressList) { this.addressList = addressList; } // prints and returns all the elements of the list. public List getAddressList() { System.out.println(\"List Elements :\" + addressList); return addressList; } // a setter method to set Set public void setAddressSet(Set addressSet) { this.addressSet = addressSet; } // prints and returns all the elements of the Set. public Set getAddressSet() { System.out.println(\"Set Elements :\" + addressSet); return addressSet; } // a setter method to set Map public void setAddressMap(Map addressMap) { this.addressMap = addressMap; } // prints and returns all the elements of the Map. public Map getAddressMap() { System.out.println(\"Map Elements :\" + addressMap); return addressMap; } // a setter method to set Property public void setAddressProp(Properties addressProp) { this.addressProp = addressProp; } // prints and returns all the elements of the Property. public Properties getAddressProp() { System.out.println(\"Property Elements :\" + addressProp); return addressProp; } } import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainApp { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); JavaCollection jc=(JavaCollection)context.getBean(\"javaCollection\"); jc.getAddressList(); jc.getAddressSet(); jc.getAddressMap(); jc.getAddressProp(); } } \u003c?xml version = \"1.0\" encoding = \"UTF-8\"?\u003e \u003cbeans xmlns = \"http://www.springframework.org/schema/beans\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\u003e \u003c!-- Definition for javaCollection --\u003e \u003cbean id = \"javaCollection\" class = \"com.JavaCollection\"\u003e \u003c!-- results in a setAddressList(java.util.List) call --\u003e \u003cproperty name = \"addressList\"\u003e \u003clist\u003e \u003cvalue\u003eINDIA\u003c/value\u003e \u003cvalue\u003ePakistan\u003c/value\u003e \u003cvalue\u003eUSA\u003c/value\u003e \u003cvalue\u003eUSA\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!-- results in a setAddressSet(java.util.Set) call --\u003e \u003cproperty name = \"addressSet\"\u003e \u003cset\u003e \u003cvalue\u003eINDIA\u003c/value\u003e \u003cvalue\u003ePakistan\u003c/value\u003e \u003cvalue\u003eUSA\u003c/value\u003e \u003cvalue\u003eUSA\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003c!-- results in a setAddressMap(java.util.Map) call --\u003e \u003cproperty name = \"addressMap\"\u003e \u003cmap\u003e \u003centry key = \"1\" value = \"INDIA\"/\u003e \u003centry key = \"2\" value = \"Pakistan\"/\u003e \u003centry key = \"3\" value = \"USA\"/\u003e \u003centry key = \"4\" value = \"USA\"/\u003e \u003c/map\u003e \u003c/property\u003e \u003c!-- results in a setAddressProp(java.util.Properties) call --\u003e \u003cproperty name = \"addressProp\"\u003e \u003cprops\u003e \u003cprop key = \"one\"\u003eINDIA\u003c/prop\u003e \u003cprop key = \"one\"\u003eINDIA\u003c/prop\u003e \u003cprop key = \"two\"\u003ePakistan\u003c/prop\u003e \u003cprop key = \"three\"\u003eUSA\u003c/prop\u003e \u003cprop key = \"four\"\u003eUSA\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e ","date":"0001-01-01","objectID":"/notes/computerscience/backend/spring/spring/object_instantiation_with_iocdi/:3:0","tags":["Java"],"title":"Spring Framework Notes 3 - Object Instantiation with IOC/DI","uri":"/notes/computerscience/backend/spring/spring/object_instantiation_with_iocdi/"},{"categories":["TypeScript"],"content":"TypeScript","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_1_intro/","tags":["TypeScript"],"title":"TypeScript Notes 1 Intro","uri":"/notes/computerscience/language/typescript/typescript_notes_1_intro/"},{"categories":["TypeScript"],"content":"Introduction TypeScript is a statically-typed superset of JavaScript. TypeScript can be transferred to JavaScript. ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_1_intro/:1:0","tags":["TypeScript"],"title":"TypeScript Notes 1 Intro","uri":"/notes/computerscience/language/typescript/typescript_notes_1_intro/"},{"categories":["TypeScript"],"content":"Environmental Setup How to install TypeScript npm install -g typescript How to transfer TypeScript to JavaScript npx tsc greeter.ts npx tsc greeter.ts --out ../dist/greeter.js How to run JavaScript in shell node greeter.js How to create configuration file npx tsc --init ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_1_intro/:2:0","tags":["TypeScript"],"title":"TypeScript Notes 1 Intro","uri":"/notes/computerscience/language/typescript/typescript_notes_1_intro/"},{"categories":["TypeScript"],"content":"Configuration The presence of a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. Example tsconfig.json files: { \"compilerOptions\": { \"module\": \"commonjs\", \"noImplicitAny\": true, \"removeComments\": true, \"preserveConstEnums\": true, \"sourceMap\": true }, \"files\": [ \"core.ts\", \"sys.ts\", \"types.ts\", \"scanner.ts\", \"parser.ts\", \"utilities.ts\", \"binder.ts\", \"checker.ts\", \"emitter.ts\", \"program.ts\", \"commandLineParser.ts\", \"tsc.ts\", \"diagnosticInformationMap.generated.ts\" ] } Below is with include and exclude { \"compilerOptions\": { \"module\": \"system\", \"noImplicitAny\": true, \"removeComments\": true, \"preserveConstEnums\": true, \"outFile\": \"../../built/local/tsc.js\", \"sourceMap\": true }, \"include\": [\"src/**/*\"], \"exclude\": [\"node_modules\", \"**/*.spec.ts\"] } ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_1_intro/:3:0","tags":["TypeScript"],"title":"TypeScript Notes 1 Intro","uri":"/notes/computerscience/language/typescript/typescript_notes_1_intro/"},{"categories":["TypeScript"],"content":"Variable Normally, in TypeScript, we use let keyword, as opposed to using traditional JavaScript var keywords to avoid issue with Scoping, capturing, and shadowing etc. let \u003cvariableName\u003e: \u003ctype\u003e = \u003cinital value\u003e let found: boolean = true; let grade: number = 88.6; TypeScript is Strongly Typed that means we cannot use different type value in same variable. This will be detected in compile time. However, there are types called union and any. This type of variable can be used for multiple type. Example: Union let code: (string | number); code = 123; // OK code = \"ABC\"; // OK code = false; // Compiler Error let empId: string | number; empId = 111; // OK empId = \"E111\"; // OK empId = true; // Compiler Error Example: any let myData: any = 40.0 myData = false; myData = 'Test'; myData = 19; In TypeScript, instead of String concatenation, we can also use template string, as below example let firstName: string = \"testFirstName\"; let lastName: string = \"testLastName\"; // String concatenation console.log (\"Hi\" + firstName + \" \" + lastName) // Template Strings console.log(`Hi` ${firstName} ${lastName}); ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_1_intro/:4:0","tags":["TypeScript"],"title":"TypeScript Notes 1 Intro","uri":"/notes/computerscience/language/typescript/typescript_notes_1_intro/"},{"categories":["TypeScript"],"content":"Condition ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_1_intro/:5:0","tags":["TypeScript"],"title":"TypeScript Notes 1 Intro","uri":"/notes/computerscience/language/typescript/typescript_notes_1_intro/"},{"categories":["TypeScript"],"content":"if else let x: number = 10, y = 20; if (x \u003e y) { console.log('x is greater than y.'); } else if (x \u003c y) { console.log('x is less than y.'); //This will be executed } else if (x == y) { console.log('x is equal to y'); } ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_1_intro/:5:1","tags":["TypeScript"],"title":"TypeScript Notes 1 Intro","uri":"/notes/computerscience/language/typescript/typescript_notes_1_intro/"},{"categories":["TypeScript"],"content":"Ternary operator let x: number = 10, y = 20; x \u003e y? console.log('x is greater than y.'): console.log('x is less than or equal to y.') ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_1_intro/:5:2","tags":["TypeScript"],"title":"TypeScript Notes 1 Intro","uri":"/notes/computerscience/language/typescript/typescript_notes_1_intro/"},{"categories":["TypeScript"],"content":"Switch switch(expression) { case constant-expression1: { //statements; break; } case constant_expression2: { //statements; break; } default: { //statements; break; } } ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_1_intro/:5:3","tags":["TypeScript"],"title":"TypeScript Notes 1 Intro","uri":"/notes/computerscience/language/typescript/typescript_notes_1_intro/"},{"categories":["TypeScript"],"content":"Loop ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_1_intro/:6:0","tags":["TypeScript"],"title":"TypeScript Notes 1 Intro","uri":"/notes/computerscience/language/typescript/typescript_notes_1_intro/"},{"categories":["TypeScript"],"content":"for Loop TypeScript supports the following three for loops: for loop for (let i = 0; i \u003c 3; i++) { console.log (\"Block statement execution no.\" + i); } for..of loop let arr = [10, 20, 30, 40]; for (var val of arr) { console.log(val); // prints values: 10, 20, 30, 40 } let str = \"Hello World\"; for (var char of str) { console.log(char); // prints chars: H e l l o W o r l d } for..in loop let arr = [10, 20, 30, 40]; for (var index in arr) { console.log(index); // prints indexes: 0, 1, 2, 3 console.log(arr[index]); // prints elements: 10, 20, 30, 40 } ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_1_intro/:6:1","tags":["TypeScript"],"title":"TypeScript Notes 1 Intro","uri":"/notes/computerscience/language/typescript/typescript_notes_1_intro/"},{"categories":["TypeScript"],"content":"while Loop TypeScript supports while loop and do while loop while loop let i: number = 2; while (i \u003c 4) { console.log( \"Block statement execution no.\" + i ) i++; } do while loop let i: number = 2; do { console.log(\"Block statement execution no.\" + i ) i++; } while ( i \u003c 4) ","date":"2021-01-15","objectID":"/notes/computerscience/language/typescript/typescript_notes_1_intro/:6:2","tags":["TypeScript"],"title":"TypeScript Notes 1 Intro","uri":"/notes/computerscience/language/typescript/typescript_notes_1_intro/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Generic Classes A generic class declaration looks like a non-generic class declaration, except that the class name is followed by a type parameter section. The type parameter section of a generic class can have one or more type parameters separated by commas. These classes are known as parameterized classes or parameterized types because they accept one or more parameters. Syntax: public class Box\u003cT\u003e { private T t; } Box − Box is a generic class. T − The generic type parameter passed to generic class. It can take any Object. t − Instance of generic type T. ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:1:0","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Naming Conventions By convention, type parameter names are named as single, uppercase letters so that a type parameter can be distinguished easily with an ordinary class or interface name. Following is the list of commonly used type parameter names − E − Element (mainly used by Java Collections framework) K − Key (mainly used to represent key of a map) V − Value (mainly used to represent value of a map) N − Number (represents numbers) T − Type (represents first generic type parameter) S, U, V, etc − 2nd, 3rd, 4th Types ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:2:0","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Type Inference Type inference represents the Java compiler’s ability to look at a method invocation and its corresponding declaration to check and determine the type argument(s). The inference algorithm checks the types of the arguments and, if available, assigned type is returned. Inference algorithms tries to find a specific type which can fullfill all type parameters. Compiler generates unchecked conversion warning in-case type inference is not used. Syntax: Box\u003cInteger\u003e integerBox = new Box\u003c\u003e(); Box − Box is a generic class. − The diamond operator denotes type inference. Using diamond operator, compiler determines the type of the parameter. This operator is avalilable from Java SE 7 version onwards. ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:3:0","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Generic Methods You can write a single generic method declaration that can be called with arguments of different types. Based on the types of the arguments passed to the generic method, the compiler handles each method call appropriately. Following are the rules to define Generic Methods − All generic method declarations have a type parameter section delimited by angle brackets () that precedes the method's return type ( in the next example). Each type parameter section contains one or more type parameters separated by commas. A type parameter, also known as a type variable, is an identifier that specifies a generic type name. The type parameters can be used to declare the return type and act as placeholders for the types of the arguments passed to the generic method, which are known as actual type arguments. A generic method's body is declared like that of any other method. Note that type parameters can represent only reference types, not primitive types (like int, double and char). public static \u003cE\u003e void printArray( E[] inputArray ) { // Display array elements for(E element : inputArray) { System.out.printf(\"%s \", element); } System.out.println(); } ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:4:0","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Multiple Type Parameters A Generic class can have muliple type parameters. Following example will showcase above mentioned concept. public class Box\u003cS,T\u003e { private T t; private S s; } ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:5:0","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Parameterized Types A Generic class can have parameterized types where a type parameter can be substituted with a parameterized type. Parameterized Types are types that take other types as parameters. Eg - Collection, ArrayList, etc. public class Box\u003cS,T\u003e { ... } ... Box\u003cInteger, List\u003cString\u003e\u003e box = new Box\u003cInteger, List\u003cString\u003e\u003e(); //Parameterized Types ... ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:6:0","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Raw Types A raw type is an object of a generic class or interface if its type arguments are not passed during its creation. Box rawBox = new Box(); ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:7:0","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Bounded Type Parameters There may be times when you’ll want to restrict the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for. To declare a bounded type parameter, list the type parameter’s name, followed by the extends keyword, followed by its upper bound. Single Bound: public static \u003cT extends Comparable\u003cT\u003e\u003e T maximum(T x, T y, T z) Multiple Bounds: public static \u003cT extends Number \u0026 Comparable\u003cT\u003e\u003e T maximum(T x, T y, T z) maximum − maximum is a generic method. T − The generic type parameter passed to generic method. It can take any Object. The T is a type parameter passed to the generic class Box and should be subtype of Number class and must implments Comparable interface. In case a class is passed as bound, it should be passed first before interface otherwise compile time error will occur. Calling eg.: maximum( 6.6, 8.8, 7.7 ) ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:8:0","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Collections Framework Examples Java has provided generic support in Collections Framework Interfaces like List, Set, Map, etc. ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:9:0","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"List List\u003cT\u003e list = new ArrayList\u003cT\u003e(); list − object of List interface. T − The generic type parameter passed during List declaration. The T is a type parameter passed to the generic interface List and its implemenation class ArrayList. ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:9:1","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Set Set\u003cT\u003e set = new HashSet\u003cT\u003e(); set − object of Set Interface. T − The generic type parameter passed during Set declaration. The T is a type parameter passed to the generic interface Set and its implemenation class HashSet. ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:9:2","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Map Map\u003cT\u003e set = new HashMap\u003cT\u003e(); set − object of Map Interface. T − The generic type parameter passed during Map declaration. The T is a type parameter passed to the generic interface Map and its implemenation class HashMap. ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:9:3","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Generics Wild Cards The question mark (?), represents the wildcard, stands for unknown type in generics. ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:10:0","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Upper Bounded Wildcards There may be times when you’ll want to restrict the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. To declare a upper bounded Wildcard parameter, list the ?, followed by the extends keyword, followed by its upper bound. public static double sum(List\u003c? extends Number\u003e numberlist) { ... } ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:10:1","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Unbounded Wildcards There may be times when any object can be used when a method can be implemented using functionality provided in the Object class or When the code is independent of the type parameter. To declare a Unbounded Wildcard parameter, list the ? only. public static void printAll(List\u003c?\u003e list) { ... } ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:10:2","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Lower Bounded Wildcards There may be times when you’ll want to restrict the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Integer or its superclasses like Number. To declare a lower bounded Wildcard parameter, list the ?, followed by the super keyword, followed by its lower bound. public static void addCat(List\u003c? super Cat\u003e catList) { ... } ... //You can add list of Cat or Animal (super class of the Cat class) addCat(animalList); addCat(catList); ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:10:3","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Type Erasure Generics are used for tighter type checks at compile time and to provide a generic programming. To implement generic behaviour, java compiler apply type erasure. Type erasure is a process in which compiler replaces a generic parameter with actual class or bridge method. In type erasure, compiler ensures that no extra classes are created and there is no runtime overhead. Type Erasure rules: Replace type parameters in generic type with their bound if bounded type parameters are used. Replace type parameters in generic type with Object if unbounded type parameters are used. Insert type casts to preserve type safety. Generate bridge methods to keep polymorphism in extended generic types. ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:11:0","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Restrictions on Generics No Primitive Types - Using generics, primitive types can not be passed as type parameters. Box\u003cint\u003e intBox = new Box\u003cint\u003e() //Error NOTE: Use Wrappers like Integar instead. No Instance - A type parameter cannot be used to instantiate its object inside a method. public static \u003cT\u003e void add(Box\u003cT\u003e box) //Error NOTE: To achieve such functionality, reflection can be used. No Static field - Using generics, type parameters are not allowed to be static. As static variable is shared among object so compiler can not determine which type to used. class Box\u003cT\u003e { private static T t; //Error } No Cast - Casting to a parameterized type is not allowed unless it is parameterized by unbounded wildcards. Box\u003cInteger\u003e integerBox = new Box\u003cInteger\u003e(); Box\u003cNumber\u003e numberBox = new Box\u003cNumber\u003e(); integerBox = (Box\u003cInteger\u003e)numberBox; //Error: Cannot cast from Box\u003cNumber\u003e to Box\u003cInteger\u003e NOTE: To achive the same, unbounded wildcards can be used. No instanceOf - Because compiler uses type erasure, the runtime does not keep track of type parameters, so at runtime difference between Box and Box cannot be verified using instanceOf operator. ... integerBox instanceof Box\u003cInteger\u003e ... No Array - Arrays of parameterized types are not allowed. Because compiler uses type erasure, the type parameter is replaced with Object and user can add any type of object to the array. And at runtime, code will not able to throw ArrayStoreException. Object[] stringBoxes = new Box\u003cString\u003e[]; //Error No Exceptionn - A generic class is not allowed to extend the Throwable class directly or indirectly. //The generic class Box\u003cT\u003e may not subclass java.lang.Throwable class Box\u003cT\u003e extends Exception {} class Box1\u003cT\u003e extends Throwable {} A method is not allowed to catch an instance of a type parameter. ... catch (T e) ... No Overload - A class is not allowed to have two overloaded methods that can have the same signature after type erasure. ... public void print(List\u003cString\u003e stringList) { } // Error public void print(List\u003cInteger\u003e integerList) { } ","date":"2019-07-05","objectID":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/:12:0","tags":["Java"],"title":"Java Notes(4) Generic","uri":"/notes/computerscience/language/java/basicjava/java_notes_4_generics/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Exception Handling in Java Exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime. The exception handling in java is one of the powerful mechanism to handle the runtime errors so that normal flow of the application can be maintained. An Error “indicates serious problems that a reasonable application should not try to catch.” An Exception “indicates conditions that a reasonable application might want to catch.” ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:0:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Hierarchy of the Throwable Class : ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:1:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Types of Exceptions : 1. Checked Exception - A checked exception is an exception that occurs at the compile time, these are also called as compile time exceptions. These exceptions cannot simply be ignored at the time of compilation, the programmer should take care of (handle) these exceptions. e.g. IOException, SQLException, ClassNotFoundException, CloneNotSupported, etc. Checked exceptions are checked at compile-time. 2. Unchecked Exception - An unchecked exception is an exception that occurs at the time of execution. These are also called as Runtime Exceptions. These include programming bugs, such as logic errors or improper use of an API. e.g. ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc. Unchecked exceptions are not checked at compile-time rather they are checked at runtime. 3. Error - These are not exceptions at all, but problems that arise beyond the control of the user or the programmer. Errors are typically ignored in your code because you can rarely do anything about an error. Suppose, if a stack overflow occurs, an error will arise. e.g. OutOfMemoryError, VirtualMachineError, AssertionError etc. ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:2:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Exception Example Situations : ArithmeticException int a = 50/0; //ArithmeticException NullPointerException String s = null; System.out.println(s.length());//NullPointerException NumberFormatException String s = \"abc\"; int i = Integer.parseInt(s);//NumberFormatException ArrayIndexOutOfBoundsException int a[] = new int[5]; a[10] = 50; //ArrayIndexOutOfBoundsException ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:3:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Java Exception Handling Keywords : 1. try - Java try block is used to enclose the code that might throw an exception. It must be used within the method. Java try block must be followed by either catch or finally block. 2. catch - Java catch block is used to handle the Exception. It must be used after the try block only. You can use multiple catch block with a single try. 3. finally - Java finally block is a block that is used to execute important code such as closing connection, stream etc. Java finally block is always executed whether exception is handled or not. Java finally block follows try or catch block. 4. throw - Java throw keyword is used to explicitly throw an exception. We can throw either checked or uncheked exception in java by throw keyword. The throw keyword is mainly used to throw custom exception. 5. throws - Java throws keyword is used to declare an exception. It gives an information to the programmer that there may occur an exception so it is better for the programmer to provide the exception handling code. NOTE : Exception Handling is mainly used to handle the checked exceptions. If there occurs any unchecked exception such as NullPointerException, it is programmers fault that he is not performing check up before the code being used. ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:4:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"JVM’s Default Exception Handler The JVM firstly checks whether the exception is handled or not. If exception is not handled, JVM provides a default exception handler that performs the following tasks: Prints out exception description. Prints the stack trace (Hierarchy of methods where the exception occurred). Causes the program to terminate. But if exception is handled by the application programmer, normal flow of the application is maintained i.e. rest of the code is executed. ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:5:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Using Multiple catch blocks If the superclass method declares an exception, subclass overridden method can declare same, subclass exception or no exception but cannot declare parent exception. All catch blocks must be ordered from most specific to most general i.e. catch for ArithmeticException must come before catch for Exception. ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:6:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Using finally block If you don’t handle exception, before terminating the program, JVM executes finally block(if any). For each try block there can be zero or more catch blocks, but only one finally block. The finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort). ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:7:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Execution Propagation An exception is first thrown from the top of the stack and if it is not caught, it drops down the call stack to the previous method,If not caught there, the exception again drops down to the previous method, and so on until they are caught or until they reach the very bottom of the call stack.This is called exception propagation. By default Unchecked Exceptions are forwarded in calling chain (propagated). By default, Checked Exceptions are not forwarded in calling chain (propagated). ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:8:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Using throws keyword Only Checked exception should be declared, because Unchecked Exception are under your control (so correct your code) And Errors are beyond your control. Advantage : By using throws keyword Checked Exception can be propagated (forwarded in call stack). It provides information to the caller of the method about the exception. If you are calling a method that declares an exception, you must either caught or declare the exception. You caught the exception i.e. handle the exception using try/catch. the code will be executed fine whether exception occurs during the program or not. You declare the exception i.e. specifying throws with the method. if exception does not occur, the code will be executed fine. if exception occures, an exception will be thrown at runtime because throws does not handle the exception. You can rethrow and exception by throwing same exception in catch block. ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:9:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Java throw vs throws Keywords No.throwthrows 1)Java throw keyword is used to explicitly throw an exception.Java throws keyword is used to declare an exception. 2)Checked exception cannot be propagated using throw only.Checked exception can be propagated with throws. 3)Throw is followed by an instance.Throws is followed by class. 4)Throw is used within the method.Throws is used with the method signature. 5)You cannot throw multiple exceptions.You can declare multiple exceptions e.g. public void method()throws IOException,SQLException. ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:10:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Java final vs finally vs finalize No.finalfinallyfinalize 1)Final is used to apply restrictions on class, method and variable. Final class can't be inherited, final method can't be overridden and final variable value can't be changed.Finally is used to place important code, it will be executed whether exception is handled or not.Finalize is used to perform clean up processing just before object is garbage collected. 2)Final is a keyword.Finally is a block.Finalize is a method. ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:11:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Exception Handling with Method Overriding : If the superclass method does not declare an exception, subclass overridden method cannot declare the checked exception but it can declare unchecked exception. If the superclass method declares an exception, subclass overridden method can declare same, subclass exception or no exception but cannot declare parent exception. ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:12:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Java Custom Exception : If you are creating your own Exception that is known as custom exception or user-defined exception. Java custom exceptions are used to customize the exception according to user need. By the help of custom exception, you can have your own exception and message. ","date":"2019-07-25","objectID":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/:13:0","tags":["Java"],"title":"Java Notes(5) Error and Exception Handling","uri":"/notes/computerscience/language/java/basicjava/java_notes_5_errors_and_exception_handling/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-07-26","objectID":"/notes/computerscience/language/java/basicjava/java_notes_6_string/","tags":["Java"],"title":"Java Notes(6) String","uri":"/notes/computerscience/language/java/basicjava/java_notes_6_string/"},{"categories":["Java"],"content":"String, in general, is a sequence of characters. But in Java, string is an object that represents a sequence of character. CharSequence Interface: The CharSequence interface is used to represent the sequence of characters. The Charsequence interface is extended in three class namely String, StringBuffer, and StringBuilder classes. ","date":"2019-07-26","objectID":"/notes/computerscience/language/java/basicjava/java_notes_6_string/:0:0","tags":["Java"],"title":"Java Notes(6) String","uri":"/notes/computerscience/language/java/basicjava/java_notes_6_string/"},{"categories":["Java"],"content":"String Class By String literal String s1 = \"Welcome\"; // This doesn't create a new instance. String s2 = \"Welcome\"; In the above example, only one object will be created. Firstly, JVM will not find any string object with the value “Welcome” in string constant pool, that is why it will create a new object. After that it will find the string with the value “Welcome” in the pool, it will not create a new object but will return the reference to the same instance. This results that both s1 == s2 and s1.equal(s2) return true value. By new Keyword String s1=new String(\"Welcome\"); String s2=new String(\"Welcome\"); s1 == s2 // return false s1.equal(s2) // return true In the above example, object will be created. There is some ambiguity of whether one or two object is created. In case of only one object being created, the object is created in non-pool heap memory. In case of two objects being created, the objects are created in both non-pool heap memory and and string constant pool. //A new object is created if we modify the string s2=s2.concat(\"world\"); It will waste time and computation if we constantly modify the string. Thus, two new classes are introduced. ","date":"2019-07-26","objectID":"/notes/computerscience/language/java/basicjava/java_notes_6_string/:0:1","tags":["Java"],"title":"Java Notes(6) String","uri":"/notes/computerscience/language/java/basicjava/java_notes_6_string/"},{"categories":["Java"],"content":"StringBuffer Class String buffer is slower than StringBuilder class but it is thread safe public class Test{ public static void main(String args[]){ StringBuffer sBuffer = new StringBuffer(\"ABC\"); sBuffer.append(\"DEF\"); sBuffer.append(\"GHI\"); sBuffer.append(\"JKL\"); System.out.println(sBuffer); } } ","date":"2019-07-26","objectID":"/notes/computerscience/language/java/basicjava/java_notes_6_string/:0:2","tags":["Java"],"title":"Java Notes(6) String","uri":"/notes/computerscience/language/java/basicjava/java_notes_6_string/"},{"categories":["Java"],"content":"StringBuilder Class String builder is fast but not thread safe. public class Test{ public static void main(String args[]){ StringBuilder sBuilder=new StringBuilder(\"ABC\"); sBuffer.append(\"DEF\"); sBuffer.append(\"GHI\"); sBuffer.append(\"JKL\"); System.out.println(sBuilder); } } ","date":"2019-07-26","objectID":"/notes/computerscience/language/java/basicjava/java_notes_6_string/:0:3","tags":["Java"],"title":"Java Notes(6) String","uri":"/notes/computerscience/language/java/basicjava/java_notes_6_string/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-07-26","objectID":"/notes/computerscience/language/java/basicjava/java_notes_7_anonymouse_class/","tags":["Java"],"title":"Java Notes(7) Nested and Anonymous Class ","uri":"/notes/computerscience/language/java/basicjava/java_notes_7_anonymouse_class/"},{"categories":["Java"],"content":"Nested Class In Java, just like methods, variables of a class too can have another class as its member. Writing a class within another is allowed in Java. The class written within is called the nested class, and the class that holds the inner class is called the outer class. public class Outer { public class Inner { } } Outer.Inner inner = outer.new Inner(); Nested classes are divided into two categories: Non-static nested classes : Non-static nested classes could only existed if the outer class object existing. In general, an object of the inner class is always strongly associated with an outer class object. Static nested class : Nested classes that are declared static are called static nested classes. Static nested class object can exist, even if the outer class object is not existing. They are not strongly associated with outer classes. ","date":"2019-07-26","objectID":"/notes/computerscience/language/java/basicjava/java_notes_7_anonymouse_class/:1:0","tags":["Java"],"title":"Java Notes(7) Nested and Anonymous Class ","uri":"/notes/computerscience/language/java/basicjava/java_notes_7_anonymouse_class/"},{"categories":["Java"],"content":"Non-static Nested Classes Inner classes are a security mechanism in Java. We know a class cannot be associated with the access modifier private, but if we have the class as a member of other class, then the inner class can be made private. And this is also used to access the private members of a class. Non-static Nested Classes are of three types depending on how and where you define them. They are − Inner Class Method-local Inner Class Anonymous Inner Class Inner Class Inner class is most obvious. class Outer_Demo { int num; // inner class private class Inner_Demo { public void print() { System.out.println(\"This is an inner class\"); } } // Accessing he inner class from the method within void display_Inner() { Inner_Demo inner = new Inner_Demo(); inner.print(); } } public class My_class { public static void main(String args[]) { // Instantiating the outer class Outer_Demo outer = new Outer_Demo(); // Accessing the display_Inner() method. outer.display_Inner(); } } Method-local Inner Class A method-local inner class can be instantiated only within the method where the inner class is defined. public class Outerclass { // instance method of the outer class void my_Method() { int num = 23; // method-local inner class class MethodInner_Demo { public void print() { System.out.println(\"This is method inner class \"+num); } } // end of inner class // Accessing the inner class MethodInner_Demo inner = new MethodInner_Demo(); inner.print(); } public static void main(String args[]) { Outerclass outer = new Outerclass(); outer.my_Method(); } } Anonymous inner class Anonymous inner class is a class that we declare and instantiate it at same time. abstract class AnonymousInner { public abstract void mymethod(); } public class Outer_class { public static void main(String args[]) { AnonymousInner inner = new AnonymousInner() { public void mymethod() { System.out.println(\"This is an example of anonymous inner class\"); } }; inner.mymethod(); } } Anonymous inner class could also be passed as parameter of one method. // interface interface Message { String greet(); } public class My_class { // method which accepts the object of interface Message public void displayMessage(Message m) { System.out.println(m.greet() + \", This is an example of anonymous inner class as an argument\"); } public static void main(String args[]) { // Instantiating the class My_class obj = new My_class(); // Passing an anonymous inner class as an argument obj.displayMessage(new Message() { public String greet() { return \"Hello\"; } }); } } ","date":"2019-07-26","objectID":"/notes/computerscience/language/java/basicjava/java_notes_7_anonymouse_class/:1:1","tags":["Java"],"title":"Java Notes(7) Nested and Anonymous Class ","uri":"/notes/computerscience/language/java/basicjava/java_notes_7_anonymouse_class/"},{"categories":["Java"],"content":"Static Nested Class Live Demo public class Outer { static class Nested_Demo { public void my_method() { System.out.println(\"This is my nested class\"); } } public static void main(String args[]) { Outer.Nested_Demo nested = new Outer.Nested_Demo(); nested.my_method(); } } ","date":"2019-07-26","objectID":"/notes/computerscience/language/java/basicjava/java_notes_7_anonymouse_class/:1:2","tags":["Java"],"title":"Java Notes(7) Nested and Anonymous Class ","uri":"/notes/computerscience/language/java/basicjava/java_notes_7_anonymouse_class/"},{"categories":["Java"],"content":"Java Database","date":"2019-08-27","objectID":"/notes/computerscience/language/java/advancejava/java_jdbc/","tags":["Java","JDBC","Database"],"title":"JDBC Notes","uri":"/notes/computerscience/language/java/advancejava/java_jdbc/"},{"categories":["Java"],"content":"Common Database URL ","date":"2019-08-27","objectID":"/notes/computerscience/language/java/advancejava/java_jdbc/:1:0","tags":["Java","JDBC","Database"],"title":"JDBC Notes","uri":"/notes/computerscience/language/java/advancejava/java_jdbc/"},{"categories":["Java"],"content":"JDBC Database URL for MySQL Driver class name: com.mysql.jdbc.Driver Format of database URL: jdbc:mysql://host][,failoverhost...][:port/database[?propertyName1][=propertyValue1][\u0026propertyName2][=propertyValue2]... Examples: jdbc:mysql://localhost:3306/test jdbc:mysql://localhost:3306/test?user=root\u0026password=secret ","date":"2019-08-27","objectID":"/notes/computerscience/language/java/advancejava/java_jdbc/:1:1","tags":["Java","JDBC","Database"],"title":"JDBC Notes","uri":"/notes/computerscience/language/java/advancejava/java_jdbc/"},{"categories":["Java"],"content":"JDBC Database URL for Oracle Driver class name: oracle.jdbc.OracleDriver Format of database URL: jdbc:oracle:\u003cdrivertype\u003e:@\u003cdatabase\u003e jdbc:oracle:\u003cdrivertype\u003e:\u003cuser\u003e/\u003cpassword\u003e@\u003cdatabase\u003e Examples: jdbc:oracle:thin:@localhost:1521:testdb jdbc:oracle:thin:root/secret@localhost:1521:testdb jdbc:oracle:oci:@hoststring jdbc:oracle:oci:@localhost:1521:testdb jdbc:oracle:oci:root/secret@hoststring\u003e Jdbc:oracle:oci:root/secret@localhost:1521:testdb ","date":"2019-08-27","objectID":"/notes/computerscience/language/java/advancejava/java_jdbc/:1:2","tags":["Java","JDBC","Database"],"title":"JDBC Notes","uri":"/notes/computerscience/language/java/advancejava/java_jdbc/"},{"categories":["Java"],"content":"Driver ","date":"2019-08-27","objectID":"/notes/computerscience/language/java/advancejava/java_jdbc/:2:0","tags":["Java","JDBC","Database"],"title":"JDBC Notes","uri":"/notes/computerscience/language/java/advancejava/java_jdbc/"},{"categories":["Java"],"content":"Example of using Driver to get connection import java.sql.Driver; import org.junit.Test; public class JDBCTest{ @Test public void testDriver(){ // Create a Driver object Driver driver = new com.mysql.jdbc.Driver(); // Prepare the database information String url = \"jdbc:mysql://127.0.0.1:3306/test\"; Properties info = new Properties(); // Use connect method of Driver object Connection connection = driver.connect(url,info); System.out.println(connection); } } Issue: High coupling when creating the Driver and its properties Solution: create a properties file with all the external parametesres jdbc.properties driver = com.mysql.jdbc.Driver jdbcUrl = jdbc:mysql://127.0.0.1:3306/test user = root password = 1234 public Connection getConnection() throws Exception(){ String driverClass = null; String jdbcUrl = null; String user = null; String password = null; // Read the class path jdbc.properties to get parameters InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"jdbc.properties\"); Properties properties = new Properties(); properties.load(in); driverClass = properties.getProperty(\"driver\"); jdbcUrl = properties.getProperty(\"jdbcUrl\"); user = properties.getProperty(\"user\"); password = properties.getProperty(\"password\"); // Use reflection to create Driver Driver driver = (Driver) Class.forName(driverClass).newInstance(); Properties info = new Properties(); info.put(\"user\",user); info.put(\"password\",password); // Use the driver connection method to get connection Connection connection = driver.connect(jdbcUrl,info); return connection; } ","date":"2019-08-27","objectID":"/notes/computerscience/language/java/advancejava/java_jdbc/:2:1","tags":["Java","JDBC","Database"],"title":"JDBC Notes","uri":"/notes/computerscience/language/java/advancejava/java_jdbc/"},{"categories":["Java"],"content":"Driver Manager There are two advantages of using DriverManagers. It uses its overloadding method getConnection() to get the database connection. It can manage multiple Driver by passing different parameters. Connection getConnection(){ // Step 1: Four parameters are required parameters in Driver Manager String driverClass = null; String jdbcUrl = null; String user = null; String password = null; // Step 2: Read the class path jdbc.properties to get parameters // This should be further simplified as to read the property only once InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"jdbc.properties\"); properties.load(in); Properties properties = new Properties(); driverClass = properties.getProperty(\"driver\"); jdbcUrl = properties.getProperty(\"jdbcUrl\"); user = properties.getProperty(\"user\"); password = properties.getProperty(\"password\"); // Step 3: load driver // DriverManager.registerDriver(Class.forName(driverClass).newInstance())) // The above method is already in a static block of the Driver manager. Thus, no need to define that again Class.forName(driverClass); // Step 4: Use getConnection() method to get the connection Connection connection = DriverManager.getConnection(jdbcUrl,user,password) System.out.println(connection); return connection; } ","date":"2019-08-27","objectID":"/notes/computerscience/language/java/advancejava/java_jdbc/:3:0","tags":["Java","JDBC","Database"],"title":"JDBC Notes","uri":"/notes/computerscience/language/java/advancejava/java_jdbc/"},{"categories":["Java"],"content":"Statement To use JDBC to run a INSERT/UPDATE/DELETE requires Get Connection Create and execute Statement SQL query Close Statement and then Connection @Test public void testStatement(){ Connection conn = null; Statement statement = null; try{ // Step 1: get Database connection conn = getConnection(); // Step 2: create Statment query String sql = \"INSERT INTO customers (NAME, email, birth) VALUES ('XYZ','xyz@aa.com', '2000-02-01')\"; statement = conn.createStatement(); // Step 3: Use execute update(sql) for INSERT/UPDATE/DELETE, but not SELECT statement.executeUpdate(sql); } catch (Exception e){ e.printStackTrace(); } finally { if (statement != null){ statment.close(); } if (conn != null ){ conn.close(); } } } // The multiple try catch finally blocks are to avoid issue regards to exception raised before closing the connection We can also wrap all the above method as a utility class. ","date":"2019-08-27","objectID":"/notes/computerscience/language/java/advancejava/java_jdbc/:4:0","tags":["Java","JDBC","Database"],"title":"JDBC Notes","uri":"/notes/computerscience/language/java/advancejava/java_jdbc/"},{"categories":["Java"],"content":"ResultSet @Test public void testResultSet(){ Connection conn = null; Statement statement = null; ResultSet rs = null; try { // Step 1: get Database connection conn = getConnection(); // Step 2: create Statment query String sql = \"SELECT id, name, email, birth FROM customers\"; statement = conn.createStatement(); // Step 3: execute SQL query rs = statement.executeQuery(sql); // Step 4: Working on the ResultSet while (rs.next()){ int id = rs.getInt(1); String name = rs.getString(\"name\"); String email = rs.getString(3); Date birth = rs.getDate(4); } catch (Exception e){ e.printStackTrace(); } finally { if (rs != null ){ rs.close(); } if (statement != null){ statment.close(); } if (conn != null ){ conn.close(); } } } } ","date":"2019-08-27","objectID":"/notes/computerscience/language/java/advancejava/java_jdbc/:5:0","tags":["Java","JDBC","Database"],"title":"JDBC Notes","uri":"/notes/computerscience/language/java/advancejava/java_jdbc/"},{"categories":["Java"],"content":"PreparedStatement PreparedStatement is the child class of Statement. It prevents the SQL injection. // Get Connection ..... // Use preparedStatement String sql = \"INSERT INTO examstudent (name,email,birth) VALUES(?,?,?,?)\" PreparedStatement preparedStatement = conn.prepareStatement(sql); // set value in preparedStatement preparedStatement.setString(1,\"John\"); preparedStatement.setString(2, \"test@gmail.com\") preparedStatement.setDate(3, new Date(new java.util.Date().getTime())); // Execute preparedStatement and no need to pass sql in the executeUpdate(). preparedStatement.executeUpdate(); ","date":"2019-08-27","objectID":"/notes/computerscience/language/java/advancejava/java_jdbc/:6:0","tags":["Java","JDBC","Database"],"title":"JDBC Notes","uri":"/notes/computerscience/language/java/advancejava/java_jdbc/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"The java.io package contains nearly every class required to perform input and output (I/O) in Java. All these streams represent an input source and an output destination. The stream in the java.io package supports many data such as primitives, object, localized characters, etc. Java provides strong and flexible support for I/O related to files and networks. ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:0:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"The Hierarchy of I/O Class in Java ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:1:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"Stream A stream can be defined as a sequence of data. There are two kinds of Streams : InputStream − The InputStream is used to read data from a source. OutputStream − The OutputStream is used for writing data to a destination. ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:2:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"Byte Streams Java byte streams are used to perform input and output of 8-bit bytes. Though there are many classes related to byte streams but the most frequently used classes are, FileInputStream and FileOutputStream. ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:2:1","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"Character Streams Java Byte streams are used to perform input and output of 8-bit bytes, whereas Java Character streams are used to perform input and output for 16-bit unicode. Though there are many classes related to character streams but the most frequently used classes are, FileReader and FileWriter. Though internally FileReader uses FileInputStream and FileWriter uses FileOutputStream but here the major difference is that FileReader reads two bytes at a time and FileWriter writes two bytes at a time. ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:2:2","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"Why there are Byte and Character Streams A stream is a way of sequentially accessing a file. A byte stream access the file byte by byte. A byte stream is suitable for any kind of file, however not quite appropriate for text files. For example, if the file is using a unicode encoding and a character is represented with two bytes, the byte stream will treat these separately and you will need to do the conversion yourself. A character stream will read a file character by character. A character stream needs to be given the file’s encoding in order to work properly. ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:3:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"Standard Streams All the programming languages provide support for standard I/O where the user’s program can take input from a keyboard and then produce an output on the computer screen. Java provides the following three standard streams Standard Input − This is used to feed the data to user's program and usually a keyboard is used as standard input stream and represented as System.in. Standard Output − This is used to output the data produced by the user's program and usually a computer screen is used for standard output stream and represented as System.out. Standard Error − This is used to output the error data produced by the user's program and usually a computer screen is used for standard error stream and represented as System.err. ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:4:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"Reading and Writing Files The InputStream is used to read data from a source and the OutputStream is used for writing data to a destination. The two important streams are FileInputStream and FileOutputStream. ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:5:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"FileInputStream This stream is used for reading data from the files. Objects can be created using the keyword new and there are several types of constructors available. Following constructor takes a file name as a string to create an input stream object to read the file. InputStream f = new FileInputStream(\"C:/java/hello\"); Following constructor takes a file object to create an input stream object to read the file. First we create a file object using File() method. File f = new File(\"C:/java/hello\"); InputStream f = new FileInputStream(f); Once you have InputStream object, You can use various methods : Sr.No. Method \u0026 Description 1 public void close() throws IOException{} This method closes the file output stream. Releases any system resources associated with the file. Throws an IOException. 2 protected void finalize()throws IOException {} This method cleans up the connection to the file. Ensures that the close method of this file output stream is called when there are no more references to this stream. Throws an IOException. 3 public int read(int r)throws IOException{} This method reads the specified byte of data from the InputStream. Returns an int. Returns the next byte of data and -1 will be returned if it's the end of the file. 4 public int read(byte[] r) throws IOException{} This method reads r.length bytes from the input stream into an array. Returns the total number of bytes read. If it is the end of the file, -1 will be returned. 5 public int available() throws IOException{} Gives the number of bytes that can be read from this file input stream. Returns an int. Other important input streams : ByteArrayInputStream DataInputStream ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:6:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"FileOutputStream FileOutputStream is used to create a file and write data into it. The stream would create a file, if it doesn’t already exist, before opening it for output. Following constructor takes a file name as a string to create an input stream object to write the file OutputStream f = new FileOutputStream(\"C:/java/hello\") Following constructor takes a file object to create an output stream object to write the file. First, we create a file object using File() method. File f = new File(\"C:/java/hello\"); OutputStream f = new FileOutputStream(f); Once you have InputStream object, You can use various methods : Sr.No. Method \u0026 Description 1 public void close() throws IOException{} This method closes the file output stream. Releases any system resources associated with the file. Throws an IOException. 2 protected void finalize()throws IOException {} This method cleans up the connection to the file. Ensures that the close method of this file output stream is called when there are no more references to this stream. Throws an IOException. 3 public void write(int w)throws IOException{} This methods writes the specified byte to the output stream. 4 public void write(byte[] w) Writes w.length bytes from the mentioned byte array to the OutputStream. Other important output streams : ByteArrayOutputStream DataOutputStream ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:7:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"Complete Example The below code would create file test.txt and would write given numbers in binary format. Same would be the output on the stdout screen. import java.io.*; public class fileStreamTest { public static void main(String args[]) { try { byte bWrite [] = {11,21,3,40,5}; OutputStream os = new FileOutputStream(\"test.txt\"); for(int x = 0; x \u003c bWrite.length ; x++) { os.write( bWrite[x] ); // writes the bytes } os.close(); InputStream is = new FileInputStream(\"test.txt\"); int size = is.available(); for(int i = 0; i \u003c size; i++) { System.out.print((char)is.read() + \" \"); } is.close(); } catch (IOException e) { System.out.print(\"Exception\"); } } } ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:8:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"Java Console Class The Java Console class is be used to get input from console. It provides methods to read texts and passwords. If you read password using Console class, it will not be displayed to the user. The java.io.Console class is attached with system console internally. Example : import java.io.Console; class ReadPasswordTest{ public static void main(String args[]){ Console c=System.console(); System.out.println(\"Enter password: \"); char[] ch=c.readPassword(); String pass=String.valueOf(ch);//converting char array into string System.out.println(\"Password is: \"+pass); } } ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:9:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"File Navigation and I/O Other classes for File Navigation and I/O. File Class FileReader Class FileWriter Class ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:10:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"Directories in Java A directory is a File which can contain a list of other files and directories. You use File object to create directories, to list down files available in a directory. ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:11:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"Creating Directories The mkdir( ) method creates a directory, returning true on success and false on failure. Failure indicates that the path specified in the File object already exists, or that the directory cannot be created because the entire path does not exist yet. The mkdirs() method creates both a directory and all the parents of the directory. Below code creates “/tmp/user/java/bin” directory. import java.io.File; public class CreateDir { public static void main(String args[]) { String dirname = \"/tmp/user/java/bin\"; File d = new File(dirname); // Create directory now. d.mkdirs(); } } NOTE : Java automatically takes care of path separators on UNIX and Windows as per conventions. If you use a forward slash (/) on a Windows version of Java, the path will still resolve correctly. ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:12:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"Listing Directories You can use list( ) method provided by File object to list down all the files and directories available in a directory as follows. import java.io.File; public class ReadDir { public static void main(String[] args) { File file = null; String[] paths; try { // create new file object file = new File(\"/tmp\"); // array of files and directory paths = file.list(); // for each name in the path array for(String path:paths) { // prints filename and directory name System.out.println(path); } } catch (Exception e) { // if any error occurs e.printStackTrace(); } } } ","date":"2019-07-27","objectID":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/:13:0","tags":["Java"],"title":"Java Notes(8) File I/O","uri":"/notes/computerscience/language/java/basicjava/java_notes_8_file_io/"},{"categories":["Java"],"content":"Software Management Tool","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"Core Concepts of Maven: POM Files: Project Object Model(POM) Files are XML file that contains information related to the project and configuration information such as dependencies, source directory, plugin, goals etc. used by Maven to build the project. When you should execute a maven command you give maven a POM file to execute the commands. Maven reads pom.xml file to accomplish its configuration and operations. Dependencies and Repositories: Dependencies are external Java libraries required for Project and repositories are directories of packaged JAR files. The local repository is just a directory on your machine hard drive. If the dependencies are not found in the local Maven repository, Maven downloads them from a central Maven repository and puts them in your local repository. Build Life Cycles, Phases and Goals: A build life cycle consists of a sequence of build phases, and each build phase consists of a sequence of goals. Maven command is the name of a build lifecycle, phase or goal. If a lifecycle is requested executed by giving maven command, all build phases in that life cycle are executed also. If a build phase is requested executed, all build phases before it in the defined sequence are executed too. Build Profiles: Build profiles a set of configuration values which allows you to build your project using different configurations. For example, you may need to build your project for your local computer, for development and test. To enable different builds you can add different build profiles to your POM files using its profiles elements and are triggered in the variety of ways. Build Plugins: Build plugins are used to perform specific goal. you can add a plugin to the POM file. Maven has some standard plugins you can use, and you can also implement your own in Java. ","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/:1:0","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"Pom File POM means Project Object Model is key to operate Maven. Maven reads pom.xml file to accomplish its configuration and operations. It is an XML file that contains information related to the project and configuration information such as dependencies, source directory, plugin, goals etc. used by Maven to build the project. \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003e com.project.loggerapi \u003c/groupId\u003e \u003cartifactId\u003eLoggerApi\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c!-- Add typical dependencies for a web application --\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-api\u003c/artifactId\u003e \u003cversion\u003e2.11.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e Elements used for Creating pom.xml file project - It is the root element of the pom.xml file. modelVersion - modelversion means what version of the POM model you are using. Use version 4.0.0 for maven 2 and maven 3. groupId - groupId means the id for the project group. It is unique and Most often you will use a group ID which is similar to the root Java package name of the project like we used the groupId com.project.loggerapi. artifactId - artifactId used to give name of the project you are building.in our example name of our project is LoggerApi. version - version element contains the version number of the project. If your project has been released in different versions then it is useful to give version of your project. Other Elements of Pom.xml file dependencies - dependencies element is used to defines a list of dependency of project. dependency - dependency defines a dependency and used inside dependencies tag. Each dependency is described by its groupId, artifactId and version. name - this element is used to give name to our maven project. scope - this element used to define scope for this maven project that can be compile, runtime, test, provided system etc. packaging - packaging element is used to packaging our project to output types like JAR, WAR etc. ","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/:2:0","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"Dependency Scopes ","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/:3:0","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"Compile This is the default scope when no other scope is provided. Dependencies with this scope are available on the classpath of the project in all build tasks and they’re propagated to the dependent projects. More importantly, these dependencies are also transitive: \u003cdependency\u003e \u003cgroupId\u003ecommons-lang\u003c/groupId\u003e \u003cartifactId\u003ecommons-lang\u003c/artifactId\u003e \u003cversion\u003e2.6\u003c/version\u003e \u003c/dependency\u003e ","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/:3:1","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"Provided This scope is used to mark dependencies that should be provided at runtime by JDK or a container, hence the name. A good use case for this scope would be a web application deployed in some container, where the container already provides some libraries itself. For example, a web server that already provides the Servlet API at runtime, thus in our project, those dependencies can be defined with the provided scope: \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003eservlet-api\u003c/artifactId\u003e \u003cversion\u003e2.5\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e The provided dependencies are available only at compile-time and in the test classpath of the project; what’s more, they aren’t transitive. ","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/:3:2","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"Runtime The dependencies with this scope are required at runtime, but they’re not needed for compilation of the project code. Because of that, dependencies marked with the runtime scope will be present in runtime and test classpath, but they will be missing from compile classpath. A good example of dependencies that should use the runtime scope is a JDBC driver: \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e6.0.6\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e ","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/:3:3","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"Test This scope is used to indicate that dependency isn’t required at standard runtime of the application, but is used only for test purposes. Test dependencies aren’t transitive and are only present for test and execution classpaths. The standard use case for this scope is adding test library like JUnit to our application: \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e ","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/:3:4","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"System System scope is much similar to the provided scope. The main difference between those two scopes is that system requires us to directly point to specific jar on the system. The important thing to remember is that building the project with system scope dependencies may fail on different machines if dependencies aren’t present or are located in a different place than the one systemPath points to: \u003cdependency\u003e \u003cgroupId\u003ecom.baeldung\u003c/groupId\u003e \u003cartifactId\u003ecustom-dependency\u003c/artifactId\u003e \u003cversion\u003e1.3.2\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/libs/custom-dependency-1.3.2.jar\u003c/systemPath\u003e \u003c/dependency\u003e ","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/:3:5","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"Import This scope was added in Maven 2.0.9 and it’s only available for the dependency type pom. We’re going to speak more about the type of the dependency in future articles. Import indicates that this dependency should be replaced with all effective dependencies declared in it’s POM: \u003cdependency\u003e \u003cgroupId\u003ecom.baeldung\u003c/groupId\u003e \u003cartifactId\u003ecustom-project\u003c/artifactId\u003e \u003cversion\u003e1.3.2\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e ","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/:3:6","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"Dependency and Transitivity Maven avoids the need to discover and specify the libraries that your own dependencies require by including transitive dependencies automatically. Dependency management - this allows project authors to directly specify the versions of artifacts to be used when they are encountered in transitive dependencies or in dependencies where no version has been specified. Dependency mediation - this determines what version of an artifact will be chosen when multiple versions are encountered as dependencies. Maven picks the “nearest definition”. If the path are same in length, then it will depends on which version comes first. A better approach is to specify the version in property file lik below. ","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/:4:0","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"Scope and Transitivity Each dependency scope affects transitive dependencies in its own way. This means that different transitive dependencies may end up in the project with different scopes. However, dependencies with scopes provided and test will never be included in the main project. Then: For the compile scope, all dependencies with runtime scope will be pulled in with the runtime scope, in the project and all dependencies with the compile scope will be pulled in with the compile scope, in the project For the provided scope, both runtime and compile scope dependencies will be pulled in with the provided scope, in the project For the test scope, both runtime and compile scope transitive dependencies will be pulled in with the test scope, in the project For the runtime scope, both runtime and compile scope transitive dependencies will be pulled in with the runtime scope, in the project ","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/:5:0","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"Maven Repositories Maven repositories are directories of packaged JAR files with some metadata. The metadata are POM files related to the projects each packaged JAR file belongs to, including what external dependencies each packaged JAR has. This metadata enables Maven to download dependencies of your dependencies recursively until all dependencies are download and put into your local machine. Maven has three types of repository : Local repository - A local repository is a directory on the machine of developer. This repository contains all the dependencies Maven downloads. Maven only needs to download the dependencies once, even if multiple projects depends on them (e.g. ODBC). By default, maven local repository is user_home/m2 directory. example – C:\\Users\\asingh.m2 Central repository - The central Maven repository is created Maven community. Maven looks in this central repository for any dependencies needed but not found in your local repository. Maven then downloads these dependencies into your local repository. You can view central repository by this link. Remote repository - remote repository is a repository on a web server from which Maven can download dependencies.it often used for hosting projects internal to organization. Maven then downloads these dependencies into your local repository. Maven searches for dependencies in this repositories. First maven searches in Local repository then Central repository then Remote repository if Remote repository specified in the POM. Reference: https://www.geeksforgeeks.org/introduction-apache-maven-build-automation-tool-java-projects/#:~:text=Maven%20is%20a%20powerful%20project,the%20build%20process%20like%20ANT.\u0026text=In%20short%20terms%20we%20can,managing%20any%20Java%2Dbased%20project. ","date":"2019-08-24","objectID":"/notes/computerscience/language/java/advancejava/java_maven/:6:0","tags":["Java"],"title":"Maven","uri":"/notes/computerscience/language/java/advancejava/java_maven/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-07-30","objectID":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/","tags":["Java"],"title":"Java Notes(9) Serialization","uri":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/"},{"categories":["Java"],"content":"Serialization in java is a mechanism of writing the state of an object into a byte stream. It is mainly used in Hibernate, RMI, JPA, EJB and JMS technologies. The reverse operation of serialization is called deserialization. Advantage of Java Serialization : It is mainly used to travel object’s state on the network (known as marshaling). java.io.Serializable interface : Serializable is a marker interface (has no data member and method). It is used to “mark” java classes so that objects of these classes may get certain capability. The Cloneable and Remote are also marker interfaces. It must be implemented by the class whose object you want to persist. The String class and all the wrapper classes implements java.io.Serializable interface by default. ","date":"2019-07-30","objectID":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/:0:0","tags":["Java"],"title":"Java Notes(9) Serialization","uri":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/"},{"categories":["Java"],"content":"ObjectOutputStream class The ObjectOutputStream class is used to write primitive data types and Java objects to an OutputStream. Only objects that support the java.io.Serializable interface can be written to streams. Constructor : public ObjectOutputStream(OutputStream out) throws IOException {} Above constructor creates an ObjectOutputStream that writes to the specified OutputStream. Important Methods : MethodDescription 1) public final void writeObject(Object obj) throws IOException {}writes the specified object to the ObjectOutputStream. 2) public void flush() throws IOException {}flushes the current output stream. 3) public void close() throws IOException {}closes the current output stream. ","date":"2019-07-30","objectID":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/:1:0","tags":["Java"],"title":"Java Notes(9) Serialization","uri":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/"},{"categories":["Java"],"content":"Example of Java Serialization Example to serialize the object of Student class. import java.io.*; class Persist{ public static void main(String args[])throws Exception{ Student s1 =new Student(211,\"John\"); FileOutputStream fout=new FileOutputStream(\"f.txt\"); ObjectOutputStream out=new ObjectOutputStream(fout); out.writeObject(s1); out.flush(); System.out.println(\"success\"); } } ","date":"2019-07-30","objectID":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/:2:0","tags":["Java"],"title":"Java Notes(9) Serialization","uri":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/"},{"categories":["Java"],"content":"Deserialization in java Deserialization is the process of reconstructing the object from the serialized state.It is the reverse operation of serialization. ","date":"2019-07-30","objectID":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/:3:0","tags":["Java"],"title":"Java Notes(9) Serialization","uri":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/"},{"categories":["Java"],"content":"ObjectInputStream class An ObjectInputStream deserializes objects and primitive data written using an ObjectOutputStream. Constructor : public ObjectInputStream(InputStream in) throws IOException {} Above constructor creates an ObjectInputStream that reads from the specified InputStream. Important Methods : MethodDescription 1) public final Object readObject() throws IOException, ClassNotFoundException{}reads an object from the input stream. 2) public void close() throws IOException {}closes ObjectInputStream. ","date":"2019-07-30","objectID":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/:4:0","tags":["Java"],"title":"Java Notes(9) Serialization","uri":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/"},{"categories":["Java"],"content":"Example of Java Deserialization Example to deserialize the object of Student class. import java.io.*; class Depersist{ public static void main(String args[])throws Exception{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(\"f.txt\")); Student s=(Student)in.readObject(); System.out.println(s.id+\" \"+s.name); in.close(); } } ","date":"2019-07-30","objectID":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/:5:0","tags":["Java"],"title":"Java Notes(9) Serialization","uri":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/"},{"categories":["Java"],"content":"Serialization Rules Serialization with Inheritance (IS-A Relationship) : If a class implements serializable then all its sub classes will also be serializable. Parent class properties are inherited to subclasses so if parent class is Serializable, subclass would also be. Serialization with Aggregation (HAS-A Relationship) : If a class has a reference of another class, all the references must be Serializable otherwise serialization process will not be performed. In such case, NotSerializableException is thrown at runtime. All the objects within an object must be Serializable. Serialization with static data member : If there is any static data member in a class, it will not be serialized because static is the part of class not object. Serialization with array or collection : In case of array or collection, all the objects of array or collection must be serializable. If any object is not serialiizable, serialization will be failed. ","date":"2019-07-30","objectID":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/:6:0","tags":["Java"],"title":"Java Notes(9) Serialization","uri":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/"},{"categories":["Java"],"content":"Externalizable in Java The Externalizable interface provides the facility of writing the state of an object into a byte stream in compress format. It is not a marker interface. The Externalizable interface provides two methods: public void writeExternal(ObjectOutput out) throws IOException public void readExternal(ObjectInput in) throws IOException ","date":"2019-07-30","objectID":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/:7:0","tags":["Java"],"title":"Java Notes(9) Serialization","uri":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/"},{"categories":["Java"],"content":"Java Transient Keyword If you don’t want to serialize any data member of a class, you can mark it as transient. Example : transient int age; //It will not be serialized ","date":"2019-07-30","objectID":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/:8:0","tags":["Java"],"title":"Java Notes(9) Serialization","uri":"/notes/computerscience/language/java/basicjava/java_notes_9_serialization/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Multithreading in java is a process of executing multiple threads simultaneously. Thread is basically a lightweight sub-process, a smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking. But we use multithreading than multiprocessing because threads share a common memory area. They don’t allocate separate memory area so saves memory, and context-switching between the threads takes less time than process. Thread is executed inside the process. There is context-switching between the threads. There can be multiple processes inside the OS and one process can have multiple threads. Advantages of Multithreading : It doesn’t block the user because threads are independent and you can perform multiple operations at same time. You can perform many operations simultaneously so it saves time. Threads are independent so it doesn’t affect other threads if exception occur in a single thread. ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:0:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Multitasking Multitasking is a process of executing multiple tasks simultaneously. We use multitasking to utilize the CPU. Multitasking can be achieved by two ways: Process-based Multitasking(Multiprocessing) Thread-based Multitasking(Multithreading) Multiprocessing Multithreading Each process have its own address in memory i.e. each process allocates separate memory area. Threads share the same address space. Process is heavyweight. Thread is lightweight. Cost of communication between the process is high. Cost of communication between the thread is low. Context-switching require some time for saving \u0026 loading registers, memory maps, updating lists etc. Context-switching between the threads takes less time than process. NOTE : Context switching (aka process/task switching) is the switching of the CPU (central processing unit) from one process or thread to another. ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:1:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Life Cycle of a Thread The life cycle of the thread in java is controlled by JVM. The java thread states are as follows: New - The thread is in new state if you create an instance of Thread class but before the invocation of start() method. Runnable - The thread is in runnable state after invocation of start() method, but the thread scheduler has not selected it to be the running thread. Running - The thread is in running state if the thread scheduler has selected it. Non-Runnable (Blocked) - This is the state when the thread is still alive, but is currently not eligible to run. Terminated - A thread is in terminated or dead state when its run() method exits. NOTE : According to sun, there is only 4 states in thread life cycle in java new, runnable, non-runnable and terminated. There is no running state. ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:2:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Creating a Thread There are two ways to create a thread: By extending Thread class By implementing Runnable interface. Thread class: Thread class provide constructors and methods to create and perform operations on a thread.Thread class extends Object class and implements Runnable interface. Commonly used Constructors of Thread class: Thread() Thread(String name) Thread(Runnable r) Thread(Runnable r,String name) Commonly used methods of Thread class: public void run(): is used to perform action for a thread. public void start(): starts the execution of the thread.JVM calls the run() method on the thread. public void sleep(long miliseconds): Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds. public void join(): waits for a thread to die. public void join(long miliseconds): waits for a thread to die for the specified miliseconds. public int getPriority(): returns the priority of the thread. public int setPriority(int priority): changes the priority of the thread. public String getName(): returns the name of the thread. public void setName(String name): changes the name of the thread. public Thread currentThread(): returns the reference of currently executing thread. public int getId(): returns the id of the thread. public Thread.State getState(): returns the state of the thread. public boolean isAlive(): tests if the thread is alive. public void yield(): causes the currently executing thread object to temporarily pause and allow other threads to execute. public void suspend(): is used to suspend the thread(depricated). public void resume(): is used to resume the suspended thread(depricated). public void stop(): is used to stop the thread(depricated). public boolean isDaemon(): tests if the thread is a daemon thread. public void setDaemon(boolean b): marks the thread as daemon or user thread. public void interrupt(): interrupts the thread. public boolean isInterrupted(): tests if the thread has been interrupted. public static boolean interrupted(): tests if the current thread has been interrupted. Runnable interface: The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. Runnable interface have only one method named run(). public void run(): is used to perform action for a thread. Starting a thread: start() method of Thread class is used to start a newly created thread. It performs following tasks: A new thread starts(with new callstack). The thread moves from New state to the Runnable state. When the thread gets a chance to execute, its target run() method will run. ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:3:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Creating Thread Codes : Thread Example by extending Thread class class Multi extends Thread{ public void run(){ System.out.println(\"thread is running...\"); } public static void main(String args[]){ Multi t1=new Multi(); t1.start(); } } Thread Example by implementing Runnable interface class Multi3 implements Runnable{ public void run(){ System.out.println(\"thread is running...\"); } public static void main(String args[]){ Multi3 m1=new Multi3(); Thread t1 =new Thread(m1); t1.start(); } } ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:4:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Thread Scheduler in Java Thread scheduler in java is the part of the JVM that decides which thread should run. There is no guarantee that which runnable thread will be chosen to run by the thread scheduler. Only one thread at a time can run in a single process. The thread scheduler mainly uses preemptive or time slicing scheduling to schedule the threads. Difference between preemptive scheduling and time slicing Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors. NOTE : We cannot start a thread twice. After starting a thread, it can never be started again. If you does so, an IllegalThreadStateException is thrown the moment it is started for the second time. ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:5:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"sleep() method in Java The sleep() method of Thread class is used to sleep a thread for the specified amount of time. The Thread class provides two methods for sleep : public static void sleep(long miliseconds)throws InterruptedException public static void sleep(long miliseconds, int nanos)throws InterruptedException Thread.sleep(500) At a time only one thread is executed. If you sleep a thread for the specified time,the thread shedular picks up another thread and so on. ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:6:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"run() method in Java In Java, Each thread starts in a separate call stack. Invoking the run() method from main thread, the run() method goes onto the current call stack rather than at the beginning of a new call stack. Problem if you use run() directly instead of start() “ There is no context-switching in the below program because here t1 and t2 will be treated as normal object not thread object. Output will be : 1 2 3 4 5 1 2 3 4 5 (One object will finish before starting next) class TestCallRun extends Thread{ public void run(){ for(int i=1;i\u003c5;i++){ try{Thread.sleep(500);}catch(InterruptedException e){System.out.println(e);} System.out.println(i); } } public static void main(String args[]){ TestCallRun2 t1=new TestCallRun2(); TestCallRun2 t2=new TestCallRun2(); t1.run(); t2.run(); } } } } ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:7:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"join() method in Java Java Thread join() method can be used to pause the current thread execution, until the specified thread is dead. There are three join methods : public void join() public void join(long millis) public void join(long millis, int nanos) Examples : t1.join(); \\\\Current thread will be paused, until t1 is dead. (t1 will start executing) t1.join(1500); \\\\Current thread will be paused, t1 will execute for 1500 milliseconds. ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:8:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Naming Thread The Thread class provides methods to change and get the name of a thread. By default, each thread has a name i.e. thread-0, thread-1 and so on. But, we can change the name of the thread by using setName() method. public String getName(): is used to get the name of a thread. t1.getName() public void setName(String name): is used to change the name of a thread. t1.setName(\"My sweet thread\"); Getting the Current Thread public static Thread currentThread(): The currentThread() method returns a reference of currently executing thread. public void run(){ System.out.println(Thread.currentThread().getName()); } ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:9:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Priority of a Thread Each thread have a priority. Priorities are represented by a number between 1 and 10. In most cases, thread schedular schedules the threads according to their priority (known as preemptive scheduling). But it is not guaranteed because it depends on JVM specification that which scheduling it chooses. The 3 constants defined in Thread class: public static int MIN_PRIORITY public static int NORM_PRIORITY public static int MAX_PRIORITY Default priority of a thread is 5 (NORM_PRIORITY). The value of MIN_PRIORITY is 1 and the value of MAX_PRIORITY is 10. System.out.println(\"thread priority is:\"+t1.getPriority()); t1.setPriority(Thread.MIN_PRIORITY); ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:10:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Daemon Thread Daemon thread in java is a service provider thread that provides services to the user thread. It has no role in life than to serve user threads. Its life depends on user threads i.e. when all the user threads dies, JVM terminates this thread automatically. It is a low priority thread. There are many java daemon threads running automatically e.g. gc, finalizer etc. NOTE : You can see all the detail by typing the jconsole in the command prompt. The jconsole tool provides information about the loaded classes, memory usage, running threads etc. Methods for Daemon Thread: public void setDaemon(boolean status): is used to mark the current thread as daemon thread or user thread. t1.setDaemon(true); //Now, t1 is a daemon thread t1.start() public boolean isDaemon(): is used to check that current is daemon. if(t1.isDaemon()) { ... } If you want to make a user thread as Daemon, it must not be started otherwise it will throw IllegalThreadStateException. t1.start(); t1.setDaemon(true); //will Throw Exception Here ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:11:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Java Thread Pool Java Thread pool represents a group of worker threads that are waiting for the job and reuse many times. In case of thread pool, a group of fixed size threads are created. A thread from the thread pool is pulled out and assigned a job by the service provider. After completion of the job, thread is contained in the thread pool again. Advantage of Java Thread Pool is Better performance. It saves time because there is no need to create new thread. Real time usage: It is used in Servlet and JSP where container creates a thread pool to process the request. Example Syntax: ExecutorService executor = Executors.newFixedThreadPool(5); //creating a pool of 5 threads Runnable worker = new ... executor.execute(worker); //calling execute method of ExecutorService ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:12:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"ThreadGroup Class in Java Java provides a convenient way to group multiple threads in a single object. In such way, we can suspend, resume or interrupt group of threads by a single method call. Java thread group is implemented by java.lang.ThreadGroup class. NOTE : Now suspend(), resume() and stop() methods are deprecated. Constructors of ThreadGroup class : No.ConstructorDescription 1)ThreadGroup(String name)creates a thread group with given name. 2)ThreadGroup(ThreadGroup parent, String name)creates a thread group with given parent group and name. Important methods of ThreadGroup class : No.MethodDescription 1)int activeCount()returns no. of threads running in current group. 2)int activeGroupCount()returns a no. of active group in this thread group. 3)void destroy()destroys this thread group and all its sub groups. 4)String getName()returns the name of this group. 5)ThreadGroup getParent()returns the parent of this group. 6)void interrupt()interrupts all threads of this group. 7)void list()prints information of this group to standard console. Creating group of threads : ThreadGroup tg1 = new ThreadGroup(\"Group A\"); Thread t1 = new Thread(tg1,new MyRunnable(),\"one\"); Thread t2 = new Thread(tg1,new MyRunnable(),\"two\"); Thread t3 = new Thread(tg1,new MyRunnable(),\"three\"); Now all 3 threads belong to one group. Here, tg1 is the thread group name, MyRunnable is the class that implements Runnable interface and “one”, “two” and “three” are the thread names. Now we can interrupt all threads by a single line of code only. Thread.currentThread().getThreadGroup().interrupt(); ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:13:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Java Shutdown Hook The shutdown hook can be used to perform cleanup resource or save the state when JVM shuts down normally or abruptly. Performing clean resource means closing log file, sending some alerts or something else. So if you want to execute some code before JVM shuts down, use shutdown hook. The JVM shuts down when: user presses ctrl+c on the command prompt, System.exit(int) method is invoked, user logoff, shutdown, etc. The addShutdownHook() method of Runtime class is used to register the thread with the Virtual Machine. public void addShutdownHook(Thread hook){} The object of Runtime class can be obtained by calling the static factory method getRuntime() Runtime r = Runtime.getRuntime(); Factory method: The method that returns the instance of a class is known as factory method. NOTE: The shutdown sequence can be stopped by invoking the halt(int) method of Runtime class. ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:14:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Multitask Each thread run in a separate callstack. class TestMultitasking1 extends Thread{ public void run(){ System.out.println(\"task one\"); } public static void main(String args[]){ TestMultitasking1 t1=new TestMultitasking1(); TestMultitasking1 t2=new TestMultitasking1(); t1.start(); t2.start(); } } ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:15:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Java Garbage Collection In Java, garbage means unreferenced objects. Garbage Collection is process of reclaiming the runtime unused memory automatically. In other words, it is a way to destroy the unused objects. To do so, we were using free() function in C language and delete() in C++. But, in java it is performed automatically. So, java provides better memory management. Advantage of Garbage Collection: It makes java memory efficient because garbage collector removes the unreferenced objects from heap memory. It is automatically done by the garbage collector(a part of JVM) so we don’t need to make extra efforts. How an object is unreferenced: By nulling the reference Employee e=new Employee(); e=null; By assigning a reference to another Employee e1=new Employee(); Employee e2=new Employee(); e1=e2; //now, the first object referred by e1 is available for garbage collection By annonymous object new Employee(); etc. finalize() method The finalize() method is invoked each time before the object is garbage collected. This method can be used to perform cleanup processing. This method is defined in Object class as: protected void finalize(){} NOTE : The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing (destroying remaining objects). gc() method The gc() method is used to invoke the garbage collector to perform cleanup processing. The gc() is found in System and Runtime classes. This method is defined in System class as: public static void gc(){} System.gc(); // explicitely invoking the garbage collector NOTE : Garbage collection is performed by a daemon thread called Garbage Collector(GC). This thread calls the finalize() method before object is garbage collected. NOTE : Neither finalization nor garbage collection is guaranteed. ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:16:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Java Runtime Class Java Runtime class is used to interact with java runtime environment. Java Runtime class provides methods to execute a process, invoke GC, get total and free memory etc. There is only one instance of java.lang.Runtime class is available for one java application. The Runtime.getRuntime() method returns the singleton instance of Runtime class. Important methods of Java Runtime class : No.MethodDescription 1)public static Runtime getRuntime()returns the instance of Runtime class. 2)public void exit(int status)terminates the current virtual machine. 3)public void addShutdownHook(Thread hook)registers new hook thread. 4)public Process exec(String command)throws IOExceptionexecutes given command in a separate process. 5)public int availableProcessors()returns no. of available processors. 6)public long freeMemory()returns amount of free memory in JVM. 7)public long totalMemory()returns amount of total memory in JVM. ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:17:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Java Runtime exec() method public class Runtime1{ public static void main(String args[])throws Exception{ Runtime.getRuntime().exec(\"notepad\"); // Will open a new notepad } } Shutdown system in Java : Runtime.getRuntime().exec(\"shutdown -s -t 0\"); // Shutdown You can use shutdown -s command to shutdown system. For windows OS, you need to provide full path of shutdown command e.g. c:\\Windows\\System32\\shutdown. Here you can use -s switch to shutdown system, -r switch to restart system and -t switch to specify time delay. Runtime.getRuntime().exec(\"c:\\\\Windows\\\\System32\\\\shutdown -s -t 0\"); // Windows Shutdown Runtime.getRuntime().exec(\"shutdown -r -t 0\"); // Restart Runtime availableProcessors() method : System.out.println(Runtime.getRuntime().availableProcessors()); Runtime freeMemory() and totalMemory() method : System.out.println(\"Total Memory: \"+Runtime.totalMemory()); System.out.println(\"Free Memory: \"+Runtime.freeMemory()); ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/:18:0","tags":["Java"],"title":"Java Notes(10) Multithreading","uri":"/notes/computerscience/language/java/basicjava/java_notes_10_multithreading/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Synchronization in java is the capability to control the access of multiple threads to any shared resource. Java Synchronization is better option where we want to allow only one thread to access the shared resource. The synchronization is mainly used to : To prevent Thread Interference (Thread interference is a condition which occurs when more than one threads, executing simultaneously, access same piece of data.). To prevent Consistency Problem (Memory consistency errors occur when different threads have inconsistent views of what should be the same data.). ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:0:0","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Types of Synchronization : ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:1:0","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Thread Synchronization There are two types of thread synchronization mutual exclusive and inter-thread communication. Mutual Exclusive Cooperation (Inter-thread communication in java) Mutual Exclusive : Mutual Exclusive helps keep threads from interfering with one another while sharing data. This can be done by three ways in java : by synchronized method by synchronized block by static synchronization Concept of Lock in Java : Synchronization is built around an internal entity known as the lock or monitor. Every object has an lock associated with it. By convention, a thread that needs consistent access to an object’s fields has to acquire the object’s lock before accessing them, and then release the lock when it’s done with them. The package java.util.concurrent.locks contains several lock implementations. ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:2:0","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Synchronized Method in Java :** If you declare any method as synchronized, it is known as synchronized method. Synchronized method is used to lock an object for any shared resource. When a thread invokes a synchronized method, it automatically acquires the lock for that object and releases it when the thread completes its task. synchronized void printTable(int n){ //synchronized method for(int i=1;i\u003c=5;i++){ System.out.println(n*i); try{ Thread.sleep(200); }catch(Exception e){System.out.println(e);} } } ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:3:0","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Synchronized Block in Java Synchronized block can be used to perform synchronization on any specific resource of the method. Suppose you have 50 lines of code in your method, but you want to synchronize only 5 lines, you can use synchronized block. Scope of synchronized block is smaller than the method. If you put all the codes of the method in the synchronized block, it will work same as the synchronized method. Syntax - synchronized (object reference expression) { … } void printTable(int n){ synchronized(this){ //synchronized block for(int i=1;i\u003c=5;i++){ System.out.println(n*i); try{ Thread.sleep(200); }catch(Exception e){System.out.println(e);} } } } ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:4:0","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Static Synchronization in Java If you make any static method as synchronized, the lock will be on the class not on object. Problem without static synchronization : Suppose there are two objects of a shared class(e.g. Table) named object1 and object2.In case of synchronized method and synchronized block there cannot be interference between t1 and t2 or t3 and t4 because t1 and t2 both refers to a common object that have a single lock.But there can be interference between t1 and t3 or t2 and t4 because t1 acquires another lock and t3 acquires another lock.I want no interference between t1 and t3 or t2 and t4.Static synchronization solves this problem. synchronized static void printTable(int n){ for(int i=1;i\u003c=10;i++){ System.out.println(n*i); try{ Thread.sleep(200); }catch(Exception e){System.out.println(e);} } } ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:5:0","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Deadlock in Java Deadlock can occur in a situation when a thread is waiting for an object lock, that is acquired by another thread and second thread is waiting for an object lock that is acquired by first thread. Since, both threads are waiting for each other to release the lock, the condition is called deadlock. public class TestDeadlockExample1 { public static void main(String[] args) { final String resource1 = \"John\"; final String resource2 = \"Tom\"; // t1 tries to lock resource1 then resource2 Thread t1 = new Thread() { public void run() { synchronized (resource1) { System.out.println(\"Thread 1: locked resource 1\"); try { Thread.sleep(100);} catch (Exception e) {} synchronized (resource2) { System.out.println(\"Thread 1: locked resource 2\"); } } } }; // t2 tries to lock resource2 then resource1 Thread t2 = new Thread() { public void run() { synchronized (resource2) { System.out.println(\"Thread 2: locked resource 2\"); try { Thread.sleep(100);} catch (Exception e) {} synchronized (resource1) { System.out.println(\"Thread 2: locked resource 1\"); } } } }; t1.start(); t2.start(); } } Output: Thread 1: locked resource 1 Thread 2: locked resource 2 ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:6:0","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Inter-Thread Communication in Java Inter-thread communication or Co-operation is all about allowing synchronized threads to communicate with each other. Cooperation (Inter-thread communication) is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed. It is implemented by following 3 methods of Object class: wait() notify() notifyAll() ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:7:0","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"wait() Method Causes current thread to release the lock and wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed. The current thread must own this object’s monitor, so it must be called from the synchronized method only otherwise it will throw exception. public final void wait()throws InterruptedException public final void wait(long timeout)throws InterruptedException ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:7:1","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"notify() Method Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. public final void notify() ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:7:2","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"notifyAll() Method Wakes up all threads that are waiting on this object’s monitor. public final void notifyAll() ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:7:3","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Understanding the process of inter-thread communication Explanation of the above diagram : Threads enter to acquire lock. Lock is acquired by one thread. Now thread goes to waiting state if you call wait() method on the object. Otherwise, it releases the lock \u0026 exits when done. If you call notify() or notifyAll() method, thread moves to the notified state (runnable state). Now thread is available to acquire lock. After completion of the task, thread releases the lock and exits the monitor state of the object. NOTE : wait(), notify() and notifyAll() methods are defined in Object class not Thread class because they are related to lock and object has a lock. ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:8:0","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Difference between wait and sleep wait()sleep() wait() method releases the locksleep() method doesn't release the lock. is a method of Object classis a method of Thread class is a non-static methodis a static method should be notified by notify() or notifyAll() methodsafter the specified amount of time, sleep is completed. Sinple Example : class Customer { int amount = 10000; synchronized void withdraw(int amount) { System.out.println(\"going to withdraw...\"); if (this.amount \u003c amount) { System.out.println(\"Less balance; waiting for deposit...\"); try { wait(); } catch (Exception e) {} } // Simple Eg. So, doesn't consider if amount is again low after notify() this.amount -= amount; System.out.println(\"withdraw completed...\"); } synchronized void deposit(int amount) { System.out.println(\"going to deposit...\"); this.amount += amount; System.out.println(\"deposit completed... \"); notify(); } } class Test { public static void main(String args[]) { final Customer c = new Customer(); new Thread() { public void run() { c.withdraw(15000); }}.start(); new Thread() { public void run() { c.deposit(10000); }}.start(); } } ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:9:0","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Interrupting a Thread An interrupt is an indication to a thread that it should stop what it is doing and do something else. It’s up to the programmer to decide exactly how a thread responds to an interrupt, but it is very common for the thread to terminate. The 3 methods provided by the Thread class for interrupting a thread : public void interrupt() If any thread is in sleeping or waiting state (i.e. sleep() or wait()) is invoked, calling the interrupt() method on the thread, breaks out the sleeping or waiting state throwing InterruptedException. If the thread is not in the sleeping or waiting state, calling the interrupt() method performs normal behaviour and doesn’t interrupt the thread but sets the interrupt flag to true. t1.interrupt(); public static boolean interrupted() The static interrupted() method returns the interrupted flag afterthat it sets the flag to false if it is true. t1.interrupted() public boolean isInterrupted() The isInterrupted() method returns the interrupted flag either true or false. NOTE : If we interrupt a thread, and propagate the exception, it will stop working. If we don’t want to stop the thread, we should handle it where sleep() or wait() method is invoked. class TestIntrpt extends Thread { public void run() { try { Thread.sleep(1000); System.out.println(\"task\"); } catch (InterruptedException e) { System.out.println(\"Exception handled \" + e); } System.out.println(\"thread is still running after exception...\"); } public static void main(String args[]) { TestIntrpt t1 = new TestIntrpt(); t1.start(); t1.interrupt(); }} ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:10:0","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Reentrant Monitor in Java According to Sun Microsystems, Java monitors are reentrant means java thread can reuse the same monitor for different synchronized methods if method is called from the method. Advantage of Reentrant Monitor: It eliminates the possibility of single thread deadlocking. Example : class Reentrant { public synchronized void m() { n(); System.out.println(\"this is m() method\"); } public synchronized void n() { System.out.println(\"this is n() method\"); } } public class ReentrantExample { public static void main(String args[]) { final ReentrantExample re = new ReentrantExample(); Thread t1 = new Thread() { //creating thread using annonymous class public void run() { re.m(); }}; //calling m() method of Reentrant class t1.start(); }} ","date":"2019-08-06","objectID":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/:11:0","tags":["Java"],"title":"Java Notes(11) Synchronization","uri":"/notes/computerscience/language/java/basicjava/java_notes_11_synchronization/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-09-10","objectID":"/notes/computerscience/language/java/basicjava/java_notes_12_java_doc/","tags":["Java"],"title":"Java Notes(12) JavaDoc","uri":"/notes/computerscience/language/java/basicjava/java_notes_12_java_doc/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-08-02","objectID":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/"},{"categories":["Java"],"content":"Network Overview ","date":"2019-08-02","objectID":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/:0:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/"},{"categories":["Java"],"content":"Java.net java.net is the library working with network development. ","date":"2019-08-02","objectID":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/:1:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/"},{"categories":["Java"],"content":"ServerSocket and Socket ServerSocket is used for server. Socket is used for client. Java Socket Programming provides facility to share data between different computing devices. ","date":"2019-08-02","objectID":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/:2:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/"},{"categories":["Java"],"content":"Port Number The port number is used to uniquely identify different applications. It acts as a communication endpoint between applications. The port number is associated with the IP address for communication between two applications. This allows application communicates to the application via same port number. When writting program, do not use port number less than 1024. Port number less than 1024 are normally reserverd by important applications. Port 80: Http port Port 21: FTP port Port 25: SMTP Email Port 110: POP3 TCP port number is not same with UDP port number. Each has 65536 ports. ","date":"2019-08-02","objectID":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/:3:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/"},{"categories":["Java"],"content":"TCP Socket Programming import java.io.*; import java.net.ServerSocket; import java.net.*; public class JavaTCPServer { public static void main (String[] args) throws Exception{ // Create a server socket with port number 6666 ServerSocket serverSocket = new ServerSocket(6666); while (true){ Socket socket = serverSocket.accept(); DataInputStream inputStream = new DataInputStream (socket.getInputStream()); System.out.println(inputStream.readUTF()); inputStream.close(); System.out.println(\"Client Connected\"); socket.close(); } } } import java.io.*; import java.net.*; public class JavaTCPClient { public static void main (String[] args) throws Exception{ // Create a client socket with local IP address and port number Socket socket = new Socket(\"127.0.0.1\",8888); OutputStream outputStream= socket.getOutputStream(); DataOutputStream dataOutputStream = new DataOutputStream(outputStream); dataOutputStream.writeUTF(\"Hello Server\"); dataOutputStream.flush(); dataOutputStream.close(); } } ","date":"2019-08-02","objectID":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/:4:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/"},{"categories":["Java"],"content":"UDP Programming import java.net.*; public class JavaUDPServer { public static void main(String args[]) throws Exception { byte buf[] = new byte[1024]; DatagramPacket dp = new DatagramPacket (buf,buf.length); DatagramSocket ds = new DatagramSocket(5678); while (true) { ds.receive(dp); System.out.println(new String(buf,0,dp.getLength())); } } } import java.net.*; public class JavaUDPClient { public static void main(String args[]) throws Exception { byte[] buf= (new String(\"Hello\").getBytes()); // Put address in the packet DatagramPacket dp = new DatagramPacket( buf,buf.length,new InetSocketAddress(\"127.0.0.0.1\",5678)); // To use 9999 port DatagramSocket ds = new DatagramSocket(9999); ds.send(dp); ds.close(); } } ","date":"2019-08-02","objectID":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/:5:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/computerscience/language/java/basicjava/java_notes_13_networking/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-09-11","objectID":"/notes/computerscience/language/java/basicjava/java_notes_14_memory/","tags":["Java"],"title":"Java Notes(14) Stack Memory and Heap Space","uri":"/notes/computerscience/language/java/basicjava/java_notes_14_memory/"},{"categories":["Java"],"content":"JVM divides memory into stack and heap memory. Stack Memory Stack Memory in Java is used for static memory allocation and the execution of a thread. It contains primitive values that are specific to a method and references to objects that are in a heap, referred from the method. Access to this memory is in Last-In-First-Out (LIFO) order. Whenever a new method is called, a new block on top of the stack is created which contains values specific to that method, like primitive variables and references to objects. When the method finishes execution, it’s corresponding stack frame is flushed, the flow goes back to the calling method and space becomes available for the next method. ","date":"2019-09-11","objectID":"/notes/computerscience/language/java/basicjava/java_notes_14_memory/:0:0","tags":["Java"],"title":"Java Notes(14) Stack Memory and Heap Space","uri":"/notes/computerscience/language/java/basicjava/java_notes_14_memory/"},{"categories":["Java"],"content":"Key Features of Stack Memory Apart from what we have discussed so far, following are some other features of stack memory: It grows and shrinks as new methods are called and returned respectively Variables inside stack exist only as long as the method that created them is running It’s automatically allocated and deallocated when method finishes execution If this memory is full, Java throws java.lang.StackOverFlowError Access to this memory is fast when compared to heap memory This memory is threadsafe as each thread operates in its own stack Heap Space Heap space in Java is used for dynamic memory allocation for Java objects and JRE classes at the runtime. New objects are always created in heap space and the references to this objects are stored in stack memory. These objects have global access and can be accessed from anywhere in the application. This memory model is further broken into smaller parts called generations, these are: Young Generation – this is where all new objects are allocated and aged. A minor Garbage collection occurs when this fills up. Old or Tenured Generation – this is where long surviving objects are stored. When objects are stored in the Young Generation, a threshold for the object’s age is set and when that threshold is reached, the object is moved to the old generation. Permanent Generation – this consists of JVM metadata for the runtime classes and application methods ","date":"2019-09-11","objectID":"/notes/computerscience/language/java/basicjava/java_notes_14_memory/:0:1","tags":["Java"],"title":"Java Notes(14) Stack Memory and Heap Space","uri":"/notes/computerscience/language/java/basicjava/java_notes_14_memory/"},{"categories":["Java"],"content":"Key Features of Java Heap Space It’s accessed via complex memory management techniques that include Young Generation, Old or Tenured Generation, and Permanent Generation If heap space is full, Java throws java.lang.OutOfMemoryError Access to this memory is relatively slower than stack memory This memory, in contrast to stack, isn’t automatically deallocated. It needs Garbage Collector to free up unused objects so as to keep the efficiency of the memory usage Unlike stack, a heap isn’t threadsafe and needs to be guarded by properly synchronizing the code ","date":"2019-09-11","objectID":"/notes/computerscience/language/java/basicjava/java_notes_14_memory/:0:2","tags":["Java"],"title":"Java Notes(14) Stack Memory and Heap Space","uri":"/notes/computerscience/language/java/basicjava/java_notes_14_memory/"},{"categories":["Java"],"content":"Analyze Memory Example class Person { int id; String name; public Person(int id, String name) { this.id = id; this.name = name; } } public class PersonBuilder { private static Person buildPerson(int id, String name) { return new Person(id, name); } public static void main(String[] args) { int id = 23; String name = \"John\"; Person person = null; person = buildPerson(id, name); } } Upon entering the main() method, a space in stack memory would be created to store primitives and references of this method The primitive value of integer id will be stored directly in stack memory The reference variable person of type Person will also be created in stack memory which will point to the actual object in the heap The call to the parameterized constructor Person(int, String) from main() will allocate further memory on top of the previous stack. This will store: The this object reference of the calling object in stack memory The primitive value id in the stack memory The reference variable of String argument name which will point to the actual string from string pool in heap memory The main method is further calling the buildPerson() static method, for which further allocation will take place in stack memory on top of the previous one. This will again store variables in the manner described above. However, for the newly created object person of type Person, all instance variables will be stored in heap memory. This allocation is explained in this diagram: Summary Table Parameter Stack Memory Heap Space Application Stack is used in parts, one at a time during execution of a thread The entire application uses Heap space during runtime Size Stack has size limits depending upon OS and is usually smaller then Heap There is no size limit on Heap Storage Stores only primitive variables and references to objects that are created in Heap Space All the newly created objects are stored here Order It is accessed using Last-in First-out (LIFO) memory allocation system This memory is accessed via complex memory management techniques that include Young Generation, Old or Tenured Generation, and Permanent Generation Life Stack memory only exists as long as the current method is running Heap space exists as long as the application runs Efficiency Comparatively much faster to allocate when compared to heap Slower to allocate when compared to stack Allocation/Deallocation This Memory is automatically allocated and deallocated when a method is called and returned respectively Heap space is allocated when new objects are created and deallocated by Gargabe Collector when they are no longer referenced Reference: https://www.baeldung.com/java-stack-heap ","date":"2019-09-11","objectID":"/notes/computerscience/language/java/basicjava/java_notes_14_memory/:1:0","tags":["Java"],"title":"Java Notes(14) Stack Memory and Heap Space","uri":"/notes/computerscience/language/java/basicjava/java_notes_14_memory/"},{"categories":["Java"],"content":"Java Fundamental","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"All 48 Java Keywords with Examples Table below lists 48 Keywords in Java. ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:0:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"1) abstract abstract keyword is used to implement the abstraction in java. A method which doesn’t have method definition must be declared as abstract and the class containing it must be declared as abstract. You can’t instantiate abstract classes. Abstract methods must be implemented in the sub classes. You can’t use abstract keyword with variables and constructors. abstract class AbstractClass { abstract void abstractMethod(); } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:1:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"2) assert assert keyword is used in the assertion statements. These statements will enable you to test your assumptions about a program. Assertion statements provide the best way to detect and correct the programming errors. Assertion statements take one boolean expression as input and assumes that this will be always true. If the boolean expression returns false, AssertionError will be thrown. public class MainClass { public static void main(String[] args) { System.out.println(\"Enter your marks\"); Scanner sc = new Scanner(System.in); int marks = sc.nextInt(); assert marks \u003e 35 : \"FAIL\"; } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:2:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"3) boolean boolean keyword is used to define boolean type variables. boolean type variables can hold only two values – either true or false. boolean isActive = true; ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:3:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"4) break The break keyword is used to stop the execution of a loop(for, while, switch-case) based on some condition. public class MainClass { public static void main(String[] args) { for (int i = 0; i \u003c 100; i++) { System.out.println(i); if(i == 50) { break; } } } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:4:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"5) byte byte keyword is used to declare byte type of variables. A byte variable can hold a numeric value in the range from -128 to 127. byte b = 50; ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:5:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"6) switch 7) case Both switch and case keywords are used in the switch-case statement. public class MainClass { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"Enter Day :\"); int day = sc.nextInt(); switch (day) { case 1 : System.out.println(\"SUNDAY\"); break; case 2 : System.out.println(\"MONDAY\"); break; case 3 : System.out.println(\"TUESDAY\"); break; case 4 : System.out.println(\"WEDNESDAY\"); break; case 5 : System.out.println(\"THURSDAY\"); break; case 6 : System.out.println(\"FRIDAY\"); break; case 7 : System.out.println(\"SATURDAY\"); break; default: System.out.println(\"Invalid\"); break; } } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:6:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"8) try 9) catch 10) finally try, catch and finally keywords are used to handle the exceptions in java. The statements which are to be monitored for exceptions are kept in the try block. The exceptions thrown by the try block are caught in the catch block. finally block is always executed. public class MainClass { public static void main(String[] args) { try { int i = Integer.parseInt(\"abc\"); } catch(NumberFormatException ex) { System.out.println(ex); } finally { System.out.println(\"This will be always executed\"); } } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:7:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"11) char char keyword is used to declare primitive char type variables. char represents the characters in java. char a = 'A'; char b = 'B'; char c = 'C'; ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:8:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"12) class class keyword is used to define the classes in java. class MyClass { class MyInnerClass { //Inner Class } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:9:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"13) continue continue keyword is used to stop the execution of current iteration and start the execution of next iteration in a loop. public class MainClass { public static void main(String[] args) { for (int i = 0; i \u003c= 100; i++) { if(i % 5 != 0) { continue; } System.out.println(i); } } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:10:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"14) default default keyword is used to define the default methods in an interface (From Java 8). default keyword is also used in the switch-case statements. interface MyInterface { public default void myDefaultMethod() { System.out.println(\"Default Method\"); } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:11:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"15) do do keyword is used in a do–while loop. do-while loop is used to execute one or more statements repetitively until a condition returns false. public class MainClass { public static void main(String[] args) { int a = 10; int b = 20; do { a = a + b; b = b + 10; System.out.println(\"a = \"+a); System.out.println(\"b = \"+b); } while (a \u003c= 100); } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:12:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"16) double double keyword is used to declare primitive double type of variables. public class MainClass { public static void main(String[] args) { double d1 = 23.56; double d2 = 56.23; double d3 = d1 + d2; System.out.println(d3); } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:13:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"17) if 18) else if and else keywords are used in if-else block. public class MainClass { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"Enter a string :\"); String input = sc.next(); if(input.equalsIgnoreCase(\"JAVA\")) { System.out.println(\"It's JAVA\"); } else { System.out.println(\"It's not JAVA\"); } } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:14:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"19) enum enum keyword is used to define enum types. enum MyEnums { A, B, C, D; } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:15:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"20) extends extends keyword is used in inheritance. It is used when a class extends another class. class SuperClass { //Super Class } class SubClass extends SuperClass { //Sub Class } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:16:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"21) final final keyword is used when a class or a method or a field doesn’t need further modifications. final class can’t be extended, final method can’t be overridden and the value of a final field can’t be changed. A final variable that is not initialized at the time of declaration is known as blank final variable. This can only be initialized in constructor. final class FinalClass { final int finalVariable = 10; final void finalMethod() { //final method } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:17:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"22) float float keyword indicates primitive float type of variables. public class MainClass { public static void main(String[] args) { float f1 = 45.26f; float f2 = 84.25f; float f3 = f2 - f1; System.out.println(f3); } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:18:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"23) for for loop is used to execute the set of statements until a condition is true. public class MainClass { public static void main(String[] args) { for (int i = 0; i \u003c= 10; i++) { System.out.println(i); } } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:19:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"24) implements implements keyword is used while implementing an interface. interface MyInterface { void myMethod(); } class MyClass implements MyInterface { public void myMethod() { System.out.println(\"My Method\"); } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:20:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"25) import import keyword is used to import the members of a particular package into current java file. import java.sql.*; import java.util.Arrays; import java.util.Scanner; ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:21:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"26) instanceOf instanceof operator is used to test whether the object is an instance of the specified type (class/subclass/interface). The syntax for using instanceOf keyword is “Object_Reference instanceOf Type“. class A { } public class MainClass { public static void main(String[] args) { A a = new A(); if(a instanceof A) { System.out.println(\"a is of type A\"); } } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:22:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"27) int int keyword is used to declare primitive integer type of variables. public class MainClass { public static void main(String[] args) { int i1 = 10; int i2 = 20; int i3 = i1 * i2; System.out.println(i3); } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:23:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"28) interface interface keyword is used to define the interfaces in java. interface MyInterface { void myMethod(); } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:24:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"29) long long is used to define the primitive long type variables. public class MainClass { public static void main(String[] args) { long l1 = 101; long l2 = 202; long l3 = l1 + l2; System.out.println(l3); } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:25:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"30) native native keyword is used with a method to indicate that a particular method is implemented in native code using Java Native Interfaces(JNI). class AnyClass { public native void anyMethod(int i, double d); } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:26:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"31) new new keyword is used while creating the instances of a class. class A { } public class MainClass { public static void main(String[] args) { A a = new A(); } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:27:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"32) package Java package is used to categorize the classes and interfaces, provides access protection and removes naming collision.* Package inside the package is called the subpackage. If you import a package (package.* ), subpackages will not be imported. To import subpackage, use import package.classname. The standard of defining package is domain.company.package. eg - com.oracle.database There can be only one public class in a java source file and it must be saved by the public class name. package pack1; class A { } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:28:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"33) private private keyword is used to declare a member of a class as private. private methods and fields are visible within the class in which they are defined. class A { private int i = 111; //private field private void method() { //private method } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:29:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"34) protected protected keyword is used to declare a member of a class as protected. protected members of a class are visible within the package only, but they can be inherited to any sub classes. class A { protected int i = 111; //protected field protected void method() { //protected method } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:30:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"35) public public keyword is used to declare the members of a class or class itself as public. public members of a class are visible from anywhere and they can be inherited to any sub classes. public class A { public int i = 222; //public field public A() { //public constructor } public void method() { //public method } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:31:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"36) return return keyword is used to return the control back to the caller from the method. class A { int method(int i) { return i*i; //method returning a value } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:32:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"37) short short keyword is used to declare primitive short type variables. short s1 = 11; short s2 = 22; ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:33:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"38) static The static can be: variable (class variable), method (class method), block \u0026 nested class. Java static property is shared to all objects, no need to instantiate a class. A static method belongs to the class rather than object of a class. A static method can be invoked without the need for creating an instance of a class. A static method can access static data member and can change the value of it. The static method can not use non static data member or call non-static method directly. this and super cannot be used in static context. The main method is static because object is not required to call static method if it were non-static method, jvm create object first then call main() method that will lead the problem of extra memory allocation. A static block is used to initialize the static data member. It is executed before main method at the time of classloading. A constructor cannot be declared final because it is never inherited. A static final variable that is not initialized at the time of declaration is known as static blank final variable. It can be initialized only in static block class A { static int staticField = 555; //Static Field static void staticMethod() { //Static method } } public class MainClass { public static void main(String[] args) { System.out.println(A.staticField); //Accessing staticField via class name A.staticMethod(); //Accessing staticMethod via class name } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:34:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"39) strictfp strictfp keyword is used to implement the strict precision of floating point calculations on different platforms. strictfp can be used with classes, interfaces and methods. strictfp interface I { //strictfp applied on interface } strictfp class C { //strictfp applied on class } class A { strictfp void method() { //strictfp applied on method } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:35:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"40) super The super keyword is used to access super(the closest parent) class members inside a sub class. class A { int i; public A(int i) { this.i = i; } void methodA() { System.out.println(i); } } class B extends A { public B() { super(10); //Calling super class constructor } void methodB() { System.out.println(super.i); //accessing super class field super.methodA(); //Calling super class method } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:36:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"41) synchronized synchronized keyword is used to implement the synchronization in java. only one thread can enter into a method or a block which is declared as synchronized. Any thread which wants to enter synchronized method or block must acquire object lock of those methods or blocks. class AnyClass { synchronized void synchronizedMethod() { //Synchronized method } void anyMethod() { synchronized (this) { //Synchronized block } } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:37:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"42) this The this keyword refers to the current object in a method or constructor. The most common use of the this keyword is to eliminate the confusion between class attributes and parameters with the same name (because a class attribute is shadowed by a method or constructor parameter). public class Main { int x; // Constructor with a parameter public Main(int x) { // If omit the keyword in this example, the output would be \"0\" instead of \"5\". this.x = x; } // Call the constructor public static void main(String[] args) { Main myObj = new Main(5); System.out.println(\"Value of x = \" + myObj.x); } } this() refers to the the first constructor. class AnyClass { int i; AnyClass() { System.out.println(\"First Constructor\"); } AnyClass(int j) { this(); //calling statement to First Constructor System.out.println(\"Second Constructor\"); } void methodOne() { System.out.println(\"From method one\"); } void methodTwo() { System.out.println(this.i); //Accessing same class field this.methodOne(); //Accessing same class method } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:38:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"43) throw throw keyword is used to throw the exceptions manually. public class MainClass { public static void main(String[] args) { try { //throwing NumberFormatException manually throw new NumberFormatException(); } catch(Exception ex) { System.out.println(ex); } } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:39:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"44) throws throws keyword is used to specify the exceptions which the current method may throw. class A { void method() throws NumberFormatException { int i = Integer.parseInt(\"abc\"); } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:40:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"45) transient transient keyword is used in serialization. A variable which is declared as transient will not be eligible for serialization. class MyClass implements Serializable { int a; transient String s; //This will not be serialized double d; } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:41:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"46) void void keyword is used to indicate that method returns nothing. class A { void methodReturnsNothing() { //Method returns no value } } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:42:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"47) volatile volatile keyword is used in the concurrent programming. The value of a variable which is declared as volatile will be written into or read from the main memory. class A { public volatile int counter = 0; } ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:43:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"},{"categories":["Java"],"content":"48) while while keyword is used in the while loop. public class MainClass { public static void main(String[] args) { int i = 10; while (i \u003c= 100) { System.out.println(i); i = i + 10; } } } Data Types in Java Data Type Default Value Default size boolean false 1 bit char '\\u0000' 2 byte byte 0 1 byte short 0 2 byte int 0 4 byte long 0L 8 byte float 0.0f 4 byte double 0.0d 8 byte Data Type Promotion in Java : Wrapper Classes in Java In Java, there is a wrapper class. This is supported by autoboxing/unboxing feature, which converts primitive into object/object into primitive automatically. Primitive TypeWrapper class booleanBoolean charCharacter byteByte shortShort intInteger longLong floatFloat doubleDouble Operators in Java Operator TypeCategoryPrecedence Unarypostfixexpr++ expr-- prefix++expr --expr +expr -expr ~ ! Arithmeticmultiplicative* / % additive+ - Shiftshift\u003c\u003c \u003e\u003e \u003e\u003e\u003e Relationalcomparison\u003c \u003e \u003c= \u003e= instanceof equality== != Bitwisebitwise AND\u0026 bitwise exclusive OR^ bitwise inclusive OR| Logicallogical AND\u0026\u0026 logical OR|| Ternaryternary? : Assignmentassignment= += -= *= /= %= \u0026= ^= |= \u003c\u003c= \u003e\u003e= \u003e\u003e\u003e= Java Naming Conventions: NameConvention class name should start with uppercase letter and be a noun e.g. String, Color, Button, System, Thread etc. interface nameshould start with uppercase letter and be an adjective e.g. Runnable, Remote, ActionListener etc. method nameshould start with lowercase letter and be a verb e.g. actionPerformed(), main(), print(), println() etc. variable nameshould start with lowercase letter e.g. firstName, orderNumber etc. package nameshould be in lowercase letter e.g. java, lang, sql, util etc. constants nameshould be in uppercase letter. e.g. RED, YELLOW, MAX_PRIORITY etc. ","date":"2019-06-12","objectID":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/:44:0","tags":["Java"],"title":"Java Notes(0) Keyword Reference","uri":"/notes/computerscience/language/java/basicjava/java_notes_0_reference/"}]