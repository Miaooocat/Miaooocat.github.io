[{"categories":["Architecture"],"content":"Application Integration","date":"2020-07-30","objectID":"/notes/architecture_design/integration/","tags":null,"title":"Integrtion","uri":"/notes/architecture_design/integration/"},{"categories":["Architecture"],"content":"In enterprise environments, interaction between applications is important. This interaction allowed organizations to both share data and make use of functionality provided by other systems. Though enterprise application integration can take many different forms, from extract-transform-load jobs run overnight to all-encompassing service-oriented architecture (SOA) strategies, all approaches leverage one of four well-known integration styles: File-based integration Shared-database integration Remote Procedure Calls Message-based integration ","date":"2020-07-30","objectID":"/notes/architecture_design/integration/:0:0","tags":null,"title":"Integrtion","uri":"/notes/architecture_design/integration/"},{"categories":["Architecture"],"content":"Integrating applications by transferring files The most basic approach is for one application to produce a file and for that file to be made available to another system. This approach is simple and generally interoperable because all that’s required is for interacting applications to be able to read and write files. Because the basic requirements for using file-based integration are simple, it’s a fairly common solution, but some of the limitations of filesystems mean that additional complexity may be created in applications having to deal with files. One limitation is that filesystems aren’t transactional and don’t provide metadata about the current state and validity of a file. As a consequence, it’s hard to tell, for example, if another process is currently updating the file. In general, to work properly, this type of integration requires some strategies to ensure that the receiver doesn’t read inconsistent data, such as a half-written file. Also, it requires setting up a process by which corrupt files are moved out of the way to prevent repeated attempts to process them. Another significant drawback is that applications generally need to poll specific locations to discover if more files are ready to be processed, thus introducing additional application complexity and a potential for unnecessary delay. ","date":"2020-07-30","objectID":"/notes/architecture_design/integration/:0:1","tags":null,"title":"Integrtion","uri":"/notes/architecture_design/integration/"},{"categories":["Architecture"],"content":"Interacting through a shared database Databases are more advanced data storage mechanisms than files and alleviate some of the limitations of the filesystems. They provide atomic operations, well-defined data structures, and mechanisms that provide some guarantees on data consistency. Shared-database integration consists of providing the different applications with access to the same database. In general, shared databases are used in two scenarios: As a smarter form of data transfer, by defining a set of staging tables where the different applications can write data that will be consumed by the receiver applications. Compared with the filesystem style, this approach has the advantage that metadata, validation, and support for concurrent access are available out of the box for the transferred data. By allowing different applications to share the same data. This has no direct correspondent to the filesystem style and has the advantage that changes made by one application are made available to everyone else in real-time (unlike the data transfer approach, which involves writing data in the file or staging tables and a certain lag until the recipient application makes use of it). The challenges of shared-database integration are as follows: One-size-fits-all is hardly true in software development, and the compromises necessary to implement a domain model (and subsequent database model) based on the needs of multiple business processes may result in a model that fits no one very well. Sharing the same data model may create unwanted coupling between the different applications in the system. This may seriously affect their capabilities of evolving in the future because changing it will require all the other applications to change as well (at least in the parts that deal directly with the shared model). Concurrent systems frequently writing the same set of data might face performance problems because exclusive access will need to be granted from time to time, so they will end up locking each other out. Caching data in memory might be an issue because applications may not be aware when it becomes stale. Database sharing works well with transferring data between applications but doesn’t solve the problem of invoking functionality in the remote application. ","date":"2020-07-30","objectID":"/notes/architecture_design/integration/:0:2","tags":null,"title":"Integrtion","uri":"/notes/architecture_design/integration/"},{"categories":["Architecture"],"content":"Remote Procedure Calls Remote Procedure Calls (RPC) is an integration style that tries to hide the fact that different services are running on different systems. The method invocation is serialized over the network to the service provider, where the service is invoked. The return value is then serialized and sent back to the invoker. This involves proxies and exporters (in Spring) or stubs and skeletons (in EJB). RPC would presumably allow architects to design scalable applications without developers having to worry about the differences between local and remote invocations. The problem with this approach is that certain details about remoting can’t safely be hidden or ignored. Assuming that RPC can hide these details will lead to simplistic solutions and leaky abstractions. Dealing with problems properly will violate the loose coupling we’ve come to enjoy. RPC requires that parameters and return values of a service are serializable, which means they can be translated into an intermediate format that can be transmitted over the wire. From case to case, this can be achieved in different ways, such as through Java serialization or using XML marshalling through mechanisms such as Java Architecture for XML Binding (JAXB). This not only restricts the types that can be sent, it also requires that the application code deal with serialization or marshalling errors. We’re probably not the first to tell you, but it’s worth mentioning again that the network isn’t reliable. You can assume that a local method invocation returns within a certain (reasonable) time with the return value or an exception, but with a network connection in the mix, this can take much longer, and worse, it’s much less predictable. The trickiest part is that the service that’s invoked can return successfully, but the invoker doesn’t get the response. Assuming you don’t need to account for this is usually a bad idea. Finally, serializing arguments and return values harms interoperability. Sending a representation of some Serializable to an application written in Perl is wishful thinking at best. The need to know about the method name and argument order is questionable. ","date":"2020-07-30","objectID":"/notes/architecture_design/integration/:0:3","tags":null,"title":"Integrtion","uri":"/notes/architecture_design/integration/"},{"categories":["Architecture"],"content":"Message-based integration Messaging is an integration style based on exchanging encapsulated data packets (messages) between components (endpoints) through connections (channels). As described at www.enterpriseintegrationpatterns.com, the packets should be small, and they should be shared frequently, reliably, immediately, and asynchronously. Potentially this resolves many of the problems of encapsulation and error handling associated with the previous three integration styles. It also provides an easy way to deal with sharing both data and functionality, and overall it’s the most recommended integration style when you have a choice. ","date":"2020-07-30","objectID":"/notes/architecture_design/integration/:0:4","tags":null,"title":"Integrtion","uri":"/notes/architecture_design/integration/"},{"categories":["Architecture"],"content":"Application Integration","date":"2020-07-29","objectID":"/notes/architecture_design/coupling/","tags":null,"title":"Coupling","uri":"/notes/architecture_design/coupling/"},{"categories":["Architecture"],"content":"Loose coupling within systems and between systems deserves serious consideration, because it has serious implications for design and maintenance. Achieving an appropriate degree of loose coupling allows you to spend more time adding new features and delivering business value. By contrast, tightly coupled systems are expensive to maintain and expand because small changes to the code tend to produce ripple effects, requiring modifications across a large number of interacting systems. Measuring of Coupling ","date":"2020-07-29","objectID":"/notes/architecture_design/coupling/:0:0","tags":null,"title":"Coupling","uri":"/notes/architecture_design/coupling/"},{"categories":["Spring"],"content":"Spring  Notes","date":"2020-07-20","objectID":"/notes/spring/spring/spring_overview/","tags":["Java"],"title":"Spring Framework Notes - Overview","uri":"/notes/spring/spring/spring_overview/"},{"categories":["Spring"],"content":" Spring Core IOC/DI Spring Bean Spring Web 1. ","date":"2020-07-20","objectID":"/notes/spring/spring/spring_overview/:0:0","tags":["Java"],"title":"Spring Framework Notes - Overview","uri":"/notes/spring/spring/spring_overview/"},{"categories":["Investment"],"content":"Beneish model","date":"2020-07-17","objectID":"/notes/investment/beneish_model/","tags":["Finance"],"title":"Beneish Model","uri":"/notes/investment/beneish_model/"},{"categories":["Investment"],"content":"The Beneish model is a mathematical model that uses financial ratios and eight variables to identify whether a company has manipulated its earnings. It is used as a tool to uncover potential financial fraud. However, the result generated from beneish model can not be the evidence. The variables are constructed from the data in the company’s financial statements, and once calculated, create an M-Score to describe the degree to which the earnings have been manipulated. Once these eight variables are calculated, they are then combined to achieve an M-Score for the company. An M-Score of less than -2.22 suggests that the company will not be a manipulator. An M-Score of greater than -2.22 signals that the company is likely to be a manipulator. The Beneish model’s eight variables are: DSRI: Days’ sales in a receivable index GMI: Gross margin index AQI: Asset quality index SGI: Sales growth index DEPI: Depreciation index SGAI: Sales and general and administrative expenses index LVGI: Leverage index TATA: Total accruals to total assets Beneish M-Score = -4.84 + 0.92DSRI + 0.528GMI + 0.404 * AQI + 0.892 * SGI + 0.115 * DEPI - 0.172 * SGAI + 4.679 *TATA - 0.327 * LVGI 一，应收账款指数（DSRI，Days’Sales in Receivables Index） $$ DSRI = \\frac{本期应收账款占收入比例}{上期应收账款占收入比例} $$ $$ DSRI = \\frac{(Net Receivables_t / Sales_t )}{(Net Receivables_{t-1} / Sales_{t-1})} $$ Sale的数据 如果没有在财报上，可以选择用Revenue来当Sale 一般公司的应收帐款应该比较稳定，如果有了突然的增长，则意味的企业经营可能出现恶化而被迫用信用销售来做调整。 二，毛利率指数（GMI，GrossMargin Index） $$ GMI = \\frac{上期毛利率}{本期毛利率} $$ $$ GMI = \\frac{[(Sales_{t-1} - COGS_{t-1})/ Sales_{t-1}]}{[(Sales_t - COGS_t)/ Sales_t]}$$ 如果指数大于1，则证明企业的盈利能力出现下滑。 CSGS - Cost of goods sold 三，资产质量指数（AQI，AssetQuality Index） $$ AQI = \\frac{本期非实物资产比例}{上期非实物资产比例} $$ $$ AQI = \\frac{Non-current Asset_t/Total Assets_t}{Non-current Asset_{t-1}/Total Assets_{t-1}} $$ 如果指数大于1，则证明企业的资产质量出来下滑。 四，营业收入指数（SGI，SalesGrowth Index） $$ SGI = \\frac{本期销售收入}{上期销售收入} $$ $$ SGI = \\frac{Sales_t}{Sales_{t-1}} $$ 五，折旧率指数（DEPI，DepreciationIndex） $$ DEPI = \\frac{上期折旧率}{本期折旧率}$$ $$ DEPI = \\frac{Depreciation_{t-1}/({PPE}_{t-1}+Depreciation_{t-1})}{Depreciation_{t}/({PPE}_{t}+Depreciation_{t})}$$ PPE is PP\u0026E(Property, Plant, and Equipment) 公司如果折旧率下降，则证明公司有可能通过修改折旧的一些计算方法来提高公司的利润，这是一种常见的财务操作手法。 六，销售管理费用指数（SGAI，Sales,General, and Administrative Expenses Index） $$ SGAI = \\frac{本期销售管理占销售收入比例}{上期销售管理占销售收入比例} $$ $$ SGAI = \\frac{SGA Expense_t/Sales_t}{SGA Expense_{t-1}/Sales_{t-1}} $$ 如果销售管理费用增加，则表明企业在成本控制上遇到一定的问题。 七，财务杠杆指数（LVGI，LeverageIndex） $$ LVGI = \\frac{本期资产负债率}{上期资产负债率} $$ $$ LVGI = \\frac{(Current Liabilities_t + Total Long Term Debt_t)/Total Assets_t}{(Current Liabilities_{t-1} + Total Long Term Debt_{t-1})/Total Assets_{t-1}} $$ 如果公司的企业杠杆率越高，则财务风险越大。 八，应计系数（TATA，TotalAccruals to Total Asset） TATA = \\frac{应计项目}{总资产}$$ TATA = \\frac{Income from Continuing Operations_t - Cash Flows from Operations_t}{Total Assets}$$ 应计利润是一个重要的财务操纵指标，反应了公司所报出来的利润和实际的现金流收入的差值。 ","date":"2020-07-17","objectID":"/notes/investment/beneish_model/:0:0","tags":["Finance"],"title":"Beneish Model","uri":"/notes/investment/beneish_model/"},{"categories":["Spring"],"content":"Spring Integration Notes","date":"2019-10-01","objectID":"/notes/spring/spring_integration/","tags":["Java"],"title":"Spring Integration Notes(1) Overview ","uri":"/notes/spring/spring_integration/"},{"categories":["Spring"],"content":"Spring Integration Basic Overview Spring Integration is an open source framework that designed to enable the development of integration solutions typical of event-driven architectures and messaging-centric architectures. It requires dependency spring intergration core, which could be downloaded from Maven Central. \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.integration\u003c/groupId\u003e \u003cartifactId\u003espring-integration-core\u003c/artifactId\u003e \u003cversion\u003e5.3.1.RELEASE\u003c/version\u003e \u003c/dependency\u003e Spring integration framework consists three parts, namely message, message channel, and message endpoint. In general. a message is a unit of information that can be passed between different message endpoint through message channels. Message: A message is a unit of information that can be passed between different components, called message endpoints. Message Channel: The message channel is the connection between multiple endpoints. The channel implementation manages the details of how and where a message is delivered but shouldn’t need to interact with the payload of a message. Message Endpoint: Message endpoints are the components that actually do something with the message. ","date":"2019-10-01","objectID":"/notes/spring/spring_integration/:1:0","tags":["Java"],"title":"Spring Integration Notes(1) Overview ","uri":"/notes/spring/spring_integration/"},{"categories":["Spring"],"content":"Spring Integration Design Concept ","date":"2019-10-01","objectID":"/notes/spring/spring_integration/:2:0","tags":["Java"],"title":"Spring Integration Notes(1) Overview ","uri":"/notes/spring/spring_integration/"},{"categories":["Spring"],"content":"Loose coupling and event-driven architecture ","date":"2019-10-01","objectID":"/notes/spring/spring_integration/:2:1","tags":["Java"],"title":"Spring Integration Notes(1) Overview ","uri":"/notes/spring/spring_integration/"},{"categories":["Investment"],"content":"Technical Indicator for Stock Market Trend","date":"2019-06-29","objectID":"/notes/investment/technicalindicator/","tags":["Finance"],"title":"Technical Indicator","uri":"/notes/investment/technicalindicator/"},{"categories":["Investment"],"content":"Accumulation/Distribution Line (ADL) The accumulation/distribution line gauges supply and demand by looking at where the price closed within the period’s range, and then multiplying that by volume. The A/D indicator is cumulative, meaning one period’s value is added or subtracted from the last. A rising A/D line helps confirm a rising price trend. A falling A/D line helps confirm a price downtrend. If the price is rising but A/D is falling, it signals underlying weakness and a potential decline in price. If the price of an asset is falling but A/D is rising, it signals underlying strength and the price may start to rise. ","date":"2019-06-29","objectID":"/notes/investment/technicalindicator/:1:0","tags":["Finance"],"title":"Technical Indicator","uri":"/notes/investment/technicalindicator/"},{"categories":["Investment"],"content":"Average Directional Index (ADX) ","date":"2019-06-29","objectID":"/notes/investment/technicalindicator/:2:0","tags":["Finance"],"title":"Technical Indicator","uri":"/notes/investment/technicalindicator/"},{"categories":["Java Language"],"content":"Java keywords reference notes","date":"2019-06-12","objectID":"/notes/java/java_key_words/","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"All 48 Java Keywords with Examples Table below lists 48 Keywords in Java. ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:0:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"1) abstract abstract keyword is used to implement the abstraction in java. A method which doesn’t have method definition must be declared as abstract and the class containing it must be declared as abstract. You can’t instantiate abstract classes. Abstract methods must be implemented in the sub classes. You can’t use abstract keyword with variables and constructors. abstract class AbstractClass { abstract void abstractMethod(); } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:1:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"2) assert assert keyword is used in the assertion statements. These statements will enable you to test your assumptions about a program. Assertion statements provide the best way to detect and correct the programming errors. Assertion statements take one boolean expression as input and assumes that this will be always true. If the boolean expression returns false, AssertionError will be thrown. public class MainClass { public static void main(String[] args) { System.out.println(\"Enter your marks\"); Scanner sc = new Scanner(System.in); int marks = sc.nextInt(); assert marks \u003e 35 : \"FAIL\"; } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:2:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"3) boolean boolean keyword is used to define boolean type variables. boolean type variables can hold only two values – either true or false. boolean isActive = true; ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:3:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"4) break The break keyword is used to stop the execution of a loop(for, while, switch-case) based on some condition. public class MainClass { public static void main(String[] args) { for (int i = 0; i \u003c 100; i++) { System.out.println(i); if(i == 50) { break; } } } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:4:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"5) byte byte keyword is used to declare byte type of variables. A byte variable can hold a numeric value in the range from -128 to 127. byte b = 50; ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:5:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"6) switch 7) case Both switch and case keywords are used in the switch-case statement. public class MainClass { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"Enter Day :\"); int day = sc.nextInt(); switch (day) { case 1 : System.out.println(\"SUNDAY\"); break; case 2 : System.out.println(\"MONDAY\"); break; case 3 : System.out.println(\"TUESDAY\"); break; case 4 : System.out.println(\"WEDNESDAY\"); break; case 5 : System.out.println(\"THURSDAY\"); break; case 6 : System.out.println(\"FRIDAY\"); break; case 7 : System.out.println(\"SATURDAY\"); break; default: System.out.println(\"Invalid\"); break; } } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:6:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"8) try 9) catch 10) finally try, catch and finally keywords are used to handle the exceptions in java. The statements which are to be monitored for exceptions are kept in the try block. The exceptions thrown by the try block are caught in the catch block. finally block is always executed. public class MainClass { public static void main(String[] args) { try { int i = Integer.parseInt(\"abc\"); } catch(NumberFormatException ex) { System.out.println(ex); } finally { System.out.println(\"This will be always executed\"); } } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:7:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"11) char char keyword is used to declare primitive char type variables. char represents the characters in java. char a = 'A'; char b = 'B'; char c = 'C'; ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:8:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"12) class class keyword is used to define the classes in java. class MyClass { class MyInnerClass { //Inner Class } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:9:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"13) continue continue keyword is used to stop the execution of current iteration and start the execution of next iteration in a loop. public class MainClass { public static void main(String[] args) { for (int i = 0; i \u003c= 100; i++) { if(i % 5 != 0) { continue; } System.out.println(i); } } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:10:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"14) default default keyword is used to define the default methods in an interface (From Java 8). default keyword is also used in the switch-case statements. interface MyInterface { public default void myDefaultMethod() { System.out.println(\"Default Method\"); } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:11:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"15) do do keyword is used in a do–while loop. do-while loop is used to execute one or more statements repetitively until a condition returns false. public class MainClass { public static void main(String[] args) { int a = 10; int b = 20; do { a = a + b; b = b + 10; System.out.println(\"a = \"+a); System.out.println(\"b = \"+b); } while (a \u003c= 100); } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:12:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"16) double double keyword is used to declare primitive double type of variables. public class MainClass { public static void main(String[] args) { double d1 = 23.56; double d2 = 56.23; double d3 = d1 + d2; System.out.println(d3); } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:13:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"17) if 18) else if and else keywords are used in if-else block. public class MainClass { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"Enter a string :\"); String input = sc.next(); if(input.equalsIgnoreCase(\"JAVA\")) { System.out.println(\"It's JAVA\"); } else { System.out.println(\"It's not JAVA\"); } } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:14:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"19) enum enum keyword is used to define enum types. enum MyEnums { A, B, C, D; } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:15:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"20) extends extends keyword is used in inheritance. It is used when a class extends another class. class SuperClass { //Super Class } class SubClass extends SuperClass { //Sub Class } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:16:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"21) final final keyword is used when a class or a method or a field doesn’t need further modifications. final class can’t be extended, final method can’t be overridden and the value of a final field can’t be changed. A final variable that is not initialized at the time of declaration is known as blank final variable. This can only be initialized in constructor. final class FinalClass { final int finalVariable = 10; final void finalMethod() { //final method } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:17:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"22) float float keyword indicates primitive float type of variables. public class MainClass { public static void main(String[] args) { float f1 = 45.26f; float f2 = 84.25f; float f3 = f2 - f1; System.out.println(f3); } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:18:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"23) for for loop is used to execute the set of statements until a condition is true. public class MainClass { public static void main(String[] args) { for (int i = 0; i \u003c= 10; i++) { System.out.println(i); } } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:19:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"24) implements implements keyword is used while implementing an interface. interface MyInterface { void myMethod(); } class MyClass implements MyInterface { public void myMethod() { System.out.println(\"My Method\"); } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:20:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"25) import import keyword is used to import the members of a particular package into current java file. import java.sql.*; import java.util.Arrays; import java.util.Scanner; ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:21:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"26) instanceOf instanceof operator is used to test whether the object is an instance of the specified type (class/subclass/interface). The syntax for using instanceOf keyword is “Object_Reference instanceOf Type“. class A { } public class MainClass { public static void main(String[] args) { A a = new A(); if(a instanceof A) { System.out.println(\"a is of type A\"); } } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:22:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"27) int int keyword is used to declare primitive integer type of variables. public class MainClass { public static void main(String[] args) { int i1 = 10; int i2 = 20; int i3 = i1 * i2; System.out.println(i3); } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:23:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"28) interface interface keyword is used to define the interfaces in java. interface MyInterface { void myMethod(); } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:24:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"29) long long is used to define the primitive long type variables. public class MainClass { public static void main(String[] args) { long l1 = 101; long l2 = 202; long l3 = l1 + l2; System.out.println(l3); } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:25:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"30) native native keyword is used with a method to indicate that a particular method is implemented in native code using Java Native Interfaces(JNI). class AnyClass { public native void anyMethod(int i, double d); } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:26:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"31) new new keyword is used while creating the instances of a class. class A { } public class MainClass { public static void main(String[] args) { A a = new A(); } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:27:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"32) package Java package is used to categorize the classes and interfaces, provides access protection and removes naming collision.* Package inside the package is called the subpackage. If you import a package (package.* ), subpackages will not be imported. To import subpackage, use import package.classname. The standard of defining package is domain.company.package. eg - com.oracle.database There can be only one public class in a java source file and it must be saved by the public class name. package pack1; class A { } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:28:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"33) private private keyword is used to declare a member of a class as private. private methods and fields are visible within the class in which they are defined. class A { private int i = 111; //private field private void method() { //private method } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:29:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"34) protected protected keyword is used to declare a member of a class as protected. protected members of a class are visible within the package only, but they can be inherited to any sub classes. class A { protected int i = 111; //protected field protected void method() { //protected method } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:30:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"35) public public keyword is used to declare the members of a class or class itself as public. public members of a class are visible from anywhere and they can be inherited to any sub classes. public class A { public int i = 222; //public field public A() { //public constructor } public void method() { //public method } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:31:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"36) return return keyword is used to return the control back to the caller from the method. class A { int method(int i) { return i*i; //method returning a value } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:32:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"37) short short keyword is used to declare primitive short type variables. short s1 = 11; short s2 = 22; ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:33:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"38) static The static can be: variable (class variable), method (class method), block \u0026 nested class. Java static property is shared to all objects, no need to instantiate a class. A static method belongs to the class rather than object of a class. A static method can be invoked without the need for creating an instance of a class. A static method can access static data member and can change the value of it. The static method can not use non static data member or call non-static method directly. this and super cannot be used in static context. The main method is static because object is not required to call static method if it were non-static method, jvm create object first then call main() method that will lead the problem of extra memory allocation. A static block is used to initialize the static data member. It is executed before main method at the time of classloading. A constructor cannot be declared final because it is never inherited. A static final variable that is not initialized at the time of declaration is known as static blank final variable. It can be initialized only in static block class A { static int staticField = 555; //Static Field static void staticMethod() { //Static method } } public class MainClass { public static void main(String[] args) { System.out.println(A.staticField); //Accessing staticField via class name A.staticMethod(); //Accessing staticMethod via class name } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:34:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"39) strictfp strictfp keyword is used to implement the strict precision of floating point calculations on different platforms. strictfp can be used with classes, interfaces and methods. strictfp interface I { //strictfp applied on interface } strictfp class C { //strictfp applied on class } class A { strictfp void method() { //strictfp applied on method } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:35:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"40) super super keyword is used to access super class members inside a sub class. class A { int i; public A(int i) { this.i = i; } void methodA() { System.out.println(i); } } class B extends A { public B() { super(10); //Calling super class constructor } void methodB() { System.out.println(super.i); //accessing super class field super.methodA(); //Calling super class method } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:36:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"41) synchronized synchronized keyword is used to implement the synchronization in java. only one thread can enter into a method or a block which is declared as synchronized. Any thread which wants to enter synchronized method or block must acquire object lock of those methods or blocks. class AnyClass { synchronized void synchronizedMethod() { //Synchronized method } void anyMethod() { synchronized (this) { //Synchronized block } } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:37:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"42) this this keyword is used to access other members of the same class. class AnyClass { int i; AnyClass() { System.out.println(\"First Constructor\"); } AnyClass(int j) { this(); //calling statement to First Constructor System.out.println(\"Second Constructor\"); } void methodOne() { System.out.println(\"From method one\"); } void methodTwo() { System.out.println(this.i); //Accessing same class field this.methodOne(); //Accessing same class method } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:38:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"43) throw throw keyword is used to throw the exceptions manually. public class MainClass { public static void main(String[] args) { try { //throwing NumberFormatException manually throw new NumberFormatException(); } catch(Exception ex) { System.out.println(ex); } } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:39:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"44) throws throws keyword is used to specify the exceptions which the current method may throw. class A { void method() throws NumberFormatException { int i = Integer.parseInt(\"abc\"); } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:40:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"45) transient transient keyword is used in serialization. A variable which is declared as transient will not be eligible for serialization. class MyClass implements Serializable { int a; transient String s; //This will not be serialized double d; } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:41:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"46) void void keyword is used to indicate that method returns nothing. class A { void methodReturnsNothing() { //Method returns no value } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:42:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"47) volatile volatile keyword is used in the concurrent programming. The value of a variable which is declared as volatile will be written into or read from the main memory. class A { public volatile int counter = 0; } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:43:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Java Language"],"content":"48) while while keyword is used in the while loop. public class MainClass { public static void main(String[] args) { int i = 10; while (i \u003c= 100) { System.out.println(i); i = i + 10; } } } ","date":"2019-06-12","objectID":"/notes/java/java_key_words/:44:0","tags":["Java"],"title":"Java Notes(1) Keywords","uri":"/notes/java/java_key_words/"},{"categories":["Spring"],"content":"Spring  Notes","date":"0001-01-01","objectID":"/notes/spring/spring/spring_bean/","tags":["Java"],"title":"Spring Framework Notes - Beans, BeanFactory and the ApplicationContext","uri":"/notes/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"Bean Bean represents as an objects in Java. Bean need to contain the following points: ","date":"0001-01-01","objectID":"/notes/spring/spring/spring_bean/:1:0","tags":["Java"],"title":"Spring Framework Notes - Beans, BeanFactory and the ApplicationContext","uri":"/notes/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"The Bean class The class attribute in bean is normally mandatory. The creation of bean object is through BeanFactory. It has three approaches. The first approach is where the BeanFactory itself directly creates the bean by calling its constructor (equivalent to Java code calling new), the class attribute specifies the class of the bean to be constructed. \u003cbean id=\"exampleBean\" class=\"examples.ExampleBean\"/\u003e \u003cbean name=\"anotherExample\" class=\"examples.ExampleBeanTwo\"/\u003e The second approach is to call a static, so-called factory method. The class attribute specifies the actual class containing the static factory method. This method returns the wanted object. \u003cbean id=\"exampleBean\" class=\"examples.ExampleBean2\" factory-method=\"createInstance\"/\u003e The third approach is to call an instance factory method. The xml file need specify the factory bean as well. \u003c!-- The factory bean, which contains a method called createInstance --\u003e \u003cbean id=\"myFactoryBean\" class=\"...\"\u003e ... \u003c/bean\u003e \u003c!-- The bean to be created via the factory bean --\u003e \u003cbean id=\"exampleBean\" factory-bean=\"myFactoryBean\" factory-method=\"createInstance\"/\u003e ","date":"0001-01-01","objectID":"/notes/spring/spring/spring_bean/:1:1","tags":["Java"],"title":"Spring Framework Notes - Beans, BeanFactory and the ApplicationContext","uri":"/notes/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"The bean identifiers (id and name) Every bean has one or more ids (also called identifiers, or names; these terms refer to the same thing). These ids must be unique within the BeanFactory or ApplicationContext the bean is hosted in. A bean will almost always have only one id, but if a bean has more than one id, the extra ones can essentially be considered aliases. ","date":"0001-01-01","objectID":"/notes/spring/spring/spring_bean/:1:2","tags":["Java"],"title":"Spring Framework Notes - Beans, BeanFactory and the ApplicationContext","uri":"/notes/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"Bean scopes ","date":"0001-01-01","objectID":"/notes/spring/spring/spring_bean/:1:3","tags":["Java"],"title":"Spring Framework Notes - Beans, BeanFactory and the ApplicationContext","uri":"/notes/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"The singleton scope Only one shared instance of a singleton bean is managed, and all requests for beans with an id or ids matching that bean definition result in that one specific bean instance being returned by the Spring container. Spring’s concept of a singleton bean differs from the Singleton pattern as defined in the Gang of Four (GoF) patterns book. The GoF Singleton hard-codes the scope of an object such that one and only one instance of a particular class is created per ClassLoader. The scope of the Spring singleton is best described as per container and per bean. This means that if you define one bean for a particular class in a single Spring container, then the Spring container creates one and only one instance of the class defined by that bean definition. The singleton scope is the default scope in Spring. To define a bean as a singleton in XML, you would write, for example: \u003cbean id=\"accountService\" class=\"com.foo.DefaultAccountService\"/\u003e \u003c!-- the following is equivalent, though redundant (singleton scope is the default); using spring-beans-2.0.dtd --\u003e \u003cbean id=\"accountService\" class=\"com.foo.DefaultAccountService\" scope=\"singleton\"/\u003e \u003c!-- the following is equivalent and preserved for backward compatibility in spring-beans.dtd --\u003e \u003cbean id=\"accountService\" class=\"com.foo.DefaultAccountService\" singleton=\"true\"/\u003e ","date":"0001-01-01","objectID":"/notes/spring/spring/spring_bean/:1:4","tags":["Java"],"title":"Spring Framework Notes - Beans, BeanFactory and the ApplicationContext","uri":"/notes/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"The prototype scope The non-singleton, prototype scope of bean deployment results in the creation of a new bean instance every time a request for that specific bean is made. That is, the bean is injected into another bean or you request it through a getBean() method call on the container. As a rule, use the prototype scope for all stateful beans and the singleton scope for stateless beans. \u003c!-- using spring-beans-2.0.dtd --\u003e \u003cbean id=\"accountService\" class=\"com.foo.DefaultAccountService\" scope=\"prototype\"/\u003e \u003c!-- the following is equivalent and preserved for backward compatibility in spring-beans.dtd --\u003e \u003cbean id=\"accountService\" class=\"com.foo.DefaultAccountService\" singleton=\"false\"/\u003e In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean: the container instantiates, configures, and otherwise assembles a prototype object, and hands it to the client, with no further record of that prototype instance. Singleton beans with prototype-bean dependencies When you use singleton-scoped beans with dependencies on prototype beans, be aware that dependencies are resolved at instantiation time. Thus if you dependency-inject a prototype-scoped bean into a singleton-scoped bean, a new prototype bean is instantiated and then dependency-injected into the singleton bean. The prototype instance is the sole instance that is ever supplied to the singleton-scoped bean. However, suppose you want the singleton-scoped bean to acquire a new instance of the prototype-scoped bean repeatedly at runtime. You cannot dependency-inject a prototype-scoped bean into your singleton bean, because that injection occurs only once, when the Spring container is instantiating the singleton bean and resolving and injecting its dependencies. I ","date":"0001-01-01","objectID":"/notes/spring/spring/spring_bean/:1:5","tags":["Java"],"title":"Spring Framework Notes - Beans, BeanFactory and the ApplicationContext","uri":"/notes/spring/spring/spring_bean/"},{"categories":["Spring"],"content":"Spring  Notes","date":"0001-01-01","objectID":"/notes/spring/spring/ioc_and_di/","tags":["Java"],"title":"Spring Framework Notes - IOC/DI","uri":"/notes/spring/spring/ioc_and_di/"},{"categories":["Spring"],"content":"Inverse of Control (IOC) and Dependency Injection Dependency Injection (DI) and inversion of Control are a design pattern. It allows the creation of dependent objects outside of a class and provides those objects to a class through different ways. The basic principle is that beans define their dependencies (i.e. the other objects they work with) only through constructor arguments, arguments to a factory method, or properties which are set on the object instance after it has been constructed or returned from a factory method. For example, say your application has a text editor component and you want to provide spell checking. The standard code would look something like this: public class TextEditor { private SpellChecker checker; public TextEditor() { this.checker = new SpellChecker(); } } The inverse controller code would look like this public class TextEditor { private IocSpellChecker checker; public TextEditor(IocSpellChecker checker) { this.checker = checker; } } In the first code example we are instantiating SpellChecker (this.checker = new SpellChecker();), which means the TextEditor class directly depends on the SpellChecker class. In the second code example we are creating an abstraction by having the SpellChecker dependency class in TextEditor’s constructor signature (not initializing dependency in class). This allows us to call the dependency then pass it to the TextEditor class like so: SpellChecker sc = new SpellChecker; // dependency TextEditor textEditor = new TextEditor(sc); The client who create the TextEditor class has control over which SpellChecker implementation to use as this is injected into TextEditor signature Spring use inverse of control and dependency injection. The following is the implementation by both xml or java ","date":"0001-01-01","objectID":"/notes/spring/spring/ioc_and_di/:1:0","tags":["Java"],"title":"Spring Framework Notes - IOC/DI","uri":"/notes/spring/spring/ioc_and_di/"},{"categories":["Spring"],"content":"XML Implementation The following XML declares two beans, an InventoryService bean and a ProductService bean, and wires the Inven- toryService bean into ProductService via a constructor argument: \u003cbean id=\"inventoryService\" class=\"com.example.InventoryService\" /\u003e \u003cbean id=\"productService\" class=\"com.example.ProductService\" /\u003e \u003cconstructor-arg ref=\"inventoryService\" /\u003e \u003c/bean\u003e ","date":"0001-01-01","objectID":"/notes/spring/spring/ioc_and_di/:1:1","tags":["Java"],"title":"Spring Framework Notes - IOC/DI","uri":"/notes/spring/spring/ioc_and_di/"},{"categories":["Spring"],"content":"Java Implementation The @Configuration annotation indicates to Spring that this is a configuration class that will provide beans to the Spring application context. The configuration’s class methods are annotated with @Bean, indicating that the objects they return should be added as beans in the application context. @Configuration public class ServiceConfiguration { @Bean public InventoryService inventoryService() { return new InventoryService(); } @Bean public ProductService productService() { return new ProductService(inventoryService()); } } ","date":"0001-01-01","objectID":"/notes/spring/spring/ioc_and_di/:1:2","tags":["Java"],"title":"Spring Framework Notes - IOC/DI","uri":"/notes/spring/spring/ioc_and_di/"},{"categories":["Spring"],"content":"Dependency Injection Inner Bean There are two types of dependency injection in Spring ","date":"0001-01-01","objectID":"/notes/spring/spring/ioc_and_di/:2:0","tags":["Java"],"title":"Spring Framework Notes - IOC/DI","uri":"/notes/spring/spring/ioc_and_di/"},{"categories":["Spring"],"content":"Type 1 Setter-based dependency injection Setter-based dependency injection is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean. public class TextEditor { private SpellChecker spellChecker; // a setter method to inject the dependency. public void setSpellChecker(SpellChecker spellChecker) { System.out.println(\"Inside setSpellChecker.\" ); this.spellChecker = spellChecker; } // a getter method to return spellChecker public SpellChecker getSpellChecker() { return spellChecker; } public void spellCheck() { spellChecker.checkSpelling(); } } public class SpellChecker { public SpellChecker(){ System.out.println(\"Inside SpellChecker constructor.\" ); } public void checkSpelling() { System.out.println(\"Inside checkSpelling.\" ); } } import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainApp { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); TextEditor te = (TextEditor) context.getBean(\"textEditor\"); te.spellCheck(); } } \u003c?xml version = \"1.0\" encoding = \"UTF-8\"?\u003e \u003cbeans xmlns = \"http://www.springframework.org/schema/beans\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\u003e \u003c!-- Definition for textEditor bean --\u003e \u003cbean id = \"textEditor\" class = \"com.TextEditor\"\u003e \u003cproperty name = \"spellChecker\" ref = \"spellChecker\"/\u003e \u003c/bean\u003e \u003c!-- Definition for spellChecker bean --\u003e \u003cbean id = \"spellChecker\" class = \"com.SpellChecker\"\u003e\u003c/bean\u003e \u003c/beans\u003e ","date":"0001-01-01","objectID":"/notes/spring/spring/ioc_and_di/:2:1","tags":["Java"],"title":"Spring Framework Notes - IOC/DI","uri":"/notes/spring/spring/ioc_and_di/"},{"categories":["Spring"],"content":"Type 2 Constructor-based dependency injection Constructor-based dependency injection is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on the other class. public class TextEditor { private SpellChecker spellChecker; public TextEditor(SpellChecker spellChecker) { System.out.println(\"Inside TextEditor constructor.\" ); this.spellChecker = spellChecker; } public void spellCheck() { spellChecker.checkSpelling(); } } public class SpellChecker { public SpellChecker(){ System.out.println(\"Inside SpellChecker constructor.\" ); } public void checkSpelling() { System.out.println(\"Inside checkSpelling.\" ); } } import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainApp { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); TextEditor te = (TextEditor) context.getBean(\"textEditor\"); te.spellCheck(); } } \u003c?xml version = \"1.0\" encoding = \"UTF-8\"?\u003e \u003cbeans xmlns = \"http://www.springframework.org/schema/beans\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\u003e \u003c!-- Definition for textEditor bean --\u003e \u003cbean id = \"textEditor\" class = \"com.TextEditor\"\u003e \u003cconstructor-arg ref = \"spellChecker\"/\u003e \u003c/bean\u003e \u003c!-- Definition for spellChecker bean --\u003e \u003cbean id = \"spellChecker\" class = \"com.SpellChecker\"\u003e\u003c/bean\u003e \u003c/beans\u003e Constructor arguments resolution The order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor. public class Foo { public Foo(Bar bar, Baz baz) { // ... } } \u003cbeans\u003e \u003cbean id = \"foo\" class = \"x.y.Foo\"\u003e \u003cconstructor-arg ref = \"bar\"/\u003e \u003cconstructor-arg ref = \"baz\"/\u003e \u003c/bean\u003e \u003cbean id = \"bar\" class = \"x.y.Bar\"/\u003e \u003cbean id = \"baz\" class = \"x.y.Baz\"/\u003e \u003c/beans\u003e public class Foo { public Foo(int year, String name) { // ... } } The container can also use type matching with simple types, if you explicitly specify the type of the constructor argument using the type attribute. For example − \u003cbeans\u003e \u003cbean id = \"exampleBean\" class = \"examples.ExampleBean\"\u003e \u003cconstructor-arg type = \"int\" value = \"2001\"/\u003e \u003cconstructor-arg type = \"java.lang.String\" value = \"Zara\"/\u003e \u003c/bean\u003e \u003c/beans\u003e Finally, the best way to pass constructor arguments, use the index attribute to specify explicitly the index of constructor arguments. Here, the index is 0 based. For example − \u003cbeans\u003e \u003cbean id = \"exampleBean\" class = \"examples.ExampleBean\"\u003e \u003cconstructor-arg index = \"0\" value = \"2001\"/\u003e \u003cconstructor-arg index = \"1\" value = \"Zara\"/\u003e \u003c/bean\u003e \u003c/beans\u003e ","date":"0001-01-01","objectID":"/notes/spring/spring/ioc_and_di/:2:2","tags":["Java"],"title":"Spring Framework Notes - IOC/DI","uri":"/notes/spring/spring/ioc_and_di/"},{"categories":["Spring"],"content":"Spring Injecting Collection Java Collection class object can also be injected by using Spring Framework, see example below import java.util.*; public class JavaCollection { List addressList; Set addressSet; Map addressMap; Properties addressProp; // a setter method to set List public void setAddressList(List addressList) { this.addressList = addressList; } // prints and returns all the elements of the list. public List getAddressList() { System.out.println(\"List Elements :\" + addressList); return addressList; } // a setter method to set Set public void setAddressSet(Set addressSet) { this.addressSet = addressSet; } // prints and returns all the elements of the Set. public Set getAddressSet() { System.out.println(\"Set Elements :\" + addressSet); return addressSet; } // a setter method to set Map public void setAddressMap(Map addressMap) { this.addressMap = addressMap; } // prints and returns all the elements of the Map. public Map getAddressMap() { System.out.println(\"Map Elements :\" + addressMap); return addressMap; } // a setter method to set Property public void setAddressProp(Properties addressProp) { this.addressProp = addressProp; } // prints and returns all the elements of the Property. public Properties getAddressProp() { System.out.println(\"Property Elements :\" + addressProp); return addressProp; } } import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MainApp { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); JavaCollection jc=(JavaCollection)context.getBean(\"javaCollection\"); jc.getAddressList(); jc.getAddressSet(); jc.getAddressMap(); jc.getAddressProp(); } } \u003c?xml version = \"1.0\" encoding = \"UTF-8\"?\u003e \u003cbeans xmlns = \"http://www.springframework.org/schema/beans\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\u003e \u003c!-- Definition for javaCollection --\u003e \u003cbean id = \"javaCollection\" class = \"com.JavaCollection\"\u003e \u003c!-- results in a setAddressList(java.util.List) call --\u003e \u003cproperty name = \"addressList\"\u003e \u003clist\u003e \u003cvalue\u003eINDIA\u003c/value\u003e \u003cvalue\u003ePakistan\u003c/value\u003e \u003cvalue\u003eUSA\u003c/value\u003e \u003cvalue\u003eUSA\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!-- results in a setAddressSet(java.util.Set) call --\u003e \u003cproperty name = \"addressSet\"\u003e \u003cset\u003e \u003cvalue\u003eINDIA\u003c/value\u003e \u003cvalue\u003ePakistan\u003c/value\u003e \u003cvalue\u003eUSA\u003c/value\u003e \u003cvalue\u003eUSA\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003c!-- results in a setAddressMap(java.util.Map) call --\u003e \u003cproperty name = \"addressMap\"\u003e \u003cmap\u003e \u003centry key = \"1\" value = \"INDIA\"/\u003e \u003centry key = \"2\" value = \"Pakistan\"/\u003e \u003centry key = \"3\" value = \"USA\"/\u003e \u003centry key = \"4\" value = \"USA\"/\u003e \u003c/map\u003e \u003c/property\u003e \u003c!-- results in a setAddressProp(java.util.Properties) call --\u003e \u003cproperty name = \"addressProp\"\u003e \u003cprops\u003e \u003cprop key = \"one\"\u003eINDIA\u003c/prop\u003e \u003cprop key = \"one\"\u003eINDIA\u003c/prop\u003e \u003cprop key = \"two\"\u003ePakistan\u003c/prop\u003e \u003cprop key = \"three\"\u003eUSA\u003c/prop\u003e \u003cprop key = \"four\"\u003eUSA\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e ","date":"0001-01-01","objectID":"/notes/spring/spring/ioc_and_di/:3:0","tags":["Java"],"title":"Spring Framework Notes - IOC/DI","uri":"/notes/spring/spring/ioc_and_di/"},{"categories":["Java Language"],"content":"Java notes","date":"2019-06-13","objectID":"/notes/java/java_feature_execution/","tags":["Java"],"title":"Java Notes(2) Feature and Program Execution","uri":"/notes/java/java_feature_execution/"},{"categories":["Java Language"],"content":"Java Features and Program Execution Java is a programming language and a platform. Platform: Any hardware or software environment in which a program runs, is known as a platform. Since Java has its own runtime environment (JRE) and Application Programming Interface (API), it is called platform. ","date":"2019-06-13","objectID":"/notes/java/java_feature_execution/:0:0","tags":["Java"],"title":"Java Notes(2) Feature and Program Execution","uri":"/notes/java/java_feature_execution/"},{"categories":["Java Language"],"content":"Features of Java : Simple: User friendly syntax based on C++ It has Automatic Garbage Collection It has Rich set of APIs Removed confusing features - explicit pointers, operator overloading, multiple inheritance, etc Object-oriented: In Java, we organize the software as a combination of different types of objects that incorporates both data and behaviour. Based on the concept of Objects, Class, Inheritance, Polymorphism, Abstraction, Encapsulation Platform Independent: Java provides software-based platform. It has two components: JRE (Runtime Environment) API (Application Programming Interface) Java code is compiled by the compiler and converted into bytecode. This bytecode is a platform-independent. Can run on many platforms - Windows, Linux, Mac, etc. Secured: No explicit pointer JVM - java Programs run inside virtual machine sandbox Classloader - adds security by separating the package for the classes of the local file system from those that are imported from network sources. Bytecode Verifier - checks the code fragments for illegal code that can violate access right to objects. Security Manager - determines what resources a class can access such as reading and writing to the local disk. More - developers can add extra security through SSL, JAAS, Cryptography etc. Robust: Good memory management - automatic garbage collection. No pointers - increses security. Exception handling - increses robustness against errors. Strongly typed - every variable must be declared with a data type. Statically typed - type checking of variables is performed at compile time. Architecture-Neutral: There is no implementation dependent features. e.g. size of primitive types is fixed. Portable: Write Once and Run Anywhere. interpreted: Java is compiled to bytecodes, which are interpreted by a Java run-time environment. The interpreter reads bytecode stream then execute the instructions. High-Performance: Uses ByteCode - Java is faster than traditional interpreted languages since byte code is “close” to native code. Just-In-Time (JIT) - it is designed to support JIT compilers, which dynamically compile bytecodes to machine code. Garbage collector - collect the unused memory space and improve the performance of the application. NOTE: Java is still slower than a compiled language like C/C++. Distributed: We can create distributed applications in java. RMI and EJB are used for creating distributed applications. We may access files by calling the methods from any machine on the internet. Multi-threaded: A thread is like a separate program, executing concurrently. We can write Java programs that deal with many tasks at once by defining multiple threads. The main advantage of multi-threading is that it doesn’t occupy memory for each thread. It shares a common memory area. Threads are important for multi-media, Web applications etc. Dynamic: Dynamic Compilation (JIT) - Implementations to gain performance during program execution. The machine code emitted by a dynamic compiler is constructed and optimized at program runtime, the use of dynamic compilation enables optimizations for efficiency. Load on Demand - Loads in classes as they are needed, even from across the network. Dynamic memory allocation - All Java objects are dynamically allocated. Dynamic Polymorphism - Compiler doesn’t know which method to be called in advance. JVM decides which method to called at run time. ","date":"2019-06-13","objectID":"/notes/java/java_feature_execution/:1:0","tags":["Java"],"title":"Java Notes(2) Feature and Program Execution","uri":"/notes/java/java_feature_execution/"},{"categories":["Java Language"],"content":"Java Program Execution Process : ","date":"2019-06-13","objectID":"/notes/java/java_feature_execution/:2:0","tags":["Java"],"title":"Java Notes(2) Feature and Program Execution","uri":"/notes/java/java_feature_execution/"},{"categories":["Java Language"],"content":"JDK - JRE - JVM : Java Development Kit (JDK): It is a collection of development tools including JRE. Java Runtime Environment (JRE): It contains set of libraries and the JVM. Java Virtual Machine (JVM): It is an abstract machine. It is a specification that provides runtime environment in which java bytecode can be executed. The JVM performs following main tasks: Loads code, Verifies code, Executes code and Provides runtime environment. NOTE - JVMs are available for many hardware and software platforms. JVM, JRE and JDK are platform dependent because configuration of each OS differs. But, Java is platform independent. ","date":"2019-06-13","objectID":"/notes/java/java_feature_execution/:3:0","tags":["Java"],"title":"Java Notes(2) Feature and Program Execution","uri":"/notes/java/java_feature_execution/"},{"categories":["Java Language"],"content":"Internal Architecture of JVM : JVM (Java Virtual Machine) has various sub components internally. You can see the most important ones in the above diagram. Class loader sub system: JVM’s class loader sub system performs 3 tasks It loads .class file into memory. It verifies byte code instructions. It allots memory required for the program. Run time data area: This is the memory resource used by JVM and it is divided into 5 parts Class (Method) area: Stores constant pool, field and method data, the code for methods. Heap: Objects are allocated on the heap. Java stacks: Java stacks are the places where the Java methods are executed. A Java stack contains frames. It holds local variables and partial results, and plays a part in method invocation and return. On each frame, a separate method is executed. Each thread has a private JVM stack, created at the same time as thread. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes. Program counter registers: PC (program counter) register. It contains the address of the JVM instruction currently being executed. Native method stacks: Are places where native methods (eg. C language programs, etc) are executed. Native method interface: Native method interface is a program that connects native methods libraries (C header files) with JVM for executing native methods. Native method library: Holds the native libraries information. Execution engine: Just-In-Time(JIT) compiler: It is used to improve the performance. It coverts byte code into machine code. JIT compiles parts of the byte code that have similar functionality at the same time, and hence reduces the amount of time needed for compilation.Here the term ?compiler? refers to a translator from the instruction set of a Java virtual machine (JVM) to the instruction set of a specific CPU. Interpreter: Read bytecode stream then execute the instructions. Virtual processor NOTE - JVM uses optimization technique to decide which part to be interpreted and which part to be used with JIT compiler. ","date":"2019-06-13","objectID":"/notes/java/java_feature_execution/:4:0","tags":["Java"],"title":"Java Notes(2) Feature and Program Execution","uri":"/notes/java/java_feature_execution/"},{"categories":["Java Language"],"content":"Java fundamentals reference notes","date":"2019-06-15","objectID":"/notes/java/java_fundamentals/","tags":["Java"],"title":"Java Notes(3) Java Fundamentals","uri":"/notes/java/java_fundamentals/"},{"categories":["Java Language"],"content":"Data Types in Java Data Type Default Value Default size boolean false 1 bit char '\\u0000' 2 byte byte 0 1 byte short 0 2 byte int 0 4 byte long 0L 8 byte float 0.0f 4 byte double 0.0d 8 byte ","date":"2019-06-15","objectID":"/notes/java/java_fundamentals/:1:0","tags":["Java"],"title":"Java Notes(3) Java Fundamentals","uri":"/notes/java/java_fundamentals/"},{"categories":["Java Language"],"content":"Data Type Promotion in Java : ","date":"2019-06-15","objectID":"/notes/java/java_fundamentals/:2:0","tags":["Java"],"title":"Java Notes(3) Java Fundamentals","uri":"/notes/java/java_fundamentals/"},{"categories":["Java Language"],"content":"Wrapper Classes in Java In Java, there is a wrapper class. This is supported by autoboxing/unboxing feature, which converts primitive into object/object into primitive automatically. Primitive TypeWrapper class booleanBoolean charCharacter byteByte shortShort intInteger longLong floatFloat doubleDouble ","date":"2019-06-15","objectID":"/notes/java/java_fundamentals/:3:0","tags":["Java"],"title":"Java Notes(3) Java Fundamentals","uri":"/notes/java/java_fundamentals/"},{"categories":["Java Language"],"content":"Operators in Java Operator TypeCategoryPrecedence Unarypostfixexpr++ expr-- prefix++expr --expr +expr -expr ~ ! Arithmeticmultiplicative* / % additive+ - Shiftshift\u003c\u003c \u003e\u003e \u003e\u003e\u003e Relationalcomparison\u003c \u003e \u003c= \u003e= instanceof equality== != Bitwisebitwise AND\u0026 bitwise exclusive OR^ bitwise inclusive OR| Logicallogical AND\u0026\u0026 logical OR|| Ternaryternary? : Assignmentassignment= += -= *= /= %= \u0026= ^= |= \u003c\u003c= \u003e\u003e= \u003e\u003e\u003e= ","date":"2019-06-15","objectID":"/notes/java/java_fundamentals/:4:0","tags":["Java"],"title":"Java Notes(3) Java Fundamentals","uri":"/notes/java/java_fundamentals/"},{"categories":["Java Language"],"content":"Java Naming Conventions : NameConvention class name should start with uppercase letter and be a noun e.g. String, Color, Button, System, Thread etc. interface nameshould start with uppercase letter and be an adjective e.g. Runnable, Remote, ActionListener etc. method nameshould start with lowercase letter and be a verb e.g. actionPerformed(), main(), print(), println() etc. variable nameshould start with lowercase letter e.g. firstName, orderNumber etc. package nameshould be in lowercase letter e.g. java, lang, sql, util etc. constants nameshould be in uppercase letter. e.g. RED, YELLOW, MAX_PRIORITY etc. ","date":"2019-06-15","objectID":"/notes/java/java_fundamentals/:5:0","tags":["Java"],"title":"Java Notes(3) Java Fundamentals","uri":"/notes/java/java_fundamentals/"},{"categories":["Java Language"],"content":"Java Serialization reference notes","date":"2019-08-06","objectID":"/notes/java/java_multithreading/","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Multithreading in java is a process of executing multiple threads simultaneously. Thread is basically a lightweight sub-process, a smallest unit of processing. Multiprocessing and multithreading, both are used to achieve multitasking. But we use multithreading than multiprocessing because threads share a common memory area. They don’t allocate separate memory area so saves memory, and context-switching between the threads takes less time than process. Thread is executed inside the process. There is context-switching between the threads. There can be multiple processes inside the OS and one process can have multiple threads. Advantages of Multithreading : It doesn’t block the user because threads are independent and you can perform multiple operations at same time. You can perform many operations simultaneously so it saves time. Threads are independent so it doesn’t affect other threads if exception occur in a single thread. ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:0:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Multitasking Multitasking is a process of executing multiple tasks simultaneously. We use multitasking to utilize the CPU. Multitasking can be achieved by two ways: Process-based Multitasking(Multiprocessing) Thread-based Multitasking(Multithreading) Multiprocessing Multithreading Each process have its own address in memory i.e. each process allocates separate memory area. Threads share the same address space. Process is heavyweight. Thread is lightweight. Cost of communication between the process is high. Cost of communication between the thread is low. Context-switching require some time for saving \u0026 loading registers, memory maps, updating lists etc. Context-switching between the threads takes less time than process. NOTE : Context switching (aka process/task switching) is the switching of the CPU (central processing unit) from one process or thread to another. ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:1:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Life Cycle of a Thread The life cycle of the thread in java is controlled by JVM. The java thread states are as follows: New - The thread is in new state if you create an instance of Thread class but before the invocation of start() method. Runnable - The thread is in runnable state after invocation of start() method, but the thread scheduler has not selected it to be the running thread. Running - The thread is in running state if the thread scheduler has selected it. Non-Runnable (Blocked) - This is the state when the thread is still alive, but is currently not eligible to run. Terminated - A thread is in terminated or dead state when its run() method exits. NOTE : According to sun, there is only 4 states in thread life cycle in java new, runnable, non-runnable and terminated. There is no running state. ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:2:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Creating a Thread There are two ways to create a thread: By extending Thread class By implementing Runnable interface. Thread class: Thread class provide constructors and methods to create and perform operations on a thread.Thread class extends Object class and implements Runnable interface. Commonly used Constructors of Thread class: Thread() Thread(String name) Thread(Runnable r) Thread(Runnable r,String name) Commonly used methods of Thread class: public void run(): is used to perform action for a thread. public void start(): starts the execution of the thread.JVM calls the run() method on the thread. public void sleep(long miliseconds): Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds. public void join(): waits for a thread to die. public void join(long miliseconds): waits for a thread to die for the specified miliseconds. public int getPriority(): returns the priority of the thread. public int setPriority(int priority): changes the priority of the thread. public String getName(): returns the name of the thread. public void setName(String name): changes the name of the thread. public Thread currentThread(): returns the reference of currently executing thread. public int getId(): returns the id of the thread. public Thread.State getState(): returns the state of the thread. public boolean isAlive(): tests if the thread is alive. public void yield(): causes the currently executing thread object to temporarily pause and allow other threads to execute. public void suspend(): is used to suspend the thread(depricated). public void resume(): is used to resume the suspended thread(depricated). public void stop(): is used to stop the thread(depricated). public boolean isDaemon(): tests if the thread is a daemon thread. public void setDaemon(boolean b): marks the thread as daemon or user thread. public void interrupt(): interrupts the thread. public boolean isInterrupted(): tests if the thread has been interrupted. public static boolean interrupted(): tests if the current thread has been interrupted. Runnable interface: The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. Runnable interface have only one method named run(). public void run(): is used to perform action for a thread. Starting a thread: start() method of Thread class is used to start a newly created thread. It performs following tasks: A new thread starts(with new callstack). The thread moves from New state to the Runnable state. When the thread gets a chance to execute, its target run() method will run. ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:3:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Creating Thread Codes : Thread Example by extending Thread class class Multi extends Thread{ public void run(){ System.out.println(\"thread is running...\"); } public static void main(String args[]){ Multi t1=new Multi(); t1.start(); } } Thread Example by implementing Runnable interface class Multi3 implements Runnable{ public void run(){ System.out.println(\"thread is running...\"); } public static void main(String args[]){ Multi3 m1=new Multi3(); Thread t1 =new Thread(m1); t1.start(); } } ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:4:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Thread Scheduler in Java Thread scheduler in java is the part of the JVM that decides which thread should run. There is no guarantee that which runnable thread will be chosen to run by the thread scheduler. Only one thread at a time can run in a single process. The thread scheduler mainly uses preemptive or time slicing scheduling to schedule the threads. Difference between preemptive scheduling and time slicing Under preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence. Under time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors. NOTE : We cannot start a thread twice. After starting a thread, it can never be started again. If you does so, an IllegalThreadStateException is thrown the moment it is started for the second time. ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:5:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"sleep() method in Java The sleep() method of Thread class is used to sleep a thread for the specified amount of time. The Thread class provides two methods for sleep : public static void sleep(long miliseconds)throws InterruptedException public static void sleep(long miliseconds, int nanos)throws InterruptedException Thread.sleep(500) At a time only one thread is executed. If you sleep a thread for the specified time,the thread shedular picks up another thread and so on. ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:6:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"run() method in Java In Java, Each thread starts in a separate call stack. Invoking the run() method from main thread, the run() method goes onto the current call stack rather than at the beginning of a new call stack. Problem if you use run() directly instead of start() “ There is no context-switching in the below program because here t1 and t2 will be treated as normal object not thread object. Output will be : 1 2 3 4 5 1 2 3 4 5 (One object will finish before starting next) class TestCallRun extends Thread{ public void run(){ for(int i=1;i\u003c5;i++){ try{Thread.sleep(500);}catch(InterruptedException e){System.out.println(e);} System.out.println(i); } } public static void main(String args[]){ TestCallRun2 t1=new TestCallRun2(); TestCallRun2 t2=new TestCallRun2(); t1.run(); t2.run(); } } } } ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:7:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"join() method in Java Java Thread join() method can be used to pause the current thread execution, until the specified thread is dead. There are three join methods : public void join() public void join(long millis) public void join(long millis, int nanos) Examples : t1.join(); \\\\Current thread will be paused, until t1 is dead. (t1 will start executing) t1.join(1500); \\\\Current thread will be paused, t1 will execute for 1500 milliseconds. ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:8:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Naming Thread The Thread class provides methods to change and get the name of a thread. By default, each thread has a name i.e. thread-0, thread-1 and so on. But, we can change the name of the thread by using setName() method. public String getName(): is used to get the name of a thread. t1.getName() public void setName(String name): is used to change the name of a thread. t1.setName(\"My sweet thread\"); Getting the Current Thread public static Thread currentThread(): The currentThread() method returns a reference of currently executing thread. public void run(){ System.out.println(Thread.currentThread().getName()); } ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:9:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Priority of a Thread Each thread have a priority. Priorities are represented by a number between 1 and 10. In most cases, thread schedular schedules the threads according to their priority (known as preemptive scheduling). But it is not guaranteed because it depends on JVM specification that which scheduling it chooses. The 3 constants defined in Thread class: public static int MIN_PRIORITY public static int NORM_PRIORITY public static int MAX_PRIORITY Default priority of a thread is 5 (NORM_PRIORITY). The value of MIN_PRIORITY is 1 and the value of MAX_PRIORITY is 10. System.out.println(\"thread priority is:\"+t1.getPriority()); t1.setPriority(Thread.MIN_PRIORITY); ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:10:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Daemon Thread Daemon thread in java is a service provider thread that provides services to the user thread. It has no role in life than to serve user threads. Its life depends on user threads i.e. when all the user threads dies, JVM terminates this thread automatically. It is a low priority thread. There are many java daemon threads running automatically e.g. gc, finalizer etc. NOTE : You can see all the detail by typing the jconsole in the command prompt. The jconsole tool provides information about the loaded classes, memory usage, running threads etc. Methods for Daemon Thread: public void setDaemon(boolean status): is used to mark the current thread as daemon thread or user thread. t1.setDaemon(true); //Now, t1 is a daemon thread t1.start() public boolean isDaemon(): is used to check that current is daemon. if(t1.isDaemon()) { ... } If you want to make a user thread as Daemon, it must not be started otherwise it will throw IllegalThreadStateException. t1.start(); t1.setDaemon(true); //will Throw Exception Here ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:11:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Java Thread Pool Java Thread pool represents a group of worker threads that are waiting for the job and reuse many times. In case of thread pool, a group of fixed size threads are created. A thread from the thread pool is pulled out and assigned a job by the service provider. After completion of the job, thread is contained in the thread pool again. Advantage of Java Thread Pool is Better performance. It saves time because there is no need to create new thread. Real time usage: It is used in Servlet and JSP where container creates a thread pool to process the request. Example Syntax: ExecutorService executor = Executors.newFixedThreadPool(5); //creating a pool of 5 threads Runnable worker = new ... executor.execute(worker); //calling execute method of ExecutorService ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:12:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"ThreadGroup Class in Java Java provides a convenient way to group multiple threads in a single object. In such way, we can suspend, resume or interrupt group of threads by a single method call. Java thread group is implemented by java.lang.ThreadGroup class. NOTE : Now suspend(), resume() and stop() methods are deprecated. Constructors of ThreadGroup class : No.ConstructorDescription 1)ThreadGroup(String name)creates a thread group with given name. 2)ThreadGroup(ThreadGroup parent, String name)creates a thread group with given parent group and name. Important methods of ThreadGroup class : No.MethodDescription 1)int activeCount()returns no. of threads running in current group. 2)int activeGroupCount()returns a no. of active group in this thread group. 3)void destroy()destroys this thread group and all its sub groups. 4)String getName()returns the name of this group. 5)ThreadGroup getParent()returns the parent of this group. 6)void interrupt()interrupts all threads of this group. 7)void list()prints information of this group to standard console. Creating group of threads : ThreadGroup tg1 = new ThreadGroup(\"Group A\"); Thread t1 = new Thread(tg1,new MyRunnable(),\"one\"); Thread t2 = new Thread(tg1,new MyRunnable(),\"two\"); Thread t3 = new Thread(tg1,new MyRunnable(),\"three\"); Now all 3 threads belong to one group. Here, tg1 is the thread group name, MyRunnable is the class that implements Runnable interface and “one”, “two” and “three” are the thread names. Now we can interrupt all threads by a single line of code only. Thread.currentThread().getThreadGroup().interrupt(); ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:13:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Java Shutdown Hook The shutdown hook can be used to perform cleanup resource or save the state when JVM shuts down normally or abruptly. Performing clean resource means closing log file, sending some alerts or something else. So if you want to execute some code before JVM shuts down, use shutdown hook. The JVM shuts down when: user presses ctrl+c on the command prompt, System.exit(int) method is invoked, user logoff, shutdown, etc. The addShutdownHook() method of Runtime class is used to register the thread with the Virtual Machine. public void addShutdownHook(Thread hook){} The object of Runtime class can be obtained by calling the static factory method getRuntime() Runtime r = Runtime.getRuntime(); Factory method: The method that returns the instance of a class is known as factory method. NOTE: The shutdown sequence can be stopped by invoking the halt(int) method of Runtime class. ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:14:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Multitask Each thread run in a separate callstack. class TestMultitasking1 extends Thread{ public void run(){ System.out.println(\"task one\"); } public static void main(String args[]){ TestMultitasking1 t1=new TestMultitasking1(); TestMultitasking1 t2=new TestMultitasking1(); t1.start(); t2.start(); } } ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:15:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Java Garbage Collection In Java, garbage means unreferenced objects. Garbage Collection is process of reclaiming the runtime unused memory automatically. In other words, it is a way to destroy the unused objects. To do so, we were using free() function in C language and delete() in C++. But, in java it is performed automatically. So, java provides better memory management. Advantage of Garbage Collection: It makes java memory efficient because garbage collector removes the unreferenced objects from heap memory. It is automatically done by the garbage collector(a part of JVM) so we don’t need to make extra efforts. How an object is unreferenced: By nulling the reference Employee e=new Employee(); e=null; By assigning a reference to another Employee e1=new Employee(); Employee e2=new Employee(); e1=e2; //now, the first object referred by e1 is available for garbage collection By annonymous object new Employee(); etc. finalize() method The finalize() method is invoked each time before the object is garbage collected. This method can be used to perform cleanup processing. This method is defined in Object class as: protected void finalize(){} NOTE : The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing (destroying remaining objects). gc() method The gc() method is used to invoke the garbage collector to perform cleanup processing. The gc() is found in System and Runtime classes. This method is defined in System class as: public static void gc(){} System.gc(); // explicitely invoking the garbage collector NOTE : Garbage collection is performed by a daemon thread called Garbage Collector(GC). This thread calls the finalize() method before object is garbage collected. NOTE : Neither finalization nor garbage collection is guaranteed. ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:16:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Java Runtime Class Java Runtime class is used to interact with java runtime environment. Java Runtime class provides methods to execute a process, invoke GC, get total and free memory etc. There is only one instance of java.lang.Runtime class is available for one java application. The Runtime.getRuntime() method returns the singleton instance of Runtime class. Important methods of Java Runtime class : No.MethodDescription 1)public static Runtime getRuntime()returns the instance of Runtime class. 2)public void exit(int status)terminates the current virtual machine. 3)public void addShutdownHook(Thread hook)registers new hook thread. 4)public Process exec(String command)throws IOExceptionexecutes given command in a separate process. 5)public int availableProcessors()returns no. of available processors. 6)public long freeMemory()returns amount of free memory in JVM. 7)public long totalMemory()returns amount of total memory in JVM. ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:17:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Java Runtime exec() method public class Runtime1{ public static void main(String args[])throws Exception{ Runtime.getRuntime().exec(\"notepad\"); // Will open a new notepad } } Shutdown system in Java : Runtime.getRuntime().exec(\"shutdown -s -t 0\"); // Shutdown You can use shutdown -s command to shutdown system. For windows OS, you need to provide full path of shutdown command e.g. c:\\Windows\\System32\\shutdown. Here you can use -s switch to shutdown system, -r switch to restart system and -t switch to specify time delay. Runtime.getRuntime().exec(\"c:\\\\Windows\\\\System32\\\\shutdown -s -t 0\"); // Windows Shutdown Runtime.getRuntime().exec(\"shutdown -r -t 0\"); // Restart Runtime availableProcessors() method : System.out.println(Runtime.getRuntime().availableProcessors()); Runtime freeMemory() and totalMemory() method : System.out.println(\"Total Memory: \"+Runtime.totalMemory()); System.out.println(\"Free Memory: \"+Runtime.freeMemory()); ","date":"2019-08-06","objectID":"/notes/java/java_multithreading/:18:0","tags":["Java"],"title":"Java Notes(14) Multithreading","uri":"/notes/java/java_multithreading/"},{"categories":["Java Language"],"content":"Java networking reference notes","date":"2019-08-02","objectID":"/notes/java/java_networking/","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java/java_networking/"},{"categories":["Java Language"],"content":"Java Networking is a concept of connecting two or more computing devices together so that we can share resources. Java Socket Programming provides facility to share data between different computing devices. Advantage of Java Networking : sharing resources centralized software management ","date":"2019-08-02","objectID":"/notes/java/java_networking/:0:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java/java_networking/"},{"categories":["Java Language"],"content":"Java Networking Terminology : Some of the widely used java networking terminologies are as follows: IP Address IP address is a unique number assigned to a node of a network e.g. 192.168.0.1. It is composed of octets that range from 0 to 255. It is a logical address that can be changed. Protocol A protocol is a set of rules basically that is followed for communication. For example: TCP, FTP, Telnet, SMTP, POP, etc. Port Number The port number is used to uniquely identify different applications. It acts as a communication endpoint between applications. The port number is associated with the IP address for communication between two applications. MAC Address MAC (Media Access Control) Address is a unique identifier of NIC (Network Interface Controller). A network node can have multiple NIC but each with unique MAC. The main difference between MAC and IP address is that, MAC Address is used to ensure the physical address of computer. It uniquely identifies the devices on a network. While IP address are used to uniquely identifies the connection of network with that device take part in a network. Socket A socket is an endpoint between two way communication. More details in “Socket” section below. Connection-oriented protocol In connection-oriented protocol, acknowledgement is sent by the receiver. So, it is reliable but slow. The example of connection-oriented protocol is TCP. Connection-less protocol In connection-less protocol, acknowledgement is not sent by the receiver. So, it is not reliable but fast. The example of connection-less protocol is UDP. ","date":"2019-08-02","objectID":"/notes/java/java_networking/:1:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java/java_networking/"},{"categories":["Java Language"],"content":"java.net package The java.net package provides many classes to deal with networking applications in Java. A list of these classes is given below: Authenticator CacheRequest CacheResponse ContentHandler CookieHandler CookieManager DatagramPacket DatagramSocket DatagramSocketImpl InterfaceAddress JarURLConnection MulticastSocket InetSocketAddress InetAddress Inet4Address Inet6Address IDN HttpURLConnection HttpCookie NetPermission NetworkInterface PasswordAuthentication Proxy ProxySelector ResponseCache SecureCacheResponse ServerSocket Socket SocketAddress SocketImpl SocketPermission StandardSocketOptions URI URL URLClassLoader URLConnection URLDecoder URLEncoder URLStreamHandler ","date":"2019-08-02","objectID":"/notes/java/java_networking/:2:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java/java_networking/"},{"categories":["Java Language"],"content":"Java Socket Programming Java Socket programming is used for communication between the applications running on different JRE. Java Socket programming can be connection-oriented or connection-less. Socket and ServerSocket classes are used for connection-oriented socket programming and DatagramSocket and DatagramPacket classes are used for connection-less socket programming. The client in socket programming must know two information: IP Address of Server Port number. ","date":"2019-08-02","objectID":"/notes/java/java_networking/:3:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java/java_networking/"},{"categories":["Java Language"],"content":"Socket Class : A socket is simply an endpoint for communications between the machines. The Socket class can be used to create a socket. Important methods : MethodDescription 1) public InputStream getInputStream()returns the InputStream attached with this socket. 2) public OutputStream getOutputStream()returns the OutputStream attached with this socket. 3) public synchronized void close()closes this socket ","date":"2019-08-02","objectID":"/notes/java/java_networking/:3:1","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java/java_networking/"},{"categories":["Java Language"],"content":"ServerSocket Class : The ServerSocket class can be used to create a server socket. This object is used to establish communication with the clients. Important methods : MethodDescription 1) public Socket accept()returns the socket and establish a connection between server and client. 2) public synchronized void close()closes the server socket. ","date":"2019-08-02","objectID":"/notes/java/java_networking/:3:2","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java/java_networking/"},{"categories":["Java Language"],"content":"Example of Java Socket Programming ","date":"2019-08-02","objectID":"/notes/java/java_networking/:4:0","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java/java_networking/"},{"categories":["Java Language"],"content":"Creating Server : ServerSocket ss = new ServerSocket(6666); Socket s = ss.accept(); //establishes connection and waits for the client ","date":"2019-08-02","objectID":"/notes/java/java_networking/:4:1","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java/java_networking/"},{"categories":["Java Language"],"content":"Creating Client : Socket s = new Socket(\"localhost\",6666); ","date":"2019-08-02","objectID":"/notes/java/java_networking/:4:2","tags":["Java"],"title":"Java Notes(13) Networking","uri":"/notes/java/java_networking/"},{"categories":["Java Language"],"content":"Java Serialization reference notes","date":"2019-07-30","objectID":"/notes/java/java_serialization/","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java/java_serialization/"},{"categories":["Java Language"],"content":"Serialization in java is a mechanism of writing the state of an object into a byte stream. It is mainly used in Hibernate, RMI, JPA, EJB and JMS technologies. The reverse operation of serialization is called deserialization. Advantage of Java Serialization : It is mainly used to travel object’s state on the network (known as marshaling). java.io.Serializable interface : Serializable is a marker interface (has no data member and method). It is used to “mark” java classes so that objects of these classes may get certain capability. The Cloneable and Remote are also marker interfaces. It must be implemented by the class whose object you want to persist. The String class and all the wrapper classes implements java.io.Serializable interface by default. ","date":"2019-07-30","objectID":"/notes/java/java_serialization/:0:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java/java_serialization/"},{"categories":["Java Language"],"content":"ObjectOutputStream class The ObjectOutputStream class is used to write primitive data types and Java objects to an OutputStream. Only objects that support the java.io.Serializable interface can be written to streams. Constructor : public ObjectOutputStream(OutputStream out) throws IOException {} Above constructor creates an ObjectOutputStream that writes to the specified OutputStream. Important Methods : MethodDescription 1) public final void writeObject(Object obj) throws IOException {}writes the specified object to the ObjectOutputStream. 2) public void flush() throws IOException {}flushes the current output stream. 3) public void close() throws IOException {}closes the current output stream. ","date":"2019-07-30","objectID":"/notes/java/java_serialization/:1:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java/java_serialization/"},{"categories":["Java Language"],"content":"Example of Java Serialization Example to serialize the object of Student class. import java.io.*; class Persist{ public static void main(String args[])throws Exception{ Student s1 =new Student(211,\"John\"); FileOutputStream fout=new FileOutputStream(\"f.txt\"); ObjectOutputStream out=new ObjectOutputStream(fout); out.writeObject(s1); out.flush(); System.out.println(\"success\"); } } ","date":"2019-07-30","objectID":"/notes/java/java_serialization/:2:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java/java_serialization/"},{"categories":["Java Language"],"content":"Deserialization in java Deserialization is the process of reconstructing the object from the serialized state.It is the reverse operation of serialization. ","date":"2019-07-30","objectID":"/notes/java/java_serialization/:3:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java/java_serialization/"},{"categories":["Java Language"],"content":"ObjectInputStream class An ObjectInputStream deserializes objects and primitive data written using an ObjectOutputStream. Constructor : public ObjectInputStream(InputStream in) throws IOException {} Above constructor creates an ObjectInputStream that reads from the specified InputStream. Important Methods : MethodDescription 1) public final Object readObject() throws IOException, ClassNotFoundException{}reads an object from the input stream. 2) public void close() throws IOException {}closes ObjectInputStream. ","date":"2019-07-30","objectID":"/notes/java/java_serialization/:4:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java/java_serialization/"},{"categories":["Java Language"],"content":"Example of Java Deserialization Example to deserialize the object of Student class. import java.io.*; class Depersist{ public static void main(String args[])throws Exception{ ObjectInputStream in=new ObjectInputStream(new FileInputStream(\"f.txt\")); Student s=(Student)in.readObject(); System.out.println(s.id+\" \"+s.name); in.close(); } } ","date":"2019-07-30","objectID":"/notes/java/java_serialization/:5:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java/java_serialization/"},{"categories":["Java Language"],"content":"Serialization Rules Serialization with Inheritance (IS-A Relationship) : If a class implements serializable then all its sub classes will also be serializable. Parent class properties are inherited to subclasses so if parent class is Serializable, subclass would also be. Serialization with Aggregation (HAS-A Relationship) : If a class has a reference of another class, all the references must be Serializable otherwise serialization process will not be performed. In such case, NotSerializableException is thrown at runtime. All the objects within an object must be Serializable. Serialization with static data member : If there is any static data member in a class, it will not be serialized because static is the part of class not object. Serialization with array or collection : In case of array or collection, all the objects of array or collection must be serializable. If any object is not serialiizable, serialization will be failed. ","date":"2019-07-30","objectID":"/notes/java/java_serialization/:6:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java/java_serialization/"},{"categories":["Java Language"],"content":"Externalizable in Java The Externalizable interface provides the facility of writing the state of an object into a byte stream in compress format. It is not a marker interface. The Externalizable interface provides two methods: public void writeExternal(ObjectOutput out) throws IOException public void readExternal(ObjectInput in) throws IOException ","date":"2019-07-30","objectID":"/notes/java/java_serialization/:7:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java/java_serialization/"},{"categories":["Java Language"],"content":"Java Transient Keyword If you don’t want to serialize any data member of a class, you can mark it as transient. Example : transient int age; //It will not be serialized ","date":"2019-07-30","objectID":"/notes/java/java_serialization/:8:0","tags":["Java"],"title":"Java Notes(12) Serialization","uri":"/notes/java/java_serialization/"},{"categories":["Java Language"],"content":"Java OOP reference notes","date":"2019-06-17","objectID":"/notes/java/java_oop/","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java/java_oop/"},{"categories":["Java Language"],"content":"Object Oriented Object-Oriented Programming is a methodology or paradigm to design a program using classes and objects. It simplifies the software development and maintenance. ","date":"2019-06-17","objectID":"/notes/java/java_oop/:1:0","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java/java_oop/"},{"categories":["Java Language"],"content":"Class A class in Java can contain: field(variable, attribute), methods, constructors, blocks, nested class and interface. Object is an instance of a class. There is only one way to define class in java using class keyword. The Object class is the parent class of all the classes in java by default. ","date":"2019-06-17","objectID":"/notes/java/java_oop/:1:1","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java/java_oop/"},{"categories":["Java Language"],"content":"Constructor Constructor in java is a special type of method that is used to initialize the object. If there is no constructor in a class, compiler automatically creates a default constructor. There is no copy constructor in java. But, we can copy the values of one object to another like copy constructor in C++. A constructor can perform other tasks instead of initialization like object creation, starting a thread, calling method etc. You can perform any operation in the constructor as you perform in the method. Constructor must not have return type. Constructor name must be same as the class name. super() is added in each class constructor automatically by compiler if there is no super() or this() ","date":"2019-06-17","objectID":"/notes/java/java_oop/:1:2","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java/java_oop/"},{"categories":["Java Language"],"content":"Instance initializer block Instance Initializer block is used to initialize the instance data member. It is created when instance of the class is created. It runs each time when object of the class is created. It is invoked after the parent class constructor is invoked (i.e. after super() constructor call). The instance Initializer block comes in the order in which they appear. ","date":"2019-06-17","objectID":"/notes/java/java_oop/:1:3","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java/java_oop/"},{"categories":["Java Language"],"content":"Four Pillars of OOP The main concepts in object oriented programming are Inheritance, Polymorphism, Abstraction, Encapsulation. ","date":"2019-06-17","objectID":"/notes/java/java_oop/:2:0","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java/java_oop/"},{"categories":["Java Language"],"content":"Inheritance Inheritance (IS-A) is a mechanism in which one object acquires all the properties and behaviors of parent object. The extends keyword indicates that you are making a new class that derives from an existing class. Multiple inheritance is not supported in Java through class. We can use Interface to perform it. To reduce the complexity and simplify the language, multiple inheritance is not supported in java. If a class have an entity reference, it is known as Aggregation (HAS-A relationship). Inheritance should be used only if the relationship is-a is maintained throughout the lifetime of the objects involved; otherwise, aggregation is the best choice. ","date":"2019-06-17","objectID":"/notes/java/java_oop/:2:1","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java/java_oop/"},{"categories":["Java Language"],"content":"Polymorphism Polymorphism is a concept by which we can perform a single action by different ways. There are two types of polymorphism in java: compile time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding. If you overload static method in java, it is the example of compile time polymorphism. In Runtime polymorphism (Dynamic Method Dispatch), an overridden method is resolved at runtime rather than compile-time. A Virtual Method is an inheritable and overridable method for which dynamic dispatch is facilitated. All non-static, non-final and non-private methods are Virtual Methods by default. When reference variable of Parent class refers to the object of Child class, it is known as upcasting. Method is overridden not the data members, so runtime polymorphism can’t be achieved by data members. Connecting a method call to the method body is known as binding. There are two types of binding : Static binding (early binding) and Dynamic binding (late binding). Method Overloading (compile time polymorphism) If a class has multiple methods having same name but different in parameters, it is known as Method Overloading. There are two ways to overload the method in java : by changing number of arguments, by changing the data type. In Java, Method Overloading is not possible by changing the return type of the method only because of ambiguity. Compile Time Error is better than Run Time Error. So, java compiler renders compiler time error if you declare the same method having same parameters. We can also overload Java main() method, but JVM calls main() method which receives string array as arguments only. One type is promoted to another implicitly if no matching datatype is found. eg. byte can be promoted to short, int, etc. If there are no matching type arguments method, and each method promotes similar number of arguments, there will be ambiguity. One type is not de-promoted implicitly for example double cannot be depromoted to any type implicitly. Method Overriding (runtime polymorphism) If subclass (child class) has the same method as declared in the parent class, it is known as method overriding. Method must have same name and parameters as in the parent class for overriding. Method overriding is used to provide specific implementation of a method that is already provided by its super class. Also used for runtime polymorphism. We cannot override static method (not also main method) because static method is bound with class whereas instance method is bound with object. Static belongs to class area and instance belongs to heap area. Method Overriding with Access Modifier: if you are overriding a method, overridden method (i.e. declared in subclass) must not be more restrictive. Covariant Return Type: It is possible to override method by changing the return type if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type. ","date":"2019-06-17","objectID":"/notes/java/java_oop/:2:2","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java/java_oop/"},{"categories":["Java Language"],"content":"Abstraction Abstraction is a process of hiding the implementation details and showing only functionality to the user. There are two ways to achieve abstraction in java : Abstract class and Interface. Abstract class A class that is declared as abstract (keyword) is abstract class. It can have abstract and non-abstract methods. A method that is declared as abstract and does not have implementation is abstract method. Any method with a body is non-abstract method. An abstract class can have data member, abstract method, method body, constructor and even main() method. If there is any abstract method in a class, that class must be abstract. If extending any abstract class that have abstract method, we must either provide the implementation of the method or make this class abstract. Interface An interface in java is a blueprint of a class. It has static constants and abstract methods. Since Java 8, we can have method body in interface. But we need to make it default or static method. The interface is a mechanism to achieve abstraction. It represents IS-A relationship. By using interface, we can support multiple inheritance. It can be also used to achieve loose coupling (coupling is degree of direct knowledge that one element has of another). The Java compiler adds public \u0026 abstract before the interface method. Adds public, static \u0026 final before data members. A class extends another class, an interface extends another interface but a class implements an interface. Multiple inheritance is not supported by class because of ambiguity. But, supported by interface because there is no ambiguity as implementation is provided by the implementation class. An interface with no member is called marker/tagged interface. For example: Serializable, Cloneable, Remote etc. Marker interface are used to provide essential information to JVM, so that JVM may perform some useful operation. An interface can have another interface i.e. known as nested interface. ","date":"2019-06-17","objectID":"/notes/java/java_oop/:2:3","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java/java_oop/"},{"categories":["Java Language"],"content":"Encapsulation Encapsulation is a process of wrapping code and data together into a single unit. To create a fully encapsulated class, make all data members of the class private, \u0026 use setter/getter methods to access data. By providing only setter or getter method, you can make the class read-only or write-only. ","date":"2019-06-17","objectID":"/notes/java/java_oop/:2:4","tags":["Java"],"title":"Java Notes(4) Object Oriented Language","uri":"/notes/java/java_oop/"},{"categories":["Java Language"],"content":"Java Generic notes","date":"2019-07-05","objectID":"/notes/java/java_generics/","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Generic Classes A generic class declaration looks like a non-generic class declaration, except that the class name is followed by a type parameter section. The type parameter section of a generic class can have one or more type parameters separated by commas. These classes are known as parameterized classes or parameterized types because they accept one or more parameters. Syntax: public class Box\u003cT\u003e { private T t; } Box − Box is a generic class. T − The generic type parameter passed to generic class. It can take any Object. t − Instance of generic type T. ","date":"2019-07-05","objectID":"/notes/java/java_generics/:1:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Naming Conventions By convention, type parameter names are named as single, uppercase letters so that a type parameter can be distinguished easily with an ordinary class or interface name. Following is the list of commonly used type parameter names − E − Element (mainly used by Java Collections framework) K − Key (mainly used to represent key of a map) V − Value (mainly used to represent value of a map) N − Number (represents numbers) T − Type (represents first generic type parameter) S, U, V, etc − 2nd, 3rd, 4th Types ","date":"2019-07-05","objectID":"/notes/java/java_generics/:2:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Type Inference Type inference represents the Java compiler’s ability to look at a method invocation and its corresponding declaration to check and determine the type argument(s). The inference algorithm checks the types of the arguments and, if available, assigned type is returned. Inference algorithms tries to find a specific type which can fullfill all type parameters. Compiler generates unchecked conversion warning in-case type inference is not used. Syntax: Box\u003cInteger\u003e integerBox = new Box\u003c\u003e(); Box − Box is a generic class. − The diamond operator denotes type inference. Using diamond operator, compiler determines the type of the parameter. This operator is avalilable from Java SE 7 version onwards. ","date":"2019-07-05","objectID":"/notes/java/java_generics/:3:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Generic Methods You can write a single generic method declaration that can be called with arguments of different types. Based on the types of the arguments passed to the generic method, the compiler handles each method call appropriately. Following are the rules to define Generic Methods − All generic method declarations have a type parameter section delimited by angle brackets () that precedes the method's return type ( in the next example). Each type parameter section contains one or more type parameters separated by commas. A type parameter, also known as a type variable, is an identifier that specifies a generic type name. The type parameters can be used to declare the return type and act as placeholders for the types of the arguments passed to the generic method, which are known as actual type arguments. A generic method's body is declared like that of any other method. Note that type parameters can represent only reference types, not primitive types (like int, double and char). public static \u003cE\u003e void printArray( E[] inputArray ) { // Display array elements for(E element : inputArray) { System.out.printf(\"%s \", element); } System.out.println(); } ","date":"2019-07-05","objectID":"/notes/java/java_generics/:4:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Multiple Type Parameters A Generic class can have muliple type parameters. Following example will showcase above mentioned concept. public class Box\u003cS,T\u003e { private T t; private S s; } ","date":"2019-07-05","objectID":"/notes/java/java_generics/:5:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Parameterized Types A Generic class can have parameterized types where a type parameter can be substituted with a parameterized type. Parameterized Types are types that take other types as parameters. Eg - Collection, ArrayList, etc. public class Box\u003cS,T\u003e { ... } ... Box\u003cInteger, List\u003cString\u003e\u003e box = new Box\u003cInteger, List\u003cString\u003e\u003e(); //Parameterized Types ... ","date":"2019-07-05","objectID":"/notes/java/java_generics/:6:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Raw Types A raw type is an object of a generic class or interface if its type arguments are not passed during its creation. Box rawBox = new Box(); ","date":"2019-07-05","objectID":"/notes/java/java_generics/:7:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Bounded Type Parameters There may be times when you’ll want to restrict the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for. To declare a bounded type parameter, list the type parameter’s name, followed by the extends keyword, followed by its upper bound. Single Bound: public static \u003cT extends Comparable\u003cT\u003e\u003e T maximum(T x, T y, T z) Multiple Bounds: public static \u003cT extends Number \u0026 Comparable\u003cT\u003e\u003e T maximum(T x, T y, T z) maximum − maximum is a generic method. T − The generic type parameter passed to generic method. It can take any Object. The T is a type parameter passed to the generic class Box and should be subtype of Number class and must implments Comparable interface. In case a class is passed as bound, it should be passed first before interface otherwise compile time error will occur. Calling eg.: maximum( 6.6, 8.8, 7.7 ) ","date":"2019-07-05","objectID":"/notes/java/java_generics/:8:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Collections Framework Examples Java has provided generic support in Collections Framework Interfaces like List, Set, Map, etc. ","date":"2019-07-05","objectID":"/notes/java/java_generics/:9:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"List List\u003cT\u003e list = new ArrayList\u003cT\u003e(); list − object of List interface. T − The generic type parameter passed during List declaration. The T is a type parameter passed to the generic interface List and its implemenation class ArrayList. ","date":"2019-07-05","objectID":"/notes/java/java_generics/:9:1","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Set Set\u003cT\u003e set = new HashSet\u003cT\u003e(); set − object of Set Interface. T − The generic type parameter passed during Set declaration. The T is a type parameter passed to the generic interface Set and its implemenation class HashSet. ","date":"2019-07-05","objectID":"/notes/java/java_generics/:9:2","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Map Map\u003cT\u003e set = new HashMap\u003cT\u003e(); set − object of Map Interface. T − The generic type parameter passed during Map declaration. The T is a type parameter passed to the generic interface Map and its implemenation class HashMap. ","date":"2019-07-05","objectID":"/notes/java/java_generics/:9:3","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Generics Wild Cards The question mark (?), represents the wildcard, stands for unknown type in generics. ","date":"2019-07-05","objectID":"/notes/java/java_generics/:10:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Upper Bounded Wildcards There may be times when you’ll want to restrict the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. To declare a upper bounded Wildcard parameter, list the ?, followed by the extends keyword, followed by its upper bound. public static double sum(List\u003c? extends Number\u003e numberlist) { ... } ","date":"2019-07-05","objectID":"/notes/java/java_generics/:10:1","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Unbounded Wildcards There may be times when any object can be used when a method can be implemented using functionality provided in the Object class or When the code is independent of the type parameter. To declare a Unbounded Wildcard parameter, list the ? only. public static void printAll(List\u003c?\u003e list) { ... } ","date":"2019-07-05","objectID":"/notes/java/java_generics/:10:2","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Lower Bounded Wildcards There may be times when you’ll want to restrict the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Integer or its superclasses like Number. To declare a lower bounded Wildcard parameter, list the ?, followed by the super keyword, followed by its lower bound. public static void addCat(List\u003c? super Cat\u003e catList) { ... } ... //You can add list of Cat or Animal (super class of the Cat class) addCat(animalList); addCat(catList); ","date":"2019-07-05","objectID":"/notes/java/java_generics/:10:3","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Type Erasure Generics are used for tighter type checks at compile time and to provide a generic programming. To implement generic behaviour, java compiler apply type erasure. Type erasure is a process in which compiler replaces a generic parameter with actual class or bridge method. In type erasure, compiler ensures that no extra classes are created and there is no runtime overhead. Type Erasure rules: Replace type parameters in generic type with their bound if bounded type parameters are used. Replace type parameters in generic type with Object if unbounded type parameters are used. Insert type casts to preserve type safety. Generate bridge methods to keep polymorphism in extended generic types. ","date":"2019-07-05","objectID":"/notes/java/java_generics/:11:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Restrictions on Generics No Primitive Types - Using generics, primitive types can not be passed as type parameters. Box\u003cint\u003e intBox = new Box\u003cint\u003e() //Error NOTE: Use Wrappers like Integar instead. No Instance - A type parameter cannot be used to instantiate its object inside a method. public static \u003cT\u003e void add(Box\u003cT\u003e box) //Error NOTE: To achieve such functionality, reflection can be used. No Static field - Using generics, type parameters are not allowed to be static. As static variable is shared among object so compiler can not determine which type to used. class Box\u003cT\u003e { private static T t; //Error } No Cast - Casting to a parameterized type is not allowed unless it is parameterized by unbounded wildcards. Box\u003cInteger\u003e integerBox = new Box\u003cInteger\u003e(); Box\u003cNumber\u003e numberBox = new Box\u003cNumber\u003e(); integerBox = (Box\u003cInteger\u003e)numberBox; //Error: Cannot cast from Box\u003cNumber\u003e to Box\u003cInteger\u003e NOTE: To achive the same, unbounded wildcards can be used. No instanceOf - Because compiler uses type erasure, the runtime does not keep track of type parameters, so at runtime difference between Box and Box cannot be verified using instanceOf operator. ... integerBox instanceof Box\u003cInteger\u003e ... No Array - Arrays of parameterized types are not allowed. Because compiler uses type erasure, the type parameter is replaced with Object and user can add any type of object to the array. And at runtime, code will not able to throw ArrayStoreException. Object[] stringBoxes = new Box\u003cString\u003e[]; //Error No Exceptionn - A generic class is not allowed to extend the Throwable class directly or indirectly. //The generic class Box\u003cT\u003e may not subclass java.lang.Throwable class Box\u003cT\u003e extends Exception {} class Box1\u003cT\u003e extends Throwable {} A method is not allowed to catch an instance of a type parameter. ... catch (T e) ... No Overload - A class is not allowed to have two overloaded methods that can have the same signature after type erasure. ... public void print(List\u003cString\u003e stringList) { } // Error public void print(List\u003cInteger\u003e integerList) { } ","date":"2019-07-05","objectID":"/notes/java/java_generics/:12:0","tags":["Java"],"title":"Java Notes(5) Generic","uri":"/notes/java/java_generics/"},{"categories":["Java Language"],"content":"Java collection reference notes","date":"2019-07-16","objectID":"/notes/java/java_collection/","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"The java.util package contains all the classes and interfaces for Collection framework. Map : An object that maps keys to values. A map is not ordered and cannot contain duplicate keys (but can contain duplicate values). Each key can map to at most one value. Collection : A collection represents a group of objects, known as its elements. The JDK provides implementations of more specific subinterfaces like Set and List. List : A list is an ordered list of objects, where the same object may well appear more than once. For example: [1, 7, 1, 3, 1, 1, 1, 5]. It makes sense to talk about the “third element” in a list. You can add an element anywhere in the list, change an element anywhere in the list, or remove an element from any position in the list. Queue : A queue is also ordered, but you’ll only ever touch elements at one end. All elements get inserted at the “end” and removed from the “beginning” (or head) of the queue. You can find out how many elements are in the queue, but you can’t find out what, say, the “third” element is. You’ll see it when you get there. Set : A set is not ordered and cannot contain duplicates. Any given object either is or isn’t in the set. {7, 5, 3, 1} is the exact same set as {1, 7, 3, 5}. You again can’t ask for the “third” element or even the “first” element, since they are not in any particular order. You can add or remove elements, and you can find out if a certain element exists. ListSetQueueMap OrderYesNoYesNo DuplicatesYesNoYesNo (Allow duplicate values not keys) Null ValuesYesSingle NullYes (LinkedList Queue). No (Priority Queue).Single null key and many null values ","date":"2019-07-16","objectID":"/notes/java/java_collection/:0:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"Hierarchy of Collection Interface : ","date":"2019-07-16","objectID":"/notes/java/java_collection/:1:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"Methods of Collection Interface : No.MethodDescription 1public boolean add(Object element) is used to insert an element in this collection. 2public boolean addAll(Collection c)is used to insert the specified collection elements in the invoking collection. 3public boolean remove(Object element)is used to delete an element from this collection. 4public boolean removeAll(Collection c)is used to delete all the elements of specified collection from the invoking collection. 5public boolean retainAll(Collection c)is used to delete all the elements of invoking collection except the specified collection. 6public int size()return the total number of elements in the collection. 7public void clear()removes the total no of element from the collection. 8public boolean contains(Object element)is used to search an element. 9public boolean containsAll(Collection c)is used to search the specified collection in this collection. 10public Iterator iterator()returns an iterator. 11public Object[] toArray()converts collection into array. 12public boolean isEmpty()checks if collection is empty. 13public boolean equals(Object element)matches two collection. 14public int hashCode()returns the hashcode number for collection. ","date":"2019-07-16","objectID":"/notes/java/java_collection/:2:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"Methods of Iterator Interface : No.MethodDescription 1public boolean hasNext()It returns true if iterator has more elements. 2public Object next()It returns the element and moves the cursor pointer to the next element. 3public void remove()It removes the last elements returned by the iterator. It is rarely used. ","date":"2019-07-16","objectID":"/notes/java/java_collection/:3:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"ArrayList vs LinkedList : ArrayListLinkedList 1) ArrayList internally uses dynamic array to store the elements.LinkedList internally uses doubly linked list to store the elements. 2) Manipulation with ArrayList is slow because it internally uses array. If any element is removed from the array, all the bits are shifted in memory.Manipulation with LinkedList is faster than ArrayList because it uses doubly linked list so no bit shifting is required in memory. 3) ArrayList class can act as a list only because it implements List only.LinkedList class can act as a list and queue both because it implements List and Deque interfaces. 4) ArrayList is better for storing and accessing data.LinkedList is better for manipulating data. ","date":"2019-07-16","objectID":"/notes/java/java_collection/:4:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"ArrayList vs Vector : ArrayListVector 1) ArrayList is not synchronized.Vector is synchronized. 2) ArrayList increments 50% of current array size if number of element exceeds from its capacity.Vector increments 100% means doubles the array size if total number of element exceeds than its capacity. 3) ArrayList is not a legacy class, it is introduced in JDK 1.2.Vector is a legacy class. 4) ArrayList is fast because it is non-synchronized.Vector is slow because it is synchronized i.e. in multithreading environment, it will hold the other threads in runnable or non-runnable state until current thread releases the lock of object. 5) ArrayList uses Iterator interface to traverse the elements.Vector uses Enumeration interface to traverse the elements. But it can use Iterator also. ","date":"2019-07-16","objectID":"/notes/java/java_collection/:5:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"Hierarchy of Map Interface : ","date":"2019-07-16","objectID":"/notes/java/java_collection/:6:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"Useful Methods of Map Interface : MethodDescription Object put(Object key, Object value)It is used to insert an entry in this map. void putAll(Map map)It is used to insert the specified map in this map. Object remove(Object key)It is used to delete an entry for the specified key. Object get(Object key)It is used to return the value for the specified key. boolean containsKey(Object key)It is used to search the specified key from this map. Set keySet()It is used to return the Set view containing all the keys. Set entrySet()It is used to return the Set view containing all the keys and values. ","date":"2019-07-16","objectID":"/notes/java/java_collection/:7:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"Methods of Map.Entry Interface : MethodDescription Object getKey()It is used to obtain key. Object getValue()It is used to obtain value. ","date":"2019-07-16","objectID":"/notes/java/java_collection/:8:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"HashMap vs HashTable : HashMapHashtable 1) HashMap is non synchronized. It is not-thread safe and can't be shared between many threads without proper synchronization code.Hashtable is synchronized. It is thread-safe and can be shared with many threads. 2) HashMap allows one null key and multiple null values.Hashtable doesn't allow any null key or value. 3) HashMap is a new class introduced in JDK 1.2.Hashtable is a legacy class. 4) HashMap is fast.Hashtable is slow. 5) We can make the HashMap as synchronized by calling this code Map m = Collections.synchronizedMap(hashMap);Hashtable is internally synchronized and can't be unsynchronized. 6) HashMap is traversed by Iterator.Hashtable is traversed by Enumerator and Iterator. 7) Iterator in HashMap is fail-fast.Enumerator in Hashtable is not fail-fast. 8) HashMap inherits AbstractMap class.Hashtable inherits Dictionary class. ","date":"2019-07-16","objectID":"/notes/java/java_collection/:9:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"Collections Framework Implementation Classes Summary : ","date":"2019-07-16","objectID":"/notes/java/java_collection/:10:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"Comparable vs Comparator Interfaces : ComparableComparator 1) Comparable provides single sorting sequence. In other words, we can sort the collection on the basis of single element such as id or name or price etc. Comparator provides multiple sorting sequence. In other words, we can sort the collection on the basis of multiple elements such as id, name and price etc. 2) Comparable affects the original class i.e. actual class is modified.Comparator doesn't affect the original class i.e. actual class is not modified. 3) Comparable provides compareTo() method to sort elements.Comparator provides compare() method to sort elements. 4) Comparable is found in java.lang package.Comparator is found in java.util package. 5) We can sort the list elements of Comparable type by Collections.sort(List) method.We can sort the list elements of Comparator type by Collections.sort(List,Comparator) method. ","date":"2019-07-16","objectID":"/notes/java/java_collection/:11:0","tags":["Java"],"title":"Java Notes(6) Collection Framework","uri":"/notes/java/java_collection/"},{"categories":["Java Language"],"content":"Java exception handling reference notes","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Exception Handling in Java Exception is an event that disrupts the normal flow of the program. It is an object which is thrown at runtime. The exception handling in java is one of the powerful mechanism to handle the runtime errors so that normal flow of the application can be maintained. An Error “indicates serious problems that a reasonable application should not try to catch.” An Exception “indicates conditions that a reasonable application might want to catch.” ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:0:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Hierarchy of the Throwable Class : ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:1:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Types of Exceptions : 1. Checked Exception - A checked exception is an exception that occurs at the compile time, these are also called as compile time exceptions. These exceptions cannot simply be ignored at the time of compilation, the programmer should take care of (handle) these exceptions. e.g. IOException, SQLException, ClassNotFoundException, CloneNotSupported, etc. Checked exceptions are checked at compile-time. 2. Unchecked Exception - An unchecked exception is an exception that occurs at the time of execution. These are also called as Runtime Exceptions. These include programming bugs, such as logic errors or improper use of an API. e.g. ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException etc. Unchecked exceptions are not checked at compile-time rather they are checked at runtime. 3. Error - These are not exceptions at all, but problems that arise beyond the control of the user or the programmer. Errors are typically ignored in your code because you can rarely do anything about an error. Suppose, if a stack overflow occurs, an error will arise. e.g. OutOfMemoryError, VirtualMachineError, AssertionError etc. ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:2:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Exception Example Situations : ArithmeticException int a = 50/0; //ArithmeticException NullPointerException String s = null; System.out.println(s.length());//NullPointerException NumberFormatException String s = \"abc\"; int i = Integer.parseInt(s);//NumberFormatException ArrayIndexOutOfBoundsException int a[] = new int[5]; a[10] = 50; //ArrayIndexOutOfBoundsException ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:3:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Java Exception Handling Keywords : 1. try - Java try block is used to enclose the code that might throw an exception. It must be used within the method. Java try block must be followed by either catch or finally block. 2. catch - Java catch block is used to handle the Exception. It must be used after the try block only. You can use multiple catch block with a single try. 3. finally - Java finally block is a block that is used to execute important code such as closing connection, stream etc. Java finally block is always executed whether exception is handled or not. Java finally block follows try or catch block. 4. throw - Java throw keyword is used to explicitly throw an exception. We can throw either checked or uncheked exception in java by throw keyword. The throw keyword is mainly used to throw custom exception. 5. throws - Java throws keyword is used to declare an exception. It gives an information to the programmer that there may occur an exception so it is better for the programmer to provide the exception handling code. NOTE : Exception Handling is mainly used to handle the checked exceptions. If there occurs any unchecked exception such as NullPointerException, it is programmers fault that he is not performing check up before the code being used. ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:4:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"JVM’s Default Exception Handler The JVM firstly checks whether the exception is handled or not. If exception is not handled, JVM provides a default exception handler that performs the following tasks: Prints out exception description. Prints the stack trace (Hierarchy of methods where the exception occurred). Causes the program to terminate. But if exception is handled by the application programmer, normal flow of the application is maintained i.e. rest of the code is executed. ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:5:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Using Multiple catch blocks If the superclass method declares an exception, subclass overridden method can declare same, subclass exception or no exception but cannot declare parent exception. All catch blocks must be ordered from most specific to most general i.e. catch for ArithmeticException must come before catch for Exception. ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:6:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Using finally block If you don’t handle exception, before terminating the program, JVM executes finally block(if any). For each try block there can be zero or more catch blocks, but only one finally block. The finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort). ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:7:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Execution Propagation An exception is first thrown from the top of the stack and if it is not caught, it drops down the call stack to the previous method,If not caught there, the exception again drops down to the previous method, and so on until they are caught or until they reach the very bottom of the call stack.This is called exception propagation. By default Unchecked Exceptions are forwarded in calling chain (propagated). By default, Checked Exceptions are not forwarded in calling chain (propagated). ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:8:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Using throws keyword Only Checked exception should be declared, because Unchecked Exception are under your control (so correct your code) And Errors are beyond your control. Advantage : By using throws keyword Checked Exception can be propagated (forwarded in call stack). It provides information to the caller of the method about the exception. If you are calling a method that declares an exception, you must either caught or declare the exception. You caught the exception i.e. handle the exception using try/catch. the code will be executed fine whether exception occurs during the program or not. You declare the exception i.e. specifying throws with the method. if exception does not occur, the code will be executed fine. if exception occures, an exception will be thrown at runtime because throws does not handle the exception. You can rethrow and exception by throwing same exception in catch block. ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:9:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Java throw vs throws Keywords No.throwthrows 1)Java throw keyword is used to explicitly throw an exception.Java throws keyword is used to declare an exception. 2)Checked exception cannot be propagated using throw only.Checked exception can be propagated with throws. 3)Throw is followed by an instance.Throws is followed by class. 4)Throw is used within the method.Throws is used with the method signature. 5)You cannot throw multiple exceptions.You can declare multiple exceptions e.g. public void method()throws IOException,SQLException. ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:10:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Java final vs finally vs finalize No.finalfinallyfinalize 1)Final is used to apply restrictions on class, method and variable. Final class can't be inherited, final method can't be overridden and final variable value can't be changed.Finally is used to place important code, it will be executed whether exception is handled or not.Finalize is used to perform clean up processing just before object is garbage collected. 2)Final is a keyword.Finally is a block.Finalize is a method. ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:11:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Exception Handling with Method Overriding : If the superclass method does not declare an exception, subclass overridden method cannot declare the checked exception but it can declare unchecked exception. If the superclass method declares an exception, subclass overridden method can declare same, subclass exception or no exception but cannot declare parent exception. ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:12:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Java Language"],"content":"Java Custom Exception : If you are creating your own Exception that is known as custom exception or user-defined exception. Java custom exceptions are used to customize the exception according to user need. By the help of custom exception, you can have your own exception and message. ","date":"2019-07-25","objectID":"/notes/java/java_errors_and_exception_handling/:13:0","tags":["Java"],"title":"Java Notes(7) Error and Exception Handling","uri":"/notes/java/java_errors_and_exception_handling/"},{"categories":["Javascript Language"],"content":"Javascript Notes","date":"2020-08-18","objectID":"/notes/javascript/javascriptstudynotes/","tags":["Javascript"],"title":"Javascript Study Notes","uri":"/notes/javascript/javascriptstudynotes/"},{"categories":["Javascript Language"],"content":"Overview ","date":"2020-08-18","objectID":"/notes/javascript/javascriptstudynotes/:1:0","tags":["Javascript"],"title":"Javascript Study Notes","uri":"/notes/javascript/javascriptstudynotes/"},{"categories":["Javascript Language"],"content":"1.1 Use external JavaScript \u003chtml\u003e \u003chead\u003e \u003cscript type=\"text/javascript\" src=\"xxx.js\"\u003e \u003c/script\u003e \u003c/head\u003e \u003c/html\u003e ","date":"2020-08-18","objectID":"/notes/javascript/javascriptstudynotes/:1:1","tags":["Javascript"],"title":"Javascript Study Notes","uri":"/notes/javascript/javascriptstudynotes/"},{"categories":["Javascript Language"],"content":"1.2. Variable and Operators Variables var declarations are globally scoped or function scoped while let and const are block scoped. var variables can be updated and re-declared within its scope; let variables can be updated but not re-declared; const variables can neither be updated nor re-declared. x=5; var x=5; let x=5; const x = 5; Arithmetic Operators: +, -, *, /, % (modulus), ++, -- Assignment Operators: =, +=, -=, *=, /=, %= String addition x = \"5\" + \"5\" // result is \"55\" x = 5 + \"5\" // result is still \"55\" Comparison operators == // equal to === // exactly equal to (value and type) != // not equal to \u003e // greater \u003c // less \u003e= // greater than or equal to \u003c= // less than or equal to Conditional operator varname = (condition)? value1: value2 ","date":"2020-08-18","objectID":"/notes/javascript/javascriptstudynotes/:1:2","tags":["Javascript"],"title":"Javascript Study Notes","uri":"/notes/javascript/javascriptstudynotes/"},{"categories":["Javascript Language"],"content":"1.3. Controll Structure if (condition) { ... } if (condition) { ... } else { ... } if (condition) { ... } else if (condition) { ... } else { ... } switch(n) { case 1: code block break; case 2: code block break; default: code default block } for (var=startvalue; var \u003c= endvalue; var+var+increment) { code; } for (var in object) { code; } do { code; } while (var \u003c= endval); while (expression) { code; } ","date":"2020-08-18","objectID":"/notes/javascript/javascriptstudynotes/:1:3","tags":["Javascript"],"title":"Javascript Study Notes","uri":"/notes/javascript/javascriptstudynotes/"},{"categories":["Javascript Language"],"content":"Implicit Type Conversion “3” can be converted by 3 implicitly ","date":"2020-08-18","objectID":"/notes/javascript/javascriptstudynotes/:1:4","tags":["Javascript"],"title":"Javascript Study Notes","uri":"/notes/javascript/javascriptstudynotes/"},{"categories":["Javascript Language"],"content":"Strict equality === and !== Check both type and value without type conversion ","date":"2020-08-18","objectID":"/notes/javascript/javascriptstudynotes/:1:5","tags":["Javascript"],"title":"Javascript Study Notes","uri":"/notes/javascript/javascriptstudynotes/"},{"categories":["Javascript Language"],"content":"1.4. Functions Function can be defined as: function func_name(var1, var2, ... ) { some code } The variables declared within a function is local to the function. ","date":"2020-08-18","objectID":"/notes/javascript/javascriptstudynotes/:1:6","tags":["Javascript"],"title":"Javascript Study Notes","uri":"/notes/javascript/javascriptstudynotes/"},{"categories":["Javascript Language"],"content":"1.5. Event Every element on a web page has certain events which can trigger a JavaScript. Examples such as: onLoad and onUnload: triggered when user enters or leaves the page onFocus, onBlur, and onChange: often used in combination with validation of form field. \u003cinput type=\"text\" size=\"30\" id=\"email\" onchange=\"checkEmail()\"\u003e onMouseOver and onMouseOut - often used to create animated button ","date":"2020-08-18","objectID":"/notes/javascript/javascriptstudynotes/:1:7","tags":["Javascript"],"title":"Javascript Study Notes","uri":"/notes/javascript/javascriptstudynotes/"},{"categories":["Java Language"],"content":"Java Jackson\u0026Json notes","date":"2019-08-30","objectID":"/notes/java/java_jackson/","tags":["Java"],"title":"Java Notes(19) Jackson","uri":"/notes/java/java_jackson/"},{"categories":["Java Language"],"content":"Java Hibernate notes","date":"2019-08-29","objectID":"/notes/java/java_hibernate/","tags":["Java"],"title":"Java Notes(18) Hibernate","uri":"/notes/java/java_hibernate/"},{"categories":["Java Language"],"content":"Java JDBC reference notes","date":"2019-08-27","objectID":"/notes/java/java_jdbc/","tags":["Java"],"title":"Java Notes(17) JDBC","uri":"/notes/java/java_jdbc/"},{"categories":["Java Language"],"content":"Java String reference notes","date":"2019-07-26","objectID":"/notes/java/java_string/","tags":["Java"],"title":"Java Notes(8) String","uri":"/notes/java/java_string/"},{"categories":["Java Language"],"content":"String, in general, is a sequence of characters. But in Java, string is an object that represents a sequence of character. CharSequence Interface: The CharSequence interface is used to represent the sequence of characters. The Charsequence interface is extended in three class namely String, StringBuffer, and StringBuilder classes. ","date":"2019-07-26","objectID":"/notes/java/java_string/:0:0","tags":["Java"],"title":"Java Notes(8) String","uri":"/notes/java/java_string/"},{"categories":["Java Language"],"content":"String Class By String literal String s1 = \"Welcome\"; // This doesn't create a new instance. String s2 = \"Welcome\"; In the above example, only one object will be created. Firstly, JVM will not find any string object with the value “Welcome” in string constant pool, that is why it will create a new object. After that it will find the string with the value “Welcome” in the pool, it will not create a new object but will return the reference to the same instance. This results that both s1 == s2 and s1.equal(s2) return true value. By new Keyword String s1=new String(\"Welcome\"); String s2=new String(\"Welcome\"); s1 == s2 // return false s1.equal(s2) // return true In the above example, object will be created. There is some ambiguity of whether one or two object is created. In case of only one object being created, the object is created in non-pool heap memory. In case of two objects being created, the objects are created in both non-pool heap memory and and string constant pool. //A new object is created if we modify the string s2=s2.concat(\"world\"); It will waste time and computation if we constantly modify the string. Thus, two new classes are introduced. ","date":"2019-07-26","objectID":"/notes/java/java_string/:0:1","tags":["Java"],"title":"Java Notes(8) String","uri":"/notes/java/java_string/"},{"categories":["Java Language"],"content":"StringBuffer Class String buffer is slower than StringBuilder class but it is thread safe public class Test{ public static void main(String args[]){ StringBuffer sBuffer = new StringBuffer(\"ABC\"); sBuffer.append(\"DEF\"); sBuffer.append(\"GHI\"); sBuffer.append(\"JKL\"); System.out.println(sBuffer); } } ","date":"2019-07-26","objectID":"/notes/java/java_string/:0:2","tags":["Java"],"title":"Java Notes(8) String","uri":"/notes/java/java_string/"},{"categories":["Java Language"],"content":"StringBuilder Class String builder is fast but not thread safe. public class Test{ public static void main(String args[]){ StringBuilder sBuilder=new StringBuilder(\"ABC\"); sBuffer.append(\"DEF\"); sBuffer.append(\"GHI\"); sBuffer.append(\"JKL\"); System.out.println(sBuilder); } } ","date":"2019-07-26","objectID":"/notes/java/java_string/:0:3","tags":["Java"],"title":"Java Notes(8) String","uri":"/notes/java/java_string/"},{"categories":["Java Language"],"content":"Adapter","date":"2020-10-23","objectID":"/notes/javadesignpatten/adapter/","tags":["Java"],"title":"Design Pattern Notes","uri":"/notes/javadesignpatten/adapter/"},{"categories":["Java Language"],"content":"Overview Adapter is classified as a structural design pattern. This design pattern is also known as wrapper ","date":"2020-10-23","objectID":"/notes/javadesignpatten/adapter/:1:0","tags":["Java"],"title":"Design Pattern Notes","uri":"/notes/javadesignpatten/adapter/"},{"categories":["Java Language"],"content":"Intent Convert the interface of a class into another interface the clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces. ","date":"2020-10-23","objectID":"/notes/javadesignpatten/adapter/:2:0","tags":["Java"],"title":"Design Pattern Notes","uri":"/notes/javadesignpatten/adapter/"},{"categories":["Java Language"],"content":"Explanation Wikipedia In software engineering, the adapter pattern is a software design pattern that allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code. In plain words Adapter pattern lets you wrap an otherwise incompatible object in an adapter to make it compatible with another class. Real world example Consider that you have some pictures in your memory card and you need to transfer them to your computer. In order to transfer them you need some kind of adapter that is compatible with your computer ports so that you can attach memory card to your computer. In this case card reader is an adapter. Another example would be the famous power adapter; a three legged plug can’t be connected to a two pronged outlet, it needs to use a power adapter that makes it compatible with the two pronged outlet. Yet another example would be a translator translating words spoken by one person to another Programmatic Example Consider a captain that can only use rowing boats and cannot sail at all. First we have interfaces RowingBoat and FishingBoat public interface RowingBoat { void row(); } public class FishingBoat { private static final Logger LOGGER = LoggerFactory.getLogger(FishingBoat.class); public void sail() { LOGGER.info(\"The fishing boat is sailing\"); } } And captain expects an implementation of RowingBoat interface to be able to move public class Captain { private final RowingBoat rowingBoat; // default constructor and setter for rowingBoat public Captain(RowingBoat rowingBoat) { this.rowingBoat = rowingBoat; } public void row() { rowingBoat.row(); } } Now let’s say the pirates are coming and our captain needs to escape but there is only fishing boat available. We need to create an adapter that allows the captain to operate the fishing boat with his rowing boat skills. public class FishingBoatAdapter implements RowingBoat { private static final Logger LOGGER = LoggerFactory.getLogger(FishingBoatAdapter.class); private final FishingBoat boat; public FishingBoatAdapter() { boat = new FishingBoat(); } @Override public void row() { boat.sail(); } } And now the Captain can use the FishingBoat to escape the pirates. var captain = new Captain(new FishingBoatAdapter()); captain.row(); ","date":"2020-10-23","objectID":"/notes/javadesignpatten/adapter/:3:0","tags":["Java"],"title":"Design Pattern Notes","uri":"/notes/javadesignpatten/adapter/"},{"categories":["Java Language"],"content":"Class diagram Adapter class diagramalt text \" Adapter class diagram ","date":"2020-10-23","objectID":"/notes/javadesignpatten/adapter/:4:0","tags":["Java"],"title":"Design Pattern Notes","uri":"/notes/javadesignpatten/adapter/"},{"categories":["Java Language"],"content":"Applicability Use the Adapter pattern when you want to use an existing class, and its interface does not match the one you need you want to create a reusable class that cooperates with unrelated or unforeseen classes, that is, classes that don’t necessarily have compatible interfaces you need to use several existing subclasses, but it’s impractical to adapt their interface by subclassing every one. An object adapter can adapt the interface of its parent class. most of the applications using third party libraries use adapters as a middle layer between the application and the 3rd party library to decouple the application from the library. If another library has to be used only an adapter for the new library is required without having to change the application code. ","date":"2020-10-23","objectID":"/notes/javadesignpatten/adapter/:5:0","tags":["Java"],"title":"Design Pattern Notes","uri":"/notes/javadesignpatten/adapter/"},{"categories":["Java Language"],"content":"Consequences: Class and object adapters have different trade-offs. A class adapter adapts Adaptee to Target by committing to a concrete Adaptee class. As a consequence, a class adapter won’t work when we want to adapt a class and all its subclasses. let’s Adapter override some of Adaptee’s behavior, since Adapter is a subclass of Adaptee. introduces only one object, and no additional pointer indirection is needed to get to the adaptee. An object adapter let’s a single Adapter work with many Adaptees—that is, the Adaptee itself and all of its subclasses (if any). The Adapter can also add functionality to all Adaptees at once. makes it harder to override Adaptee behavior. It will require subclassing Adaptee and making Adapter refer to the subclass rather than the Adaptee itself. ","date":"2020-10-23","objectID":"/notes/javadesignpatten/adapter/:6:0","tags":["Java"],"title":"Design Pattern Notes","uri":"/notes/javadesignpatten/adapter/"},{"categories":["Java Language"],"content":"Java Lambda notes","date":"2019-10-02","objectID":"/notes/java/java_8/","tags":["Java"],"title":"Java Notes(24) Lambda ","uri":"/notes/java/java_8/"},{"categories":["Java Language"],"content":"Java Lambda notes","date":"2019-10-02","objectID":"/notes/mobiledevelopement/deeplink/","tags":["Java"],"title":"Java Notes(24) Lambda ","uri":"/notes/mobiledevelopement/deeplink/"},{"categories":["Java Language"],"content":"Java Stream notes","date":"2019-10-02","objectID":"/notes/java/java_stream/","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"A stream represents a sequence of elements and supports different kind of operations to perform computations upon those elements: List\u003cString\u003e myList = Arrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\"); myList .stream() .filter(s -\u003e s.startsWith(\"c\")) .map(String::toUpperCase) .sorted() .forEach(System.out::println); ","date":"2019-10-02","objectID":"/notes/java/java_stream/:0:0","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Stream Creation Calling the method stream() on a list of objects returns a regular object stream. Arrays.asList(\"a1\", \"a2\", \"a3\") .stream() .findFirst() .ifPresent(System.out::println); But we don’t have to create collections in order to work with streams as we see in the next code sample Stream.of(). Stream.of(\"a1\", \"a2\", \"a3\") .findFirst() .ifPresent(System.out::println); // a1 Stream.of() to create a stream from a bunch of object references. ","date":"2019-10-02","objectID":"/notes/java/java_stream/:1:0","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Primitive Streams Besides regular object streams Java 8 ships with special kinds of streams for working with the primitive data types int, long and double. As you might have guessed it’s IntStream, LongStream and DoubleStream. IntStreams can replace the regular for-loop utilizing IntStream.range(): IntStream.range(1, 4) .forEach(System.out::println); ","date":"2019-10-02","objectID":"/notes/java/java_stream/:1:1","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Empty Stream Stream\u003cString\u003e streamEmpty = Stream.empty(); public Stream\u003cString\u003e streamOf(List\u003cString\u003e list) { return list == null || list.isEmpty() ? Stream.empty() : list.stream(); } ","date":"2019-10-02","objectID":"/notes/java/java_stream/:1:2","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Stream of Collection Collection\u003cString\u003e collection = Arrays.asList(\"a\", \"b\", \"c\"); Stream\u003cString\u003e streamOfCollection = collection.stream(); ","date":"2019-10-02","objectID":"/notes/java/java_stream/:1:3","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Stream of Array Array can also be a source of a Stream: Stream\u003cString\u003e streamOfArray = Stream.of(\"a\", \"b\", \"c\"); They can also be created out of an existing array or of a part of an array: String[] arr = new String[]{\"a\", \"b\", \"c\"}; Stream\u003cString\u003e streamOfArrayFull = Arrays.stream(arr); Stream\u003cString\u003e streamOfArrayPart = Arrays.stream(arr, 1, 3); ","date":"2019-10-02","objectID":"/notes/java/java_stream/:1:4","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Stream.builder() When builder is used the desired type should be additionally specified in the right part of the statement, otherwise the build() method will create an instance of the Stream: Stream\u003cString\u003e streamBuilder = Stream.\u003cString\u003ebuilder().add(\"a\").add(\"b\").add(\"c\").build(); ","date":"2019-10-02","objectID":"/notes/java/java_stream/:1:5","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Stream.generate() The generate() method accepts a Supplier for element generation. As the resulting stream is infinite, developer should specify the desired size or the generate() method will work until it reaches the memory limit: Stream\u003cString\u003e streamGenerated = Stream.generate(() -\u003e \"element\").limit(10); ","date":"2019-10-02","objectID":"/notes/java/java_stream/:1:6","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Stream.iterate() Another way of creating an infinite stream is by using the iterate() method: Stream\u003cInteger\u003e streamIterated = Stream.iterate(40, n -\u003e n + 2).limit(20); The first element of the resulting stream is a first parameter of the iterate() method. For creating every following element the specified function is applied to the previous element. In the example above the second element will be 42. ","date":"2019-10-02","objectID":"/notes/java/java_stream/:1:7","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Stream of Primitives Java 8 offers a possibility to create streams out of three primitive types: int, long and double. As Stream is a generic interface and there is no way to use primitives as a type parameter with generics, three new special interfaces were created: IntStream, LongStream, DoubleStream. Using the new interfaces alleviates unnecessary auto-boxing allows increased productivity: IntStream intStream = IntStream.range(1, 3); LongStream longStream = LongStream.rangeClosed(1, 3); The range(int startInclusive, int endExclusive) method creates an ordered stream from the first parameter to the second parameter. It increments the value of subsequent elements with the step equal to 1. The result doesn’t include the last parameter, it is just an upper bound of the sequence. The rangeClosed(int startInclusive, int endInclusive) method does the same with only one difference – the second element is included. These two methods can be used to generate any of the three types of streams of primitives. Since Java 8 the Random class provides a wide range of methods for generation streams of primitives. For example, the following code creates a DoubleStream, which has three elements: Random random = new Random(); DoubleStream doubleStream = random.doubles(3); ","date":"2019-10-02","objectID":"/notes/java/java_stream/:1:8","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Stream of String String can also be used as a source for creating a stream. With the help of the chars() method of the String class. Since there is no interface CharStream in JDK, the IntStream is used to represent a stream of chars instead. IntStream streamOfChars = \"abc\".chars(); The string can be breaked into substring according to specified RegEx: Stream\u003cString\u003e streamOfString = Pattern.compile(\", \").splitAsStream(\"a, b, c\"); ","date":"2019-10-02","objectID":"/notes/java/java_stream/:1:9","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Stream of File Java NIO class Files allows to generate a Stream of a text file through the lines() method. Every line of the text becomes an element of the stream: Path path = Paths.get(\"C:\\\\file.txt\"); Stream\u003cString\u003e streamOfStrings = Files.lines(path); Stream\u003cString\u003e streamWithCharset = Files.lines(path, Charset.forName(\"UTF-8\")); The Charset can be specified as an argument of the lines() method. List\u003cString\u003e strings = Arrays.asList(\"abc\", \"\", \"bc\", \"efg\", \"abcd\",\"\", \"jkl\"); List\u003cString\u003e filtered = strings.stream().filter(string -\u003e !string.isEmpty()).collect(Collectors.toList()); ","date":"2019-10-02","objectID":"/notes/java/java_stream/:1:10","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Intermediate and Termial Operation Stream operations are either intermediate or terminal. Intermediate operations return a stream so we can chain multiple intermediate operations without using semicolons. Terminal operations are either void or return a non-stream result. In the above example filter, map and sorted are intermediate operations whereas forEach is a terminal operation. Streams can be created from various data sources, especially collections. Lists and Sets support new methods stream() and parallelStream() to either create a sequential or a parallel stream. ","date":"2019-10-02","objectID":"/notes/java/java_stream/:2:0","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Intermediate Operation map(mapToInt,mapToLong,mapToDouble) It allows elements of a Stream to be transformed into something else by mapping them to another value or type flatmap(flatmapToInt,flatmapToLong,flatmapToDouble): It taking a Function that goes from a type T to a return type R. Thre result stream are flattened. limit it creates a new stream that only contains the first n elements of the stream it is applied on. distint filter out any duplicates by using equal method filter: Filter elements out in a stream. Skip：Skip the number of elements in the device peek 挑出操作，如果想对数据进行某些操作，如：读取、编辑修改等。 sorted: Sorted by using natural order or defined comparator. ","date":"2019-10-02","objectID":"/notes/java/java_stream/:2:1","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Termial Operation collect: To build data structures containing a specific collection of elements. Collect to Set .collect(Collectors.toSet()) Collect to List .collect(Collectors.toList()) Collect to General Collection .collect(Collectors.toCollection(LinkedList::new)) .collect(Collectors.toCollection(LinkedHashSet::new)) .collect(Collectors.toCollection(PriorityQueue::new)) Collect to Array .toArray(String[]::new) Collect to Map Collectors.toMap() takes two Functions corresponding to a key-mapper and a value-mapper .collect(Collectors.toMap(,)) Collect GroupingBy There is a very useful Collector named groupingBy() which divides the elements into different groups, depending on some property whereby the property is extracted by something called a “classifier”. .collect(Collectors.groupingBy(,)) Collect GroupingBy Using Downstream Collector There is an overloaded version of groupingBy() that allows the use of a custom “downstream collector” to get better control over the resulting Map. Below is an example of how the special downstream collector counting() is applied to count, rather than collecting, the elements of each bucket. .collect(Collectors.groupingBy(s -\u0026gt;s.charAt(0),counting())) count count the number of element in a Stream. findFirst、findAny 查找操作，查找第一个、查找任何一个 返回的类型为Optional。 noneMatch、allMatch、anyMatch 匹配操作，数据流中是否存在符合条件的元素 返回值为bool 值。 min,max,average: return the aggregate value of a stream reduce 规约操作，将整个数据流的值规约为一个值，count、min、max底层就是使用reduce。 forEach、forEachOrdered: They both take a Consumer and terminates the Stream without returning anything. toArray 数组操作，将数据流的元素转换成数组。 anyMatch(): return a boolean to see if the value existed ","date":"2019-10-02","objectID":"/notes/java/java_stream/:2:2","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Reference Java 8 Stream Tutorial https://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/ Become a Master of Java Streams, Part 3: Terminal Operations https://dzone.com/articles/become-a-master-of-java-streams-part-1-creating-st https://dzone.com/articles/become-a-master-of-java-streams-part-2-intermediat https://dzone.com/articles/become-a-master-of-java-streams-part-3-terminal-op ","date":"2019-10-02","objectID":"/notes/java/java_stream/:3:0","tags":["Java"],"title":"Java Notes(25) Stream ","uri":"/notes/java/java_stream/"},{"categories":["Java Language"],"content":"Java optional notes","date":"2019-09-28","objectID":"/notes/java/java_optional/","tags":["Java"],"title":"Java Notes(23) Optional class","uri":"/notes/java/java_optional/"},{"categories":["Java Language"],"content":"Optional class is a container for null. ","date":"2019-09-28","objectID":"/notes/java/java_optional/:0:0","tags":["Java"],"title":"Java Notes(23) Optional class","uri":"/notes/java/java_optional/"},{"categories":["Java Language"],"content":"Optional class Declartion public final class Optional\u003cT\u003e extends Object ","date":"2019-09-28","objectID":"/notes/java/java_optional/:0:1","tags":["Java"],"title":"Java Notes(23) Optional class","uri":"/notes/java/java_optional/"},{"categories":["Java Language"],"content":"Optional class method Return an empty option class static \u003cT\u003e Optional\u003cT\u003e empty() Example: @Test public void whenCreatesEmptyOptional_thenCorrect() { Optional\u003cString\u003e empty = Optional.empty(); assertFalse(empty.isPresent()); } 判断其他对象是否等于Optional boolean equals(Object obj) optionObject.filter() Filter takes a predicate as an argument and returns an Optional object. If the wrapped value passes testing by the predicate, then the Optional is returned as-is. if the predicate returns false, then it will return an empty Optional: Optional\u003cT\u003e filter(Predicate\u003c? super \u003cT\u003e predicate) Example: @Test public void whenOptionalFilterWorks_thenCorrect() { Integer year = 2016; Optional\u003cInteger\u003e yearOptional = Optional.of(year); boolean is2016 = yearOptional.filter(y -\u003e y == 2016).isPresent(); assertTrue(is2016); boolean is2017 = yearOptional.filter(y -\u003e y == 2017).isPresent(); assertFalse(is2017); } public boolean priceIsInRange2(Modem modem2) { return Optional.ofNullable(modem2) .map(Modem::getPrice) .filter(p -\u003e p \u003e= 10) .filter(p -\u003e p \u003c= 15) .isPresent(); } flatMap() flatMap is similiar to map method. The difference is that map transforms values only when they are unwrapped whereas flatMap takes a wrapped value and unwraps it before transforming it. \u003cU\u003e Optional\u003cU\u003e flatMap(Function\u003c? super T,Optional\u003cU\u003e\u003e mapper) public class Person { private String name; private int age; private String password; public Optional\u003cString\u003e getName() { return Optional.ofNullable(name); } public Optional\u003cInteger\u003e getAge() { return Optional.ofNullable(age); } public Optional\u003cString\u003e getPassword() { return Optional.ofNullable(password); } // normal constructors and setters } Normal way of creating object Person person = new Person(\"john\", 26); Optional\u003cPerson\u003e personOptional = Optional.of(person); @Test public void givenOptional_whenFlatMapWorks_thenCorrect2() { Person person = new Person(\"john\", 26); Optional\u003cPerson\u003e personOptional = Optional.of(person); Optional\u003cOptional\u003cString\u003e\u003e nameOptionalWrapper = personOptional.map(Person::getName); Optional\u003cString\u003e nameOptional = nameOptionalWrapper.orElseThrow(IllegalArgumentException::new); String name1 = nameOptional.orElse(\"\"); assertEquals(\"john\", name1); String name = personOptional .flatMap(Person::getName) .orElse(\"\"); assertEquals(\"john\", name); } optionObject.get() This method is to get the value inside Optional container The purpose of Optional is to avoid any unforeseen exceptions. However, this method is against the purpose of optional T get() @Test public void givenOptional_whenGetsValue_thenCorrect() { Optional\u003cString\u003e opt = Optional.of(\"baeldung\"); String name = opt.get(); assertEquals(\"baeldung\", name); } If get value is null @Test(expected = NoSuchElementException.class) public void givenOptionalWithNull_whenGetThrowsException_thenCorrect() { Optional\u003cString\u003e opt = Optional.ofNullable(null); String name = opt.get(); } 返回存在值的哈希码，如果值不存在 返回 0。 int hashCode() optionObject.ifPresent() This method is to replace the null check in Java void ifPresent(Consumer\u003c? super T\u003e consumer) Example: @Test public void givenOptional_whenIfPresentWorks_thenCorrect() { Optional\u003cString\u003e opt = Optional.of(\"Test\"); opt.ifPresent(name -\u003e System.out.println(name.length())); } optionObject.isPresent() This method will return true if the value is presented in Option boolean isPresent() Example: @Test public void givenOptional_whenIsPresentWorks_thenCorrect() { Optional\u003cString\u003e opt = Optional.of(\"Test\"); assertTrue(opt.isPresent()); opt = Optional.ofNullable(null); assertFalse(opt.isPresent()); } in Java 11, we can use isEmpty method @Test public void givenAnEmptyOptional_thenIsEmptyBehavesAsExpected() { Optional\u003cString\u003e opt = Optional.of(\"Baeldung\"); assertFalse(opt.isEmpty()); opt = Optional.ofNullable(null); assertTrue(opt.isEmpty()); } optionalObject.map() The map method returns the result of the computation wrapped inside a Optional. The value passing in the map bracket should not be option. Otherwise flagMap() should be used. \u003cU\u003eO","date":"2019-09-28","objectID":"/notes/java/java_optional/:0:2","tags":["Java"],"title":"Java Notes(23) Optional class","uri":"/notes/java/java_optional/"},{"categories":["Java Language"],"content":"Java logging notes","date":"2019-09-12","objectID":"/notes/java/java_logging/","tags":["Java"],"title":"Java Notes(21) Logging","uri":"/notes/java/java_logging/"},{"categories":["Java Language"],"content":"JavaDoc notes","date":"2019-09-10","objectID":"/notes/java/java_doc/","tags":["Java"],"title":"Java Notes(20) JavaDoc","uri":"/notes/java/java_doc/"},{"categories":["Java Language"],"content":"Maven notes","date":"2019-08-24","objectID":"/notes/java/java_maven/","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"Core Concepts of Maven: POM Files: Project Object Model(POM) Files are XML file that contains information related to the project and configuration information such as dependencies, source directory, plugin, goals etc. used by Maven to build the project. When you should execute a maven command you give maven a POM file to execute the commands. Maven reads pom.xml file to accomplish its configuration and operations. Dependencies and Repositories: Dependencies are external Java libraries required for Project and repositories are directories of packaged JAR files. The local repository is just a directory on your machine hard drive. If the dependencies are not found in the local Maven repository, Maven downloads them from a central Maven repository and puts them in your local repository. Build Life Cycles, Phases and Goals: A build life cycle consists of a sequence of build phases, and each build phase consists of a sequence of goals. Maven command is the name of a build lifecycle, phase or goal. If a lifecycle is requested executed by giving maven command, all build phases in that life cycle are executed also. If a build phase is requested executed, all build phases before it in the defined sequence are executed too. Build Profiles: Build profiles a set of configuration values which allows you to build your project using different configurations. For example, you may need to build your project for your local computer, for development and test. To enable different builds you can add different build profiles to your POM files using its profiles elements and are triggered in the variety of ways. Build Plugins: Build plugins are used to perform specific goal. you can add a plugin to the POM file. Maven has some standard plugins you can use, and you can also implement your own in Java. ","date":"2019-08-24","objectID":"/notes/java/java_maven/:1:0","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"Pom File POM means Project Object Model is key to operate Maven. Maven reads pom.xml file to accomplish its configuration and operations. It is an XML file that contains information related to the project and configuration information such as dependencies, source directory, plugin, goals etc. used by Maven to build the project. \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003e com.project.loggerapi \u003c/groupId\u003e \u003cartifactId\u003eLoggerApi\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c!-- Add typical dependencies for a web application --\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-api\u003c/artifactId\u003e \u003cversion\u003e2.11.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e Elements used for Creating pom.xml file project - It is the root element of the pom.xml file. modelVersion - modelversion means what version of the POM model you are using. Use version 4.0.0 for maven 2 and maven 3. groupId - groupId means the id for the project group. It is unique and Most often you will use a group ID which is similar to the root Java package name of the project like we used the groupId com.project.loggerapi. artifactId - artifactId used to give name of the project you are building.in our example name of our project is LoggerApi. version - version element contains the version number of the project. If your project has been released in different versions then it is useful to give version of your project. Other Elements of Pom.xml file dependencies - dependencies element is used to defines a list of dependency of project. dependency - dependency defines a dependency and used inside dependencies tag. Each dependency is described by its groupId, artifactId and version. name - this element is used to give name to our maven project. scope - this element used to define scope for this maven project that can be compile, runtime, test, provided system etc. packaging - packaging element is used to packaging our project to output types like JAR, WAR etc. ","date":"2019-08-24","objectID":"/notes/java/java_maven/:2:0","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"Dependency Scopes ","date":"2019-08-24","objectID":"/notes/java/java_maven/:3:0","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"Compile This is the default scope when no other scope is provided. Dependencies with this scope are available on the classpath of the project in all build tasks and they’re propagated to the dependent projects. More importantly, these dependencies are also transitive: \u003cdependency\u003e \u003cgroupId\u003ecommons-lang\u003c/groupId\u003e \u003cartifactId\u003ecommons-lang\u003c/artifactId\u003e \u003cversion\u003e2.6\u003c/version\u003e \u003c/dependency\u003e ","date":"2019-08-24","objectID":"/notes/java/java_maven/:3:1","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"Provided This scope is used to mark dependencies that should be provided at runtime by JDK or a container, hence the name. A good use case for this scope would be a web application deployed in some container, where the container already provides some libraries itself. For example, a web server that already provides the Servlet API at runtime, thus in our project, those dependencies can be defined with the provided scope: \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet\u003c/groupId\u003e \u003cartifactId\u003eservlet-api\u003c/artifactId\u003e \u003cversion\u003e2.5\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e The provided dependencies are available only at compile-time and in the test classpath of the project; what’s more, they aren’t transitive. ","date":"2019-08-24","objectID":"/notes/java/java_maven/:3:2","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"Runtime The dependencies with this scope are required at runtime, but they’re not needed for compilation of the project code. Because of that, dependencies marked with the runtime scope will be present in runtime and test classpath, but they will be missing from compile classpath. A good example of dependencies that should use the runtime scope is a JDBC driver: \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e6.0.6\u003c/version\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e ","date":"2019-08-24","objectID":"/notes/java/java_maven/:3:3","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"Test This scope is used to indicate that dependency isn’t required at standard runtime of the application, but is used only for test purposes. Test dependencies aren’t transitive and are only present for test and execution classpaths. The standard use case for this scope is adding test library like JUnit to our application: \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e ","date":"2019-08-24","objectID":"/notes/java/java_maven/:3:4","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"System System scope is much similar to the provided scope. The main difference between those two scopes is that system requires us to directly point to specific jar on the system. The important thing to remember is that building the project with system scope dependencies may fail on different machines if dependencies aren’t present or are located in a different place than the one systemPath points to: \u003cdependency\u003e \u003cgroupId\u003ecom.baeldung\u003c/groupId\u003e \u003cartifactId\u003ecustom-dependency\u003c/artifactId\u003e \u003cversion\u003e1.3.2\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/libs/custom-dependency-1.3.2.jar\u003c/systemPath\u003e \u003c/dependency\u003e ","date":"2019-08-24","objectID":"/notes/java/java_maven/:3:5","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"Import This scope was added in Maven 2.0.9 and it’s only available for the dependency type pom. We’re going to speak more about the type of the dependency in future articles. Import indicates that this dependency should be replaced with all effective dependencies declared in it’s POM: \u003cdependency\u003e \u003cgroupId\u003ecom.baeldung\u003c/groupId\u003e \u003cartifactId\u003ecustom-project\u003c/artifactId\u003e \u003cversion\u003e1.3.2\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e ","date":"2019-08-24","objectID":"/notes/java/java_maven/:3:6","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"Dependency and Transitivity Maven avoids the need to discover and specify the libraries that your own dependencies require by including transitive dependencies automatically. Dependency management - this allows project authors to directly specify the versions of artifacts to be used when they are encountered in transitive dependencies or in dependencies where no version has been specified. Dependency mediation - this determines what version of an artifact will be chosen when multiple versions are encountered as dependencies. Maven picks the “nearest definition”. If the path are same in length, then it will depends on which version comes first. A better approach is to specify the version in property file lik below. ","date":"2019-08-24","objectID":"/notes/java/java_maven/:4:0","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"Scope and Transitivity Each dependency scope affects transitive dependencies in its own way. This means that different transitive dependencies may end up in the project with different scopes. However, dependencies with scopes provided and test will never be included in the main project. Then: For the compile scope, all dependencies with runtime scope will be pulled in with the runtime scope, in the project and all dependencies with the compile scope will be pulled in with the compile scope, in the project For the provided scope, both runtime and compile scope dependencies will be pulled in with the provided scope, in the project For the test scope, both runtime and compile scope transitive dependencies will be pulled in with the test scope, in the project For the runtime scope, both runtime and compile scope transitive dependencies will be pulled in with the runtime scope, in the project ","date":"2019-08-24","objectID":"/notes/java/java_maven/:5:0","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"Maven Repositories Maven repositories are directories of packaged JAR files with some metadata. The metadata are POM files related to the projects each packaged JAR file belongs to, including what external dependencies each packaged JAR has. This metadata enables Maven to download dependencies of your dependencies recursively until all dependencies are download and put into your local machine. Maven has three types of repository : Local repository - A local repository is a directory on the machine of developer. This repository contains all the dependencies Maven downloads. Maven only needs to download the dependencies once, even if multiple projects depends on them (e.g. ODBC). By default, maven local repository is user_home/m2 directory. example – C:\\Users\\asingh.m2 Central repository - The central Maven repository is created Maven community. Maven looks in this central repository for any dependencies needed but not found in your local repository. Maven then downloads these dependencies into your local repository. You can view central repository by this link. Remote repository - remote repository is a repository on a web server from which Maven can download dependencies.it often used for hosting projects internal to organization. Maven then downloads these dependencies into your local repository. Maven searches for dependencies in this repositories. First maven searches in Local repository then Central repository then Remote repository if Remote repository specified in the POM. Reference: https://www.geeksforgeeks.org/introduction-apache-maven-build-automation-tool-java-projects/#:~:text=Maven%20is%20a%20powerful%20project,the%20build%20process%20like%20ANT.\u0026text=In%20short%20terms%20we%20can,managing%20any%20Java%2Dbased%20project. ","date":"2019-08-24","objectID":"/notes/java/java_maven/:6:0","tags":["Java"],"title":"Java Notes(16) Maven","uri":"/notes/java/java_maven/"},{"categories":["Java Language"],"content":"Java file I/O reference notes","date":"2019-07-27","objectID":"/notes/java/java_file_io/","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"The java.io package contains nearly every class required to perform input and output (I/O) in Java. All these streams represent an input source and an output destination. The stream in the java.io package supports many data such as primitives, object, localized characters, etc. Java provides strong and flexible support for I/O related to files and networks. ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:0:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"The Hierarchy of I/O Class in Java ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:1:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"Stream A stream can be defined as a sequence of data. There are two kinds of Streams : InputStream − The InputStream is used to read data from a source. OutputStream − The OutputStream is used for writing data to a destination. ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:2:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"Byte Streams Java byte streams are used to perform input and output of 8-bit bytes. Though there are many classes related to byte streams but the most frequently used classes are, FileInputStream and FileOutputStream. ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:2:1","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"Character Streams Java Byte streams are used to perform input and output of 8-bit bytes, whereas Java Character streams are used to perform input and output for 16-bit unicode. Though there are many classes related to character streams but the most frequently used classes are, FileReader and FileWriter. Though internally FileReader uses FileInputStream and FileWriter uses FileOutputStream but here the major difference is that FileReader reads two bytes at a time and FileWriter writes two bytes at a time. ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:2:2","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"Why there are Byte and Character Streams A stream is a way of sequentially accessing a file. A byte stream access the file byte by byte. A byte stream is suitable for any kind of file, however not quite appropriate for text files. For example, if the file is using a unicode encoding and a character is represented with two bytes, the byte stream will treat these separately and you will need to do the conversion yourself. A character stream will read a file character by character. A character stream needs to be given the file’s encoding in order to work properly. ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:3:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"Standard Streams All the programming languages provide support for standard I/O where the user’s program can take input from a keyboard and then produce an output on the computer screen. Java provides the following three standard streams Standard Input − This is used to feed the data to user's program and usually a keyboard is used as standard input stream and represented as System.in. Standard Output − This is used to output the data produced by the user's program and usually a computer screen is used for standard output stream and represented as System.out. Standard Error − This is used to output the error data produced by the user's program and usually a computer screen is used for standard error stream and represented as System.err. ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:4:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"Reading and Writing Files The InputStream is used to read data from a source and the OutputStream is used for writing data to a destination. The two important streams are FileInputStream and FileOutputStream. ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:5:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"FileInputStream This stream is used for reading data from the files. Objects can be created using the keyword new and there are several types of constructors available. Following constructor takes a file name as a string to create an input stream object to read the file. InputStream f = new FileInputStream(\"C:/java/hello\"); Following constructor takes a file object to create an input stream object to read the file. First we create a file object using File() method. File f = new File(\"C:/java/hello\"); InputStream f = new FileInputStream(f); Once you have InputStream object, You can use various methods : Sr.No. Method \u0026 Description 1 public void close() throws IOException{} This method closes the file output stream. Releases any system resources associated with the file. Throws an IOException. 2 protected void finalize()throws IOException {} This method cleans up the connection to the file. Ensures that the close method of this file output stream is called when there are no more references to this stream. Throws an IOException. 3 public int read(int r)throws IOException{} This method reads the specified byte of data from the InputStream. Returns an int. Returns the next byte of data and -1 will be returned if it's the end of the file. 4 public int read(byte[] r) throws IOException{} This method reads r.length bytes from the input stream into an array. Returns the total number of bytes read. If it is the end of the file, -1 will be returned. 5 public int available() throws IOException{} Gives the number of bytes that can be read from this file input stream. Returns an int. Other important input streams : ByteArrayInputStream DataInputStream ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:6:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"FileOutputStream FileOutputStream is used to create a file and write data into it. The stream would create a file, if it doesn’t already exist, before opening it for output. Following constructor takes a file name as a string to create an input stream object to write the file OutputStream f = new FileOutputStream(\"C:/java/hello\") Following constructor takes a file object to create an output stream object to write the file. First, we create a file object using File() method. File f = new File(\"C:/java/hello\"); OutputStream f = new FileOutputStream(f); Once you have InputStream object, You can use various methods : Sr.No. Method \u0026 Description 1 public void close() throws IOException{} This method closes the file output stream. Releases any system resources associated with the file. Throws an IOException. 2 protected void finalize()throws IOException {} This method cleans up the connection to the file. Ensures that the close method of this file output stream is called when there are no more references to this stream. Throws an IOException. 3 public void write(int w)throws IOException{} This methods writes the specified byte to the output stream. 4 public void write(byte[] w) Writes w.length bytes from the mentioned byte array to the OutputStream. Other important output streams : ByteArrayOutputStream DataOutputStream ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:7:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"Complete Example The below code would create file test.txt and would write given numbers in binary format. Same would be the output on the stdout screen. import java.io.*; public class fileStreamTest { public static void main(String args[]) { try { byte bWrite [] = {11,21,3,40,5}; OutputStream os = new FileOutputStream(\"test.txt\"); for(int x = 0; x \u003c bWrite.length ; x++) { os.write( bWrite[x] ); // writes the bytes } os.close(); InputStream is = new FileInputStream(\"test.txt\"); int size = is.available(); for(int i = 0; i \u003c size; i++) { System.out.print((char)is.read() + \" \"); } is.close(); } catch (IOException e) { System.out.print(\"Exception\"); } } } ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:8:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"Java Console Class The Java Console class is be used to get input from console. It provides methods to read texts and passwords. If you read password using Console class, it will not be displayed to the user. The java.io.Console class is attached with system console internally. Example : import java.io.Console; class ReadPasswordTest{ public static void main(String args[]){ Console c=System.console(); System.out.println(\"Enter password: \"); char[] ch=c.readPassword(); String pass=String.valueOf(ch);//converting char array into string System.out.println(\"Password is: \"+pass); } } ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:9:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"File Navigation and I/O Other classes for File Navigation and I/O. File Class FileReader Class FileWriter Class ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:10:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"Directories in Java A directory is a File which can contain a list of other files and directories. You use File object to create directories, to list down files available in a directory. ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:11:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"Creating Directories The mkdir( ) method creates a directory, returning true on success and false on failure. Failure indicates that the path specified in the File object already exists, or that the directory cannot be created because the entire path does not exist yet. The mkdirs() method creates both a directory and all the parents of the directory. Below code creates “/tmp/user/java/bin” directory. import java.io.File; public class CreateDir { public static void main(String args[]) { String dirname = \"/tmp/user/java/bin\"; File d = new File(dirname); // Create directory now. d.mkdirs(); } } NOTE : Java automatically takes care of path separators on UNIX and Windows as per conventions. If you use a forward slash (/) on a Windows version of Java, the path will still resolve correctly. ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:12:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"Listing Directories You can use list( ) method provided by File object to list down all the files and directories available in a directory as follows. import java.io.File; public class ReadDir { public static void main(String[] args) { File file = null; String[] paths; try { // create new file object file = new File(\"/tmp\"); // array of files and directory paths = file.list(); // for each name in the path array for(String path:paths) { // prints filename and directory name System.out.println(path); } } catch (Exception e) { // if any error occurs e.printStackTrace(); } } } ","date":"2019-07-27","objectID":"/notes/java/java_file_io/:13:0","tags":["Java"],"title":"Java Notes(11) File I/O","uri":"/notes/java/java_file_io/"},{"categories":["Java Language"],"content":"Java Enum notes","date":"2019-07-26","objectID":"/notes/java/java_enum/","tags":["Java"],"title":"Java Notes(10) Enum","uri":"/notes/java/java_enum/"},{"categories":["Java Language"],"content":"Java Anonymous Class notes","date":"2019-07-26","objectID":"/notes/java/java_anonymouse_class/","tags":["Java"],"title":"Java Notes(9) Nested and Anonymous Class ","uri":"/notes/java/java_anonymouse_class/"},{"categories":["Java Language"],"content":"Nested Class In Java, just like methods, variables of a class too can have another class as its member. Writing a class within another is allowed in Java. The class written within is called the nested class, and the class that holds the inner class is called the outer class. public class Outer { public class Inner { } } Outer.Inner inner = outer.new Inner(); Nested classes are divided into two categories: Non-static nested classes : Non-static nested classes could only existed if the outer class object existing. In general, an object of the inner class is always strongly associated with an outer class object. Static nested class : Nested classes that are declared static are called static nested classes. Static nested class object can exist, even if the outer class object is not existing. They are not strongly associated with outer classes. ","date":"2019-07-26","objectID":"/notes/java/java_anonymouse_class/:1:0","tags":["Java"],"title":"Java Notes(9) Nested and Anonymous Class ","uri":"/notes/java/java_anonymouse_class/"},{"categories":["Java Language"],"content":"Non-static Nested Classes Inner classes are a security mechanism in Java. We know a class cannot be associated with the access modifier private, but if we have the class as a member of other class, then the inner class can be made private. And this is also used to access the private members of a class. Non-static Nested Classes are of three types depending on how and where you define them. They are − Inner Class Method-local Inner Class Anonymous Inner Class Inner Class Inner class is most obvious. class Outer_Demo { int num; // inner class private class Inner_Demo { public void print() { System.out.println(\"This is an inner class\"); } } // Accessing he inner class from the method within void display_Inner() { Inner_Demo inner = new Inner_Demo(); inner.print(); } } public class My_class { public static void main(String args[]) { // Instantiating the outer class Outer_Demo outer = new Outer_Demo(); // Accessing the display_Inner() method. outer.display_Inner(); } } Method-local Inner Class A method-local inner class can be instantiated only within the method where the inner class is defined. public class Outerclass { // instance method of the outer class void my_Method() { int num = 23; // method-local inner class class MethodInner_Demo { public void print() { System.out.println(\"This is method inner class \"+num); } } // end of inner class // Accessing the inner class MethodInner_Demo inner = new MethodInner_Demo(); inner.print(); } public static void main(String args[]) { Outerclass outer = new Outerclass(); outer.my_Method(); } } Anonymous inner class Anonymous inner class is a class that we declare and instantiate it at same time. abstract class AnonymousInner { public abstract void mymethod(); } public class Outer_class { public static void main(String args[]) { AnonymousInner inner = new AnonymousInner() { public void mymethod() { System.out.println(\"This is an example of anonymous inner class\"); } }; inner.mymethod(); } } Anonymous inner class could also be passed as parameter of one method. // interface interface Message { String greet(); } public class My_class { // method which accepts the object of interface Message public void displayMessage(Message m) { System.out.println(m.greet() + \", This is an example of anonymous inner class as an argument\"); } public static void main(String args[]) { // Instantiating the class My_class obj = new My_class(); // Passing an anonymous inner class as an argument obj.displayMessage(new Message() { public String greet() { return \"Hello\"; } }); } } ","date":"2019-07-26","objectID":"/notes/java/java_anonymouse_class/:1:1","tags":["Java"],"title":"Java Notes(9) Nested and Anonymous Class ","uri":"/notes/java/java_anonymouse_class/"},{"categories":["Java Language"],"content":"Static Nested Class Live Demo public class Outer { static class Nested_Demo { public void my_method() { System.out.println(\"This is my nested class\"); } } public static void main(String args[]) { Outer.Nested_Demo nested = new Outer.Nested_Demo(); nested.my_method(); } } ","date":"2019-07-26","objectID":"/notes/java/java_anonymouse_class/:1:2","tags":["Java"],"title":"Java Notes(9) Nested and Anonymous Class ","uri":"/notes/java/java_anonymouse_class/"},{"categories":["Java Language"],"content":"Java Serialization reference notes","date":"2019-08-06","objectID":"/notes/java/java_synchronization/","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Synchronization in java is the capability to control the access of multiple threads to any shared resource. Java Synchronization is better option where we want to allow only one thread to access the shared resource. The synchronization is mainly used to : To prevent Thread Interference (Thread interference is a condition which occurs when more than one threads, executing simultaneously, access same piece of data.). To prevent Consistency Problem (Memory consistency errors occur when different threads have inconsistent views of what should be the same data.). ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:0:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Types of Synchronization : ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:1:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Thread Synchronization There are two types of thread synchronization mutual exclusive and inter-thread communication. Mutual Exclusive Cooperation (Inter-thread communication in java) Mutual Exclusive : Mutual Exclusive helps keep threads from interfering with one another while sharing data. This can be done by three ways in java : by synchronized method by synchronized block by static synchronization Concept of Lock in Java : Synchronization is built around an internal entity known as the lock or monitor. Every object has an lock associated with it. By convention, a thread that needs consistent access to an object’s fields has to acquire the object’s lock before accessing them, and then release the lock when it’s done with them. The package java.util.concurrent.locks contains several lock implementations. ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:2:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Synchronized Method in Java :** If you declare any method as synchronized, it is known as synchronized method. Synchronized method is used to lock an object for any shared resource. When a thread invokes a synchronized method, it automatically acquires the lock for that object and releases it when the thread completes its task. synchronized void printTable(int n){ //synchronized method for(int i=1;i\u003c=5;i++){ System.out.println(n*i); try{ Thread.sleep(200); }catch(Exception e){System.out.println(e);} } } ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:3:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Synchronized Block in Java Synchronized block can be used to perform synchronization on any specific resource of the method. Suppose you have 50 lines of code in your method, but you want to synchronize only 5 lines, you can use synchronized block. Scope of synchronized block is smaller than the method. If you put all the codes of the method in the synchronized block, it will work same as the synchronized method. Syntax - synchronized (object reference expression) { … } void printTable(int n){ synchronized(this){ //synchronized block for(int i=1;i\u003c=5;i++){ System.out.println(n*i); try{ Thread.sleep(200); }catch(Exception e){System.out.println(e);} } } } ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:4:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Static Synchronization in Java If you make any static method as synchronized, the lock will be on the class not on object. Problem without static synchronization : Suppose there are two objects of a shared class(e.g. Table) named object1 and object2.In case of synchronized method and synchronized block there cannot be interference between t1 and t2 or t3 and t4 because t1 and t2 both refers to a common object that have a single lock.But there can be interference between t1 and t3 or t2 and t4 because t1 acquires another lock and t3 acquires another lock.I want no interference between t1 and t3 or t2 and t4.Static synchronization solves this problem. synchronized static void printTable(int n){ for(int i=1;i\u003c=10;i++){ System.out.println(n*i); try{ Thread.sleep(200); }catch(Exception e){System.out.println(e);} } } ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:5:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Deadlock in Java Deadlock can occur in a situation when a thread is waiting for an object lock, that is acquired by another thread and second thread is waiting for an object lock that is acquired by first thread. Since, both threads are waiting for each other to release the lock, the condition is called deadlock. public class TestDeadlockExample1 { public static void main(String[] args) { final String resource1 = \"John\"; final String resource2 = \"Tom\"; // t1 tries to lock resource1 then resource2 Thread t1 = new Thread() { public void run() { synchronized (resource1) { System.out.println(\"Thread 1: locked resource 1\"); try { Thread.sleep(100);} catch (Exception e) {} synchronized (resource2) { System.out.println(\"Thread 1: locked resource 2\"); } } } }; // t2 tries to lock resource2 then resource1 Thread t2 = new Thread() { public void run() { synchronized (resource2) { System.out.println(\"Thread 2: locked resource 2\"); try { Thread.sleep(100);} catch (Exception e) {} synchronized (resource1) { System.out.println(\"Thread 2: locked resource 1\"); } } } }; t1.start(); t2.start(); } } Output: Thread 1: locked resource 1 Thread 2: locked resource 2 ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:6:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Inter-Thread Communication in Java Inter-thread communication or Co-operation is all about allowing synchronized threads to communicate with each other. Cooperation (Inter-thread communication) is a mechanism in which a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed. It is implemented by following 3 methods of Object class: wait() notify() notifyAll() ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:7:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"wait() Method Causes current thread to release the lock and wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed. The current thread must own this object’s monitor, so it must be called from the synchronized method only otherwise it will throw exception. public final void wait()throws InterruptedException public final void wait(long timeout)throws InterruptedException ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:7:1","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"notify() Method Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. public final void notify() ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:7:2","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"notifyAll() Method Wakes up all threads that are waiting on this object’s monitor. public final void notifyAll() ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:7:3","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Understanding the process of inter-thread communication Explanation of the above diagram : Threads enter to acquire lock. Lock is acquired by one thread. Now thread goes to waiting state if you call wait() method on the object. Otherwise, it releases the lock \u0026 exits when done. If you call notify() or notifyAll() method, thread moves to the notified state (runnable state). Now thread is available to acquire lock. After completion of the task, thread releases the lock and exits the monitor state of the object. NOTE : wait(), notify() and notifyAll() methods are defined in Object class not Thread class because they are related to lock and object has a lock. ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:8:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Difference between wait and sleep wait()sleep() wait() method releases the locksleep() method doesn't release the lock. is a method of Object classis a method of Thread class is a non-static methodis a static method should be notified by notify() or notifyAll() methodsafter the specified amount of time, sleep is completed. Sinple Example : class Customer { int amount = 10000; synchronized void withdraw(int amount) { System.out.println(\"going to withdraw...\"); if (this.amount \u003c amount) { System.out.println(\"Less balance; waiting for deposit...\"); try { wait(); } catch (Exception e) {} } // Simple Eg. So, doesn't consider if amount is again low after notify() this.amount -= amount; System.out.println(\"withdraw completed...\"); } synchronized void deposit(int amount) { System.out.println(\"going to deposit...\"); this.amount += amount; System.out.println(\"deposit completed... \"); notify(); } } class Test { public static void main(String args[]) { final Customer c = new Customer(); new Thread() { public void run() { c.withdraw(15000); }}.start(); new Thread() { public void run() { c.deposit(10000); }}.start(); } } ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:9:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Interrupting a Thread An interrupt is an indication to a thread that it should stop what it is doing and do something else. It’s up to the programmer to decide exactly how a thread responds to an interrupt, but it is very common for the thread to terminate. The 3 methods provided by the Thread class for interrupting a thread : public void interrupt() If any thread is in sleeping or waiting state (i.e. sleep() or wait()) is invoked, calling the interrupt() method on the thread, breaks out the sleeping or waiting state throwing InterruptedException. If the thread is not in the sleeping or waiting state, calling the interrupt() method performs normal behaviour and doesn’t interrupt the thread but sets the interrupt flag to true. t1.interrupt(); public static boolean interrupted() The static interrupted() method returns the interrupted flag afterthat it sets the flag to false if it is true. t1.interrupted() public boolean isInterrupted() The isInterrupted() method returns the interrupted flag either true or false. NOTE : If we interrupt a thread, and propagate the exception, it will stop working. If we don’t want to stop the thread, we should handle it where sleep() or wait() method is invoked. class TestIntrpt extends Thread { public void run() { try { Thread.sleep(1000); System.out.println(\"task\"); } catch (InterruptedException e) { System.out.println(\"Exception handled \" + e); } System.out.println(\"thread is still running after exception...\"); } public static void main(String args[]) { TestIntrpt t1 = new TestIntrpt(); t1.start(); t1.interrupt(); }} ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:10:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Reentrant Monitor in Java According to Sun Microsystems, Java monitors are reentrant means java thread can reuse the same monitor for different synchronized methods if method is called from the method. Advantage of Reentrant Monitor: It eliminates the possibility of single thread deadlocking. Example : class Reentrant { public synchronized void m() { n(); System.out.println(\"this is m() method\"); } public synchronized void n() { System.out.println(\"this is n() method\"); } } public class ReentrantExample { public static void main(String args[]) { final ReentrantExample re = new ReentrantExample(); Thread t1 = new Thread() { //creating thread using annonymous class public void run() { re.m(); }}; //calling m() method of Reentrant class t1.start(); }} ","date":"2019-08-06","objectID":"/notes/java/java_synchronization/:11:0","tags":["Java"],"title":"Java Notes(15) Synchronization","uri":"/notes/java/java_synchronization/"},{"categories":["Java Language"],"content":"Java testing notes","date":"2019-09-25","objectID":"/notes/java/java_testing/","tags":["Java"],"title":"Java Notes(22) Unit Test\u0026 Mockito","uri":"/notes/java/java_testing/"}]